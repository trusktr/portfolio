'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Calendar = undefined;

var _Transform = require('famous/src/core/Transform');

var _Transform2 = _interopRequireDefault(_Transform);

var _Transitionable = require('famous/src/transitions/Transitionable');

var _Transitionable2 = _interopRequireDefault(_Transitionable);

var _Easing = require('famous/src/transitions/Easing');

var _Easing2 = _interopRequireDefault(_Easing);

var _Molecule = require('./Molecule');

var _Molecule2 = _interopRequireDefault(_Molecule);

var _Grid = require('./Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _DoubleSidedPlane = require('./DoubleSidedPlane');

var _DoubleSidedPlane2 = _interopRequireDefault(_DoubleSidedPlane);

var _forLength = require('army-knife/forLength');

var _forLength2 = _interopRequireDefault(_forLength);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A calendar widget for selecting a date (WIP).
 *
 * @class Calendar
 * @extends Molecule
 */
class Calendar extends _Molecule2.default {

    /**
     * Create a new `Calendar` with the given Famo.us-style size array and
     * transition. The transition is the type of animation used when switching
     * between months.
     *
     * @constructor
     * @param {Array} calendarSize A Famo.us-style width/height size array.
     * @param {String} transition The name of the animation transition to use when switching months.
     */
    constructor(calendarSize, transition) {
        super({ size: calendarSize });

        this.transition = transition;
        this.flipSide = 0; // 0 means the initial front faces are showing, 1 means the initial back faces are showing.
        this.columnsRows = [7, 6];
        this.planes = [];

        this._initializeTransitions();
        this._createGrid();

        setTimeout(function () {
            this.transitions[this.transition]();
            setInterval(this.transitions[this.transition], 2000);
        }.bind(this), 800);
    }

    /**
     * Creates the grid used for the layout of the day cells.
     *
     * @private
     */
    _createGrid() {
        const grid = new _Grid2.default(this.columnsRows[0], this.columnsRows[1], this.options.size);

        (0, _forLength2.default)(this.columnsRows[0] * this.columnsRows[1], function (i) {
            const plane = new _DoubleSidedPlane2.default({
                properties: {
                    background: 'teal'
                }
            });
            this.planes.push(plane);
        }.bind(this));

        grid.setChildren(this.planes);
        this.add(grid);
    }

    /**
     * Set up `this.transitions`, containing the available month-to-month
     * transitions.
     *
     * @private
     */
    _initializeTransitions() {
        this.transitions = {
            flipDiagonal: function () {
                this.flipSide = +!this.flipSide;
                // determine which dimension of the grid is shorter and which is longer.
                let shortest = 0;
                let longest;
                this.columnsRows.forEach(function (item, index) {
                    if (item < this.columnsRows[shortest]) {
                        shortest = index;
                    }
                }.bind(this));
                longest = +!shortest;

                // for each diagonal of the grid, flip those cells.
                (0, _forLength2.default)(this.columnsRows[0] + this.columnsRows[1] - 1, function (column) {
                    (0, _forLength2.default)(this.columnsRows[shortest], function (row) {
                        if (column - row >= 0 && column - row < this.columnsRows[longest]) {
                            const plane = this.planes[column - row + this.columnsRows[longest] * row];
                            flipOne(plane, column);
                        }
                    }.bind(this));
                }.bind(this));

                function flipOne(item, column) {
                    if (typeof item.__targetRotation == 'undefined') {
                        item.__targetRotation = new _Transitionable2.default(0);
                    }
                    const rotation = new _Transitionable2.default(item.__targetRotation.get());
                    item.__targetRotation.set(item.__targetRotation.get() + Math.PI);

                    //item.get().transformFrom(function() {
                    //return Transform.rotateY(rotation.get());
                    //});
                    item.children[0].get().transformFrom(function () {
                        return _Transform2.default.rotateY(rotation.get());
                    });
                    item.children[1].get().transformFrom(function () {
                        return _Transform2.default.rotateY(rotation.get() + Math.PI);
                    });

                    setTimeout(function () {
                        rotation.set(item.__targetRotation.get(), { duration: 2000, curve: _Easing2.default.outExpo });
                    }, 0 + 50 * column);
                }
            }.bind(this)
        };
    }
}
exports.Calendar = Calendar; /*
                              * LICENSE
                              *
                              * This Source Code Form is subject to the terms of the Mozilla Public
                              * License, v. 2.0. If a copy of the MPL was not distributed with this
                              * file, You can obtain one at http://mozilla.org/MPL/2.0/.
                              *
                              */

exports.default = Calendar;
//# sourceMappingURL=Calendar.js.map