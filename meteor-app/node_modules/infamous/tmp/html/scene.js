
import styles from './scene-style'
import Motor from '../core/Motor'
import Scene from '../core/Scene'
import Observable from '../core/Observable'
import Sizeable from '../core/Sizeable'
import getWebGlRenderer from '../core/WebGLRenderer'
import MotorHTMLBase, {initMotorHTMLBase, proxyGettersSetters} from './base'
import sleep from 'awaitbox/timers/sleep'

//import * as PIXI from 'pixi.js' // also sets the PIXI global.
//import SVG from 'pixi-svg' // uses the PIXI global, won't work if you don't import the main `pixi.js module`.
import Two from 'two.js/build/two'

initMotorHTMLBase()

const privates = new WeakMap()
const _ = function (instance) {
    if (!privates.get(instance)) { privates.set(instance, {}) }
    return privates.get(instance)
}

var MotorHTMLScene = (function (superclass) {
    function MotorHTMLScene () {
        superclass.apply(this, arguments);
    }

    if ( superclass ) MotorHTMLScene.__proto__ = superclass;
    MotorHTMLScene.prototype = Object.create( superclass && superclass.prototype );
    MotorHTMLScene.prototype.constructor = MotorHTMLScene;

    MotorHTMLScene.prototype.createdCallback = function createdCallback () {
        var this$1 = this;

        superclass.prototype.createdCallback.call(this)

        this._sizePollTask = null
        this._parentSize = {x:0, y:0, z:0}

        // After the imperativeCounterpart is available it needs to register
        // mount into DOM. This is only for MotorHTMLScenes because their
        // imperativeCounterparts are not added to a parent Node.
        // MotorHTMLNodes get their parent connection from their parent in
        // childConnectedCallback.
        this._imperativeCounterpartPromise
            .then(function () {

                if (this$1.imperativeCounterpart._mounted) { return }

                if (this$1.parentNode)
                    { this$1.imperativeCounterpart.mount(this$1.parentNode) }
            })

        // For now, use the same program (with shaders) for all objects.
        // Basically it has position, frag colors, point light, directional
        // light, and ambient light.
        // TODO: maybe call this in `init()`, and destroy webgl stuff in
        // `deinit()`.
        // TODO: The user might enable this by setting the attribute later, so
        // we can't simply rely on having it in createdCallback, we need a
        // getter/setter like node properties.
        this.initWebGl()
    };

    // TODO: we need to deinit webgl too.
    MotorHTMLScene.prototype.initWebGl = function initWebGl () {
        var this$1 = this;

        // TODO: this needs to be cancelable too, search other codes for
        // "mountcancel" to see.
        this.mountPromise.then(function () {
            this$1.webglEnabled = !!this$1.getAttribute('webglenabled')
            if (!this$1.webglEnabled) { return }
            this$1.webGlRendererState = {}
            getWebGlRenderer().initGl(this$1)
        })
    };
    //async initWebGl() {
        //// TODO: this needs to be cancelable too, search other codes for
        //// "mountcancel" to see.
        //await this.mountPromise
        //this.webglEnabled = !!this.getAttribute('webglenabled')
        //if (!this.webglEnabled) return
        //this.webGlRendererState = {}
        //getWebGlRenderer().initGl(this)
    //}

    MotorHTMLScene.prototype._startSizePolling = function _startSizePolling () {
        // NOTE Polling is currently required because there's no other way to do this
        // reliably, not even with MutationObserver. ResizeObserver hasn't
        // landed in browsers yet.
        if (!this._sizePollTask)
            { this._sizePollTask = Motor.addRenderTask(this._checkSize.bind(this)) }
    };

    // NOTE, the Z dimension of a scene doesn't matter, it's a flat plane, so
    // we haven't taken that into consideration here.
    MotorHTMLScene.prototype._checkSize = function _checkSize () {

        // The scene has a parent by the time this is called (see
        // src/core/Scene#mount where _startSizePolling is called)
        const parent = this.parentNode
        const parentSize = this._parentSize
        const style = getComputedStyle(parent)
        const width = parseFloat(style.width)
        const height = parseFloat(style.height)

        // if we have a size change, trigger parentsizechange
        if (parentSize.x != width || parentSize.y != height) {
            parentSize.x = width
            parentSize.y = height

            this.triggerEvent('parentsizechange', Object.assign({}, parentSize))
        }
    };

    MotorHTMLScene.prototype._makeImperativeCounterpart = function _makeImperativeCounterpart () {
        return new Scene({
            _motorHtmlCounterpart: this
        })
    };

    /** @override */
    MotorHTMLScene.prototype.getStyles = function getStyles () {
        return styles
    };

    MotorHTMLScene.prototype.deinit = function deinit () {
        superclass.prototype.deinit.call(this)

        this.imperativeCounterpart.unmount()
    };

    MotorHTMLScene.prototype._stopSizePolling = function _stopSizePolling () {
        Motor.removeRenderTask(this._sizePollTask)
        this._sizePollTask = null
    };

    return MotorHTMLScene;
}(Observable.mixin(MotorHTMLBase)));

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.
proxyGettersSetters(Sizeable, MotorHTMLScene)

import 'document-register-element'
MotorHTMLScene = document.registerElement('motor-scene', MotorHTMLScene)

export {MotorHTMLScene as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NlbmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9odG1sL3NjZW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3NjZW5lLXN0eWxlJ1xuaW1wb3J0IE1vdG9yIGZyb20gJy4uL2NvcmUvTW90b3InXG5pbXBvcnQgU2NlbmUgZnJvbSAnLi4vY29yZS9TY2VuZSdcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZSdcbmltcG9ydCBTaXplYWJsZSBmcm9tICcuLi9jb3JlL1NpemVhYmxlJ1xuaW1wb3J0IGdldFdlYkdsUmVuZGVyZXIgZnJvbSAnLi4vY29yZS9XZWJHTFJlbmRlcmVyJ1xuaW1wb3J0IE1vdG9ySFRNTEJhc2UsIHtpbml0TW90b3JIVE1MQmFzZSwgcHJveHlHZXR0ZXJzU2V0dGVyc30gZnJvbSAnLi9iYXNlJ1xuaW1wb3J0IHNsZWVwIGZyb20gJ2F3YWl0Ym94L3RpbWVycy9zbGVlcCdcblxuLy9pbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnIC8vIGFsc28gc2V0cyB0aGUgUElYSSBnbG9iYWwuXG4vL2ltcG9ydCBTVkcgZnJvbSAncGl4aS1zdmcnIC8vIHVzZXMgdGhlIFBJWEkgZ2xvYmFsLCB3b24ndCB3b3JrIGlmIHlvdSBkb24ndCBpbXBvcnQgdGhlIG1haW4gYHBpeGkuanMgbW9kdWxlYC5cbmltcG9ydCBUd28gZnJvbSAndHdvLmpzL2J1aWxkL3R3bydcblxuaW5pdE1vdG9ySFRNTEJhc2UoKVxuXG5jb25zdCBwcml2YXRlcyA9IG5ldyBXZWFrTWFwKClcbmNvbnN0IF8gPSBpbnN0YW5jZSA9PiB7XG4gICAgaWYgKCFwcml2YXRlcy5nZXQoaW5zdGFuY2UpKSBwcml2YXRlcy5zZXQoaW5zdGFuY2UsIHt9KVxuICAgIHJldHVybiBwcml2YXRlcy5nZXQoaW5zdGFuY2UpXG59XG5cbmNsYXNzIE1vdG9ySFRNTFNjZW5lIGV4dGVuZHMgT2JzZXJ2YWJsZS5taXhpbihNb3RvckhUTUxCYXNlKSB7XG5cbiAgICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNyZWF0ZWRDYWxsYmFjaygpXG5cbiAgICAgICAgdGhpcy5fc2l6ZVBvbGxUYXNrID0gbnVsbFxuICAgICAgICB0aGlzLl9wYXJlbnRTaXplID0ge3g6MCwgeTowLCB6OjB9XG5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGltcGVyYXRpdmVDb3VudGVycGFydCBpcyBhdmFpbGFibGUgaXQgbmVlZHMgdG8gcmVnaXN0ZXJcbiAgICAgICAgLy8gbW91bnQgaW50byBET00uIFRoaXMgaXMgb25seSBmb3IgTW90b3JIVE1MU2NlbmVzIGJlY2F1c2UgdGhlaXJcbiAgICAgICAgLy8gaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0cyBhcmUgbm90IGFkZGVkIHRvIGEgcGFyZW50IE5vZGUuXG4gICAgICAgIC8vIE1vdG9ySFRNTE5vZGVzIGdldCB0aGVpciBwYXJlbnQgY29ubmVjdGlvbiBmcm9tIHRoZWlyIHBhcmVudCBpblxuICAgICAgICAvLyBjaGlsZENvbm5lY3RlZENhbGxiYWNrLlxuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlQ291bnRlcnBhcnRQcm9taXNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX21vdW50ZWQpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQubW91bnQodGhpcy5wYXJlbnROb2RlKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyBGb3Igbm93LCB1c2UgdGhlIHNhbWUgcHJvZ3JhbSAod2l0aCBzaGFkZXJzKSBmb3IgYWxsIG9iamVjdHMuXG4gICAgICAgIC8vIEJhc2ljYWxseSBpdCBoYXMgcG9zaXRpb24sIGZyYWcgY29sb3JzLCBwb2ludCBsaWdodCwgZGlyZWN0aW9uYWxcbiAgICAgICAgLy8gbGlnaHQsIGFuZCBhbWJpZW50IGxpZ2h0LlxuICAgICAgICAvLyBUT0RPOiBtYXliZSBjYWxsIHRoaXMgaW4gYGluaXQoKWAsIGFuZCBkZXN0cm95IHdlYmdsIHN0dWZmIGluXG4gICAgICAgIC8vIGBkZWluaXQoKWAuXG4gICAgICAgIC8vIFRPRE86IFRoZSB1c2VyIG1pZ2h0IGVuYWJsZSB0aGlzIGJ5IHNldHRpbmcgdGhlIGF0dHJpYnV0ZSBsYXRlciwgc29cbiAgICAgICAgLy8gd2UgY2FuJ3Qgc2ltcGx5IHJlbHkgb24gaGF2aW5nIGl0IGluIGNyZWF0ZWRDYWxsYmFjaywgd2UgbmVlZCBhXG4gICAgICAgIC8vIGdldHRlci9zZXR0ZXIgbGlrZSBub2RlIHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMuaW5pdFdlYkdsKClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3ZSBuZWVkIHRvIGRlaW5pdCB3ZWJnbCB0b28uXG4gICAgaW5pdFdlYkdsKCkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIG5lZWRzIHRvIGJlIGNhbmNlbGFibGUgdG9vLCBzZWFyY2ggb3RoZXIgY29kZXMgZm9yXG4gICAgICAgIC8vIFwibW91bnRjYW5jZWxcIiB0byBzZWUuXG4gICAgICAgIHRoaXMubW91bnRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53ZWJnbEVuYWJsZWQgPSAhIXRoaXMuZ2V0QXR0cmlidXRlKCd3ZWJnbGVuYWJsZWQnKVxuICAgICAgICAgICAgaWYgKCF0aGlzLndlYmdsRW5hYmxlZCkgcmV0dXJuXG4gICAgICAgICAgICB0aGlzLndlYkdsUmVuZGVyZXJTdGF0ZSA9IHt9XG4gICAgICAgICAgICBnZXRXZWJHbFJlbmRlcmVyKCkuaW5pdEdsKHRoaXMpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8vYXN5bmMgaW5pdFdlYkdsKCkge1xuICAgICAgICAvLy8vIFRPRE86IHRoaXMgbmVlZHMgdG8gYmUgY2FuY2VsYWJsZSB0b28sIHNlYXJjaCBvdGhlciBjb2RlcyBmb3JcbiAgICAgICAgLy8vLyBcIm1vdW50Y2FuY2VsXCIgdG8gc2VlLlxuICAgICAgICAvL2F3YWl0IHRoaXMubW91bnRQcm9taXNlXG4gICAgICAgIC8vdGhpcy53ZWJnbEVuYWJsZWQgPSAhIXRoaXMuZ2V0QXR0cmlidXRlKCd3ZWJnbGVuYWJsZWQnKVxuICAgICAgICAvL2lmICghdGhpcy53ZWJnbEVuYWJsZWQpIHJldHVyblxuICAgICAgICAvL3RoaXMud2ViR2xSZW5kZXJlclN0YXRlID0ge31cbiAgICAgICAgLy9nZXRXZWJHbFJlbmRlcmVyKCkuaW5pdEdsKHRoaXMpXG4gICAgLy99XG5cbiAgICBfc3RhcnRTaXplUG9sbGluZygpIHtcbiAgICAgICAgLy8gTk9URSBQb2xsaW5nIGlzIGN1cnJlbnRseSByZXF1aXJlZCBiZWNhdXNlIHRoZXJlJ3Mgbm8gb3RoZXIgd2F5IHRvIGRvIHRoaXNcbiAgICAgICAgLy8gcmVsaWFibHksIG5vdCBldmVuIHdpdGggTXV0YXRpb25PYnNlcnZlci4gUmVzaXplT2JzZXJ2ZXIgaGFzbid0XG4gICAgICAgIC8vIGxhbmRlZCBpbiBicm93c2VycyB5ZXQuXG4gICAgICAgIGlmICghdGhpcy5fc2l6ZVBvbGxUYXNrKVxuICAgICAgICAgICAgdGhpcy5fc2l6ZVBvbGxUYXNrID0gTW90b3IuYWRkUmVuZGVyVGFzayh0aGlzLl9jaGVja1NpemUuYmluZCh0aGlzKSlcbiAgICB9XG5cbiAgICAvLyBOT1RFLCB0aGUgWiBkaW1lbnNpb24gb2YgYSBzY2VuZSBkb2Vzbid0IG1hdHRlciwgaXQncyBhIGZsYXQgcGxhbmUsIHNvXG4gICAgLy8gd2UgaGF2ZW4ndCB0YWtlbiB0aGF0IGludG8gY29uc2lkZXJhdGlvbiBoZXJlLlxuICAgIF9jaGVja1NpemUoKSB7XG5cbiAgICAgICAgLy8gVGhlIHNjZW5lIGhhcyBhIHBhcmVudCBieSB0aGUgdGltZSB0aGlzIGlzIGNhbGxlZCAoc2VlXG4gICAgICAgIC8vIHNyYy9jb3JlL1NjZW5lI21vdW50IHdoZXJlIF9zdGFydFNpemVQb2xsaW5nIGlzIGNhbGxlZClcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlXG4gICAgICAgIGNvbnN0IHBhcmVudFNpemUgPSB0aGlzLl9wYXJlbnRTaXplXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS53aWR0aClcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5oZWlnaHQpXG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHNpemUgY2hhbmdlLCB0cmlnZ2VyIHBhcmVudHNpemVjaGFuZ2VcbiAgICAgICAgaWYgKHBhcmVudFNpemUueCAhPSB3aWR0aCB8fCBwYXJlbnRTaXplLnkgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBwYXJlbnRTaXplLnggPSB3aWR0aFxuICAgICAgICAgICAgcGFyZW50U2l6ZS55ID0gaGVpZ2h0XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdwYXJlbnRzaXplY2hhbmdlJywgT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50U2l6ZSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWFrZUltcGVyYXRpdmVDb3VudGVycGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2VuZSh7XG4gICAgICAgICAgICBfbW90b3JIdG1sQ291bnRlcnBhcnQ6IHRoaXNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgfVxuXG4gICAgZGVpbml0KCkge1xuICAgICAgICBzdXBlci5kZWluaXQoKVxuXG4gICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LnVubW91bnQoKVxuICAgIH1cblxuICAgIF9zdG9wU2l6ZVBvbGxpbmcoKSB7XG4gICAgICAgIE1vdG9yLnJlbW92ZVJlbmRlclRhc2sodGhpcy5fc2l6ZVBvbGxUYXNrKVxuICAgICAgICB0aGlzLl9zaXplUG9sbFRhc2sgPSBudWxsXG4gICAgfVxufVxuXG4vLyBUaGlzIGFzc29jaWF0ZXMgdGhlIFRyYW5zZm9ybWFibGUgZ2V0dGVycy9zZXR0ZXJzIHdpdGggdGhlIEhUTUwtQVBJIGNsYXNzZXMsXG4vLyBzbyB0aGF0IHRoZSBzYW1lIGdldHRlcnMvc2V0dGVycyBjYW4gYmUgY2FsbGVkIGZyb20gSFRNTCBzaWRlIG9mIHRoZSBBUEkuXG5wcm94eUdldHRlcnNTZXR0ZXJzKFNpemVhYmxlLCBNb3RvckhUTUxTY2VuZSlcblxuaW1wb3J0ICdkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50J1xuTW90b3JIVE1MU2NlbmUgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ21vdG9yLXNjZW5lJywgTW90b3JIVE1MU2NlbmUpXG5cbmV4cG9ydCB7TW90b3JIVE1MU2NlbmUgYXMgZGVmYXVsdH1cbiJdLCJuYW1lcyI6WyJzdXBlciIsInRoaXMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsT0FBTyxNQUFNLE1BQU0sZUFBZTtBQUNsQyxPQUFPLEtBQUssTUFBTSxlQUFlO0FBQ2pDLE9BQU8sS0FBSyxNQUFNLGVBQWU7QUFDakMsT0FBTyxVQUFVLE1BQU0sb0JBQW9CO0FBQzNDLE9BQU8sUUFBUSxNQUFNLGtCQUFrQjtBQUN2QyxPQUFPLGdCQUFnQixNQUFNLHVCQUF1QjtBQUNwRCxPQUFPLGFBQWEsR0FBRyxpQkFBaUIsRUFBRSxtQkFBbUIsT0FBTyxRQUFRO0FBQzVFLE9BQU8sS0FBSyxNQUFNLHVCQUF1Qjs7OztBQUl6QyxPQUFPLEdBQUcsTUFBTSxrQkFBa0I7O0FBRWxDLGlCQUFpQixFQUFFOztBQUVuQixNQUFNLFFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUM5QixNQUFNLENBQUMsR0FBRyxVQUFBLFFBQVEsQ0FBQSxDQUFDLEFBQUc7SUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENB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