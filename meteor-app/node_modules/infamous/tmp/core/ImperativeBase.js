import ElementManager from './ElementManager'
import Sizeable from './Sizeable'
import Node from './Node'
import Scene from './Scene'
import Motor from './Motor'

// We explicitly use `var` instead of `let` here because it is hoisted for the
// Node and Scene modules. This, along with the following initImperativeBase
// function, allows the circular dependency between this module and the Node and
// Scene modules to work. For details on why, see
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem.
var ImperativeBase

// Here we wrap the definition of the ImperativeBase class with this function in
// order to solve the circular depdendency problem caused by the
// Node<->ImperativeBase and Scene<->ImperativeBase circles. The Node and Scene
// modules call initImperativeBase to ensure that the ImperativeBase declaration
// happens first, and then those modules can use the live binding in their
// declarations.
initImperativeBase()
export function initImperativeBase() {
    if (ImperativeBase) { return }

    const instanceofSymbol = Symbol('instanceofSymbol')

    /**
     * The ImperativeBase class is the base class for the Imperative version of the
     * API, for people who chose to take the all-JavaScript approach and who will
     * not use the HTML-based API (infamous/motor-html).
     *
     * In the future when there is an option to disable the HTML-DOM rendering (and
     * render only WebGL, for example) then the imperative API will be the only API
     * available since the HTML API will be turned off as a result of disabling
     * HTML rendering. Disabling both WebGL and HTML won't make sense, as we'll need
     * at least one of those to render with.
     */
    const ImperativeBaseMixin = function (base) {
        const ParentClass = base
        var ImperativeBase = (function (ParentClass) {
            function ImperativeBase(options) {
                var this$1 = this;
                if ( options === void 0 ) options = {};


                // The presence of a _motorHtmlCounterpart argument signifies that
                // the HTML interface is being used, otherwise the imperative interface
                // here is being used. For example, see MotorHTMLNode. This means the
                // Node and MotorHTMLNode classes are coupled together, but it's in the
                // name of the API that we're supporting.
                var _motorHtmlCounterpart = options._motorHtmlCounterpart;

                ParentClass.call(this, options)

                this._willBeRendered = false

                // Here we create the DOM HTMLElement associated with this
                // Imperative-API Node.
                this._elementManager = new ElementManager(
                    _motorHtmlCounterpart || this._makeElement()
                )
                this._elementManager.element._associateImperativeNode(this)

                // For Nodes, true when this Node is added to a parent AND it
                // has an anancestor Scene that is mounted into DOM. For
                // Scenes, true when mounted into DOM.
                this._mounted = false;

                // For Nodes, a promise that resolves when this Node is
                // attached to a tree that has a root Scene TreeNode *and* when
                // that root Scene has been mounted into the DOM. For Scenes,
                // resolves when mounted into DOM.
                this._mountPromise = null
                this._resolveMountPromise = null
                this._rejectMountPromise = null

                this._awaitingMountPromiseToRender = false
                this._waitingForMountConditions = false

                // See Transformable/Sizeable propertychange event.
                this.on('propertychange', function (prop) {
                    if (
                        prop == 'sizeMode' ||
                        prop == 'absoluteSize' ||
                        prop == 'proportionalSize'
                    ) {
                        this$1._calcSize()
                    }

                    this$1._needsToBeRendered()
                })
            }

            if ( ParentClass ) ImperativeBase.__proto__ = ParentClass;
            ImperativeBase.prototype = Object.create( ParentClass && ParentClass.prototype );
            ImperativeBase.prototype.constructor = ImperativeBase;

            var prototypeAccessors = { mountPromise: {},element: {} };

            /**
             * Subclasses are required to override this. It should return the HTML-API
             * counterpart for this Imperative-API instance. See Node or Scene classes
             * for example.
             *
             * @private
             */
            ImperativeBase.prototype._makeElement = function _makeElement () {
                throw new Error('Subclasses need to override ImperativeBase#_makeElement.')
            };

            /**
             * @readonly
             */
            prototypeAccessors.mountPromise.get = function () {
                var this$1 = this;

                if (!this._mountPromise) {
                    this._mountPromise = new Promise(function (resolve, reject) {
                        this$1._resolveMountPromise = resolve
                        this$1._rejectMountPromise = reject
                    })
                }

                if (!this._mounted)
                    { this._waitForMountThenResolveMountPromise() }
                else if (this._mounted)
                    { this._resolveMountPromise() }

                return this._mountPromise
            };

            ImperativeBase.prototype._waitForMountThenResolveMountPromise = function _waitForMountThenResolveMountPromise () {
                // extended in Node or Scene to await for anything that mount
                // depends on.
            };

            /**
             * @readonly
             */
            prototypeAccessors.element.get = function () {
                return this._elementManager.element
            };

            /**
             * @override
             */
            ImperativeBase.prototype.addChild = function addChild (childNode) {
                if (!(childNode instanceof ImperativeBase)) { return }

                // We cannot add Scenes to Nodes, for now.
                if (childNode instanceof Scene) {
                    throw new Error("\n                        A Scene cannot be added to another Node or Scene (at\n                        least for now). To place a Scene in a Node, just mount\n                        a new Scene onto a MotorHTMLNode with Scene.mount().\n                    ")
                }

                ParentClass.prototype.addChild.call(this, childNode)

                // Pass this parent node's Scene reference (if any, checking this cache
                // first) to the new child and the child's children.
                if (childNode._scene || childNode.scene) {
                    if (childNode._resolveScenePromise)
                        { childNode._resolveScenePromise(childNode._scene) }
                    childNode._giveSceneRefToChildren()
                }

                // Calculate sizing because proportional size might depend on
                // the new parent.
                childNode._calcSize()
                childNode._needsToBeRendered()

                // child should watch the parent for size changes.
                this.on('sizechange', childNode._onParentSizeChange)

                this._elementManager.connectChildElement(childNode)

                return this
            };

            ImperativeBase.prototype.removeChild = function removeChild (childNode, /*private use*/leaveInDom) {
                if (!(childNode instanceof Node)) { return }

                ParentClass.prototype.removeChild.call(this, childNode)

                this.off('sizechange', childNode._onParentSizeChange)

                childNode._resetSceneRef()

                if (childNode._mountPromise) { childNode._rejectMountPromise('mountcancel') }
                if (childNode._mounted) { childNode._elementManager.shouldNotRender() }
                childNode._resetMountPromise()

                if (!leaveInDom)
                    { this._elementManager.disconnectChildElement(childNode) }
            };

            ImperativeBase.prototype._resetMountPromise = function _resetMountPromise () {
                this._mounted = false
                this._mountPromise = null
                this._resolveMountPromise = null
                this._rejectMountPromise = null
                const children = this._children
                for (let i=0, l=children.length; i<l; i+=1) {
                    children[i]._resetMountPromise();
                }
            };

            ImperativeBase.prototype._needsToBeRendered = function _needsToBeRendered () {
                var this$1 = this;

                if (this._awaitingMountPromiseToRender) { return Promise.resolve() }

                const logic = function () {
                    this$1._willBeRendered = true
                    Motor._setNodeToBeRendered(this$1)
                }

                if (!this._mounted) {
                    this._awaitingMountPromiseToRender = true

                    let possibleError = undefined

                    // try
                    return this.mountPromise

                    .then(logic)

                    // catch
                    .catch(function () {
                        if (e == 'mountcancel') { return }
                        else { possibleError = e }
                    })

                    // finally
                    .then(function () {
                        this$1._awaitingMountPromiseToRender = false

                        if (possibleError) { throw possibleError }
                    })
                }

                logic()
                return Promise.resolve()
            };
            //async _needsToBeRendered() {
                //if (this._awaitingMountPromiseToRender) return

                //if (!this._mounted) {
                    //try {
                        //this._awaitingMountPromiseToRender = true
                        //await this.mountPromise
                    //} catch(e) {
                        //if (e == 'mountcancel') return
                        //else throw e
                    //} finally {
                        //this._awaitingMountPromiseToRender = false
                    //}
                //}

                //this._willBeRendered = true
                //Motor._setNodeToBeRendered(this)
            //}

            // This method is used by Motor._renderNodes().
            ImperativeBase.prototype._getAncestorToBeRendered = function _getAncestorToBeRendered () {
                let parent = this._parent

                while (parent) {
                    if (parent._willBeRendered) { return parent }
                    parent = parent._parent
                }

                return false
            };

            ImperativeBase.prototype._render = function _render (timestamp) {
                ParentClass.prototype._render.call(this)
                // applies the transform matrix to the element's style property.
                this._elementManager.applyImperativeNodeProperties(this)
            };

            Object.defineProperties( ImperativeBase.prototype, prototypeAccessors );

            return ImperativeBase;
        }(ParentClass));

        var ref = Object.getOwnPropertyDescriptor(ParentClass.prototype, 'properties');
        var superPropertiesSet = ref.set;

        Object.defineProperties(ImperativeBase.prototype, {

            /**
             * Set all properties of an ImperativeBase instance in one method.
             *
             * @param {Object} properties Properties object - see example.
             *
             * @example
             * node.properties = {
             *   classes: ['open', 'big'],
             * }
             */
            properties: {
                set: function set(properties) {
                    if ( properties === void 0 ) properties = {};

                    superPropertiesSet.call(this, properties)

                    if (properties.classes)
                        { (ref = this._elementManager).setClasses.apply(ref, properties.classes);
                    var ref; }
                },
                configurable: true,
            },
        })

        Object.defineProperty(ImperativeBase, Symbol.hasInstance, {
            value: function(obj) {
                if (this !== ImperativeBase) { return Object.getPrototypeOf(ImperativeBase)[Symbol.hasInstance].call(this, obj) }

                let currentProto = obj

                while(currentProto) {
                    const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                    if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                        { return true }

                    currentProto = Object.getPrototypeOf(currentProto)
                }

                return false
            }
        })

        ImperativeBase[instanceofSymbol] = true

        return ImperativeBase
    }

    ImperativeBase = ImperativeBaseMixin(Sizeable)
    ImperativeBase.mixin = ImperativeBaseMixin

}

export {ImperativeBase as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1wZXJhdGl2ZUJhc2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL0ltcGVyYXRpdmVCYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFbGVtZW50TWFuYWdlciBmcm9tICcuL0VsZW1lbnRNYW5hZ2VyJ1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4vU2l6ZWFibGUnXG5pbXBvcnQgTm9kZSBmcm9tICcuL05vZGUnXG5pbXBvcnQgU2NlbmUgZnJvbSAnLi9TY2VuZSdcbmltcG9ydCBNb3RvciBmcm9tICcuL01vdG9yJ1xuXG4vLyBXZSBleHBsaWNpdGx5IHVzZSBgdmFyYCBpbnN0ZWFkIG9mIGBsZXRgIGhlcmUgYmVjYXVzZSBpdCBpcyBob2lzdGVkIGZvciB0aGVcbi8vIE5vZGUgYW5kIFNjZW5lIG1vZHVsZXMuIFRoaXMsIGFsb25nIHdpdGggdGhlIGZvbGxvd2luZyBpbml0SW1wZXJhdGl2ZUJhc2Vcbi8vIGZ1bmN0aW9uLCBhbGxvd3MgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGlzIG1vZHVsZSBhbmQgdGhlIE5vZGUgYW5kXG4vLyBTY2VuZSBtb2R1bGVzIHRvIHdvcmsuIEZvciBkZXRhaWxzIG9uIHdoeSwgc2VlXG4vLyBodHRwczovL2VzZGlzY3Vzcy5vcmcvdG9waWMvaG93LXRvLXNvbHZlLXRoaXMtYmFzaWMtZXM2LW1vZHVsZS1jaXJjdWxhci1kZXBlbmRlbmN5LXByb2JsZW0uXG52YXIgSW1wZXJhdGl2ZUJhc2VcblxuLy8gSGVyZSB3ZSB3cmFwIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBJbXBlcmF0aXZlQmFzZSBjbGFzcyB3aXRoIHRoaXMgZnVuY3Rpb24gaW5cbi8vIG9yZGVyIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBkZW5kZW5jeSBwcm9ibGVtIGNhdXNlZCBieSB0aGVcbi8vIE5vZGU8LT5JbXBlcmF0aXZlQmFzZSBhbmQgU2NlbmU8LT5JbXBlcmF0aXZlQmFzZSBjaXJjbGVzLiBUaGUgTm9kZSBhbmQgU2NlbmVcbi8vIG1vZHVsZXMgY2FsbCBpbml0SW1wZXJhdGl2ZUJhc2UgdG8gZW5zdXJlIHRoYXQgdGhlIEltcGVyYXRpdmVCYXNlIGRlY2xhcmF0aW9uXG4vLyBoYXBwZW5zIGZpcnN0LCBhbmQgdGhlbiB0aG9zZSBtb2R1bGVzIGNhbiB1c2UgdGhlIGxpdmUgYmluZGluZyBpbiB0aGVpclxuLy8gZGVjbGFyYXRpb25zLlxuaW5pdEltcGVyYXRpdmVCYXNlKClcbmV4cG9ydCBmdW5jdGlvbiBpbml0SW1wZXJhdGl2ZUJhc2UoKSB7XG4gICAgaWYgKEltcGVyYXRpdmVCYXNlKSByZXR1cm5cblxuICAgIGNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG4gICAgLyoqXG4gICAgICogVGhlIEltcGVyYXRpdmVCYXNlIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciB0aGUgSW1wZXJhdGl2ZSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIEFQSSwgZm9yIHBlb3BsZSB3aG8gY2hvc2UgdG8gdGFrZSB0aGUgYWxsLUphdmFTY3JpcHQgYXBwcm9hY2ggYW5kIHdobyB3aWxsXG4gICAgICogbm90IHVzZSB0aGUgSFRNTC1iYXNlZCBBUEkgKGluZmFtb3VzL21vdG9yLWh0bWwpLlxuICAgICAqXG4gICAgICogSW4gdGhlIGZ1dHVyZSB3aGVuIHRoZXJlIGlzIGFuIG9wdGlvbiB0byBkaXNhYmxlIHRoZSBIVE1MLURPTSByZW5kZXJpbmcgKGFuZFxuICAgICAqIHJlbmRlciBvbmx5IFdlYkdMLCBmb3IgZXhhbXBsZSkgdGhlbiB0aGUgaW1wZXJhdGl2ZSBBUEkgd2lsbCBiZSB0aGUgb25seSBBUElcbiAgICAgKiBhdmFpbGFibGUgc2luY2UgdGhlIEhUTUwgQVBJIHdpbGwgYmUgdHVybmVkIG9mZiBhcyBhIHJlc3VsdCBvZiBkaXNhYmxpbmdcbiAgICAgKiBIVE1MIHJlbmRlcmluZy4gRGlzYWJsaW5nIGJvdGggV2ViR0wgYW5kIEhUTUwgd29uJ3QgbWFrZSBzZW5zZSwgYXMgd2UnbGwgbmVlZFxuICAgICAqIGF0IGxlYXN0IG9uZSBvZiB0aG9zZSB0byByZW5kZXIgd2l0aC5cbiAgICAgKi9cbiAgICBjb25zdCBJbXBlcmF0aXZlQmFzZU1peGluID0gYmFzZSA9PiB7XG4gICAgICAgIGNvbnN0IFBhcmVudENsYXNzID0gYmFzZVxuICAgICAgICBjbGFzcyBJbXBlcmF0aXZlQmFzZSBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHByZXNlbmNlIG9mIGEgX21vdG9ySHRtbENvdW50ZXJwYXJ0IGFyZ3VtZW50IHNpZ25pZmllcyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIEhUTUwgaW50ZXJmYWNlIGlzIGJlaW5nIHVzZWQsIG90aGVyd2lzZSB0aGUgaW1wZXJhdGl2ZSBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGlzIGJlaW5nIHVzZWQuIEZvciBleGFtcGxlLCBzZWUgTW90b3JIVE1MTm9kZS4gVGhpcyBtZWFucyB0aGVcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGFuZCBNb3RvckhUTUxOb2RlIGNsYXNzZXMgYXJlIGNvdXBsZWQgdG9nZXRoZXIsIGJ1dCBpdCdzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgdGhlIEFQSSB0aGF0IHdlJ3JlIHN1cHBvcnRpbmcuXG4gICAgICAgICAgICAgICAgY29uc3Qge19tb3Rvckh0bWxDb3VudGVycGFydH0gPSBvcHRpb25zXG5cbiAgICAgICAgICAgICAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lsbEJlUmVuZGVyZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBjcmVhdGUgdGhlIERPTSBIVE1MRWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgICAgICAgICAgICAgIC8vIEltcGVyYXRpdmUtQVBJIE5vZGUuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIgPSBuZXcgRWxlbWVudE1hbmFnZXIoXG4gICAgICAgICAgICAgICAgICAgIF9tb3Rvckh0bWxDb3VudGVycGFydCB8fCB0aGlzLl9tYWtlRWxlbWVudCgpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQuX2Fzc29jaWF0ZUltcGVyYXRpdmVOb2RlKHRoaXMpXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgTm9kZXMsIHRydWUgd2hlbiB0aGlzIE5vZGUgaXMgYWRkZWQgdG8gYSBwYXJlbnQgQU5EIGl0XG4gICAgICAgICAgICAgICAgLy8gaGFzIGFuIGFuYW5jZXN0b3IgU2NlbmUgdGhhdCBpcyBtb3VudGVkIGludG8gRE9NLiBGb3JcbiAgICAgICAgICAgICAgICAvLyBTY2VuZXMsIHRydWUgd2hlbiBtb3VudGVkIGludG8gRE9NLlxuICAgICAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBOb2RlcywgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGlzIE5vZGUgaXNcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2hlZCB0byBhIHRyZWUgdGhhdCBoYXMgYSByb290IFNjZW5lIFRyZWVOb2RlICphbmQqIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGF0IHJvb3QgU2NlbmUgaGFzIGJlZW4gbW91bnRlZCBpbnRvIHRoZSBET00uIEZvciBTY2VuZXMsXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXMgd2hlbiBtb3VudGVkIGludG8gRE9NLlxuICAgICAgICAgICAgICAgIHRoaXMuX21vdW50UHJvbWlzZSA9IG51bGxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlTW91bnRQcm9taXNlID0gbnVsbFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdE1vdW50UHJvbWlzZSA9IG51bGxcblxuICAgICAgICAgICAgICAgIHRoaXMuX2F3YWl0aW5nTW91bnRQcm9taXNlVG9SZW5kZXIgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdGb3JNb3VudENvbmRpdGlvbnMgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgLy8gU2VlIFRyYW5zZm9ybWFibGUvU2l6ZWFibGUgcHJvcGVydHljaGFuZ2UgZXZlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncHJvcGVydHljaGFuZ2UnLCBwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9PSAnc2l6ZU1vZGUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID09ICdhYnNvbHV0ZVNpemUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID09ICdwcm9wb3J0aW9uYWxTaXplJ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGNTaXplKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzVG9CZVJlbmRlcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN1YmNsYXNzZXMgYXJlIHJlcXVpcmVkIHRvIG92ZXJyaWRlIHRoaXMuIEl0IHNob3VsZCByZXR1cm4gdGhlIEhUTUwtQVBJXG4gICAgICAgICAgICAgKiBjb3VudGVycGFydCBmb3IgdGhpcyBJbXBlcmF0aXZlLUFQSSBpbnN0YW5jZS4gU2VlIE5vZGUgb3IgU2NlbmUgY2xhc3Nlc1xuICAgICAgICAgICAgICogZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX21ha2VFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBuZWVkIHRvIG92ZXJyaWRlIEltcGVyYXRpdmVCYXNlI19tYWtlRWxlbWVudC4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQgbW91bnRQcm9taXNlKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbW91bnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdW50UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVNb3VudFByb21pc2UgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RNb3VudFByb21pc2UgPSByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vdW50ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhaXRGb3JNb3VudFRoZW5SZXNvbHZlTW91bnRQcm9taXNlKClcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9tb3VudGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlTW91bnRQcm9taXNlKClcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb3VudFByb21pc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3dhaXRGb3JNb3VudFRoZW5SZXNvbHZlTW91bnRQcm9taXNlKCkge1xuICAgICAgICAgICAgICAgIC8vIGV4dGVuZGVkIGluIE5vZGUgb3IgU2NlbmUgdG8gYXdhaXQgZm9yIGFueXRoaW5nIHRoYXQgbW91bnRcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmRzIG9uLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRDaGlsZChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZE5vZGUgaW5zdGFuY2VvZiBJbXBlcmF0aXZlQmFzZSkpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFkZCBTY2VuZXMgdG8gTm9kZXMsIGZvciBub3cuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIFNjZW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgICAgICAgICBBIFNjZW5lIGNhbm5vdCBiZSBhZGRlZCB0byBhbm90aGVyIE5vZGUgb3IgU2NlbmUgKGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFzdCBmb3Igbm93KS4gVG8gcGxhY2UgYSBTY2VuZSBpbiBhIE5vZGUsIGp1c3QgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgbmV3IFNjZW5lIG9udG8gYSBNb3RvckhUTUxOb2RlIHdpdGggU2NlbmUubW91bnQoKS5cbiAgICAgICAgICAgICAgICAgICAgYClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdXBlci5hZGRDaGlsZChjaGlsZE5vZGUpXG5cbiAgICAgICAgICAgICAgICAvLyBQYXNzIHRoaXMgcGFyZW50IG5vZGUncyBTY2VuZSByZWZlcmVuY2UgKGlmIGFueSwgY2hlY2tpbmcgdGhpcyBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIGZpcnN0KSB0byB0aGUgbmV3IGNoaWxkIGFuZCB0aGUgY2hpbGQncyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9zY2VuZSB8fCBjaGlsZE5vZGUuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5fcmVzb2x2ZVNjZW5lUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5fcmVzb2x2ZVNjZW5lUHJvbWlzZShjaGlsZE5vZGUuX3NjZW5lKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX2dpdmVTY2VuZVJlZlRvQ2hpbGRyZW4oKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzaXppbmcgYmVjYXVzZSBwcm9wb3J0aW9uYWwgc2l6ZSBtaWdodCBkZXBlbmQgb25cbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX2NhbGNTaXplKClcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX25lZWRzVG9CZVJlbmRlcmVkKClcblxuICAgICAgICAgICAgICAgIC8vIGNoaWxkIHNob3VsZCB3YXRjaCB0aGUgcGFyZW50IGZvciBzaXplIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgdGhpcy5vbignc2l6ZWNoYW5nZScsIGNoaWxkTm9kZS5fb25QYXJlbnRTaXplQ2hhbmdlKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIuY29ubmVjdENoaWxkRWxlbWVudChjaGlsZE5vZGUpXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW1vdmVDaGlsZChjaGlsZE5vZGUsIC8qcHJpdmF0ZSB1c2UqL2xlYXZlSW5Eb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZE5vZGUgaW5zdGFuY2VvZiBOb2RlKSkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICBzdXBlci5yZW1vdmVDaGlsZChjaGlsZE5vZGUpXG5cbiAgICAgICAgICAgICAgICB0aGlzLm9mZignc2l6ZWNoYW5nZScsIGNoaWxkTm9kZS5fb25QYXJlbnRTaXplQ2hhbmdlKVxuXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9yZXNldFNjZW5lUmVmKClcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuX21vdW50UHJvbWlzZSkgY2hpbGROb2RlLl9yZWplY3RNb3VudFByb21pc2UoJ21vdW50Y2FuY2VsJylcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9tb3VudGVkKSBjaGlsZE5vZGUuX2VsZW1lbnRNYW5hZ2VyLnNob3VsZE5vdFJlbmRlcigpXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9yZXNldE1vdW50UHJvbWlzZSgpXG5cbiAgICAgICAgICAgICAgICBpZiAoIWxlYXZlSW5Eb20pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmRpc2Nvbm5lY3RDaGlsZEVsZW1lbnQoY2hpbGROb2RlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfcmVzZXRNb3VudFByb21pc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91bnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91bnRQcm9taXNlID0gbnVsbFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVNb3VudFByb21pc2UgPSBudWxsXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0TW91bnRQcm9taXNlID0gbnVsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX3Jlc2V0TW91bnRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfbmVlZHNUb0JlUmVuZGVyZWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F3YWl0aW5nTW91bnRQcm9taXNlVG9SZW5kZXIpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9naWMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpbGxCZVJlbmRlcmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBNb3Rvci5fc2V0Tm9kZVRvQmVSZW5kZXJlZCh0aGlzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hd2FpdGluZ01vdW50UHJvbWlzZVRvUmVuZGVyID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NzaWJsZUVycm9yID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdW50UHJvbWlzZVxuXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGxvZ2ljKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PSAnbW91bnRjYW5jZWwnKSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcG9zc2libGVFcnJvciA9IGVcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5hbGx5XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F3YWl0aW5nTW91bnRQcm9taXNlVG9SZW5kZXIgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVFcnJvcikgdGhyb3cgcG9zc2libGVFcnJvclxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvZ2ljKClcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYXN5bmMgX25lZWRzVG9CZVJlbmRlcmVkKCkge1xuICAgICAgICAgICAgICAgIC8vaWYgKHRoaXMuX2F3YWl0aW5nTW91bnRQcm9taXNlVG9SZW5kZXIpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgLy9pZiAoIXRoaXMuX21vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLl9hd2FpdGluZ01vdW50UHJvbWlzZVRvUmVuZGVyID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hd2FpdCB0aGlzLm1vdW50UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvL30gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoZSA9PSAnbW91bnRjYW5jZWwnKSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxzZSB0aHJvdyBlXG4gICAgICAgICAgICAgICAgICAgIC8vfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fYXdhaXRpbmdNb3VudFByb21pc2VUb1JlbmRlciA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgLy90aGlzLl93aWxsQmVSZW5kZXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAvL01vdG9yLl9zZXROb2RlVG9CZVJlbmRlcmVkKHRoaXMpXG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBieSBNb3Rvci5fcmVuZGVyTm9kZXMoKS5cbiAgICAgICAgICAgIF9nZXRBbmNlc3RvclRvQmVSZW5kZXJlZCgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5fcGFyZW50XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuX3dpbGxCZVJlbmRlcmVkKSByZXR1cm4gcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9yZW5kZXIodGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuX3JlbmRlcigpXG4gICAgICAgICAgICAgICAgLy8gYXBwbGllcyB0aGUgdHJhbnNmb3JtIG1hdHJpeCB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmFwcGx5SW1wZXJhdGl2ZU5vZGVQcm9wZXJ0aWVzKHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7c2V0OiBzdXBlclByb3BlcnRpZXNTZXR9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihQYXJlbnRDbGFzcy5wcm90b3R5cGUsICdwcm9wZXJ0aWVzJylcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbXBlcmF0aXZlQmFzZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIHByb3BlcnRpZXMgb2YgYW4gSW1wZXJhdGl2ZUJhc2UgaW5zdGFuY2UgaW4gb25lIG1ldGhvZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG9iamVjdCAtIHNlZSBleGFtcGxlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBub2RlLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgKiAgIGNsYXNzZXM6IFsnb3BlbicsICdiaWcnXSxcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHNldChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJQcm9wZXJ0aWVzU2V0LmNhbGwodGhpcywgcHJvcGVydGllcylcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5jbGFzc2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIuc2V0Q2xhc3NlcyguLi5wcm9wZXJ0aWVzLmNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1wZXJhdGl2ZUJhc2UsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzICE9PSBJbXBlcmF0aXZlQmFzZSkgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihJbXBlcmF0aXZlQmFzZSlbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHRoaXMsIG9iailcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UHJvdG8gPSBvYmpcblxuICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRQcm90bykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50UHJvdG8sIFwiY29uc3RydWN0b3JcIilcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLnZhbHVlICYmIGRlc2MudmFsdWUuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VvZlN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50UHJvdG8pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgSW1wZXJhdGl2ZUJhc2VbaW5zdGFuY2VvZlN5bWJvbF0gPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuIEltcGVyYXRpdmVCYXNlXG4gICAgfVxuXG4gICAgSW1wZXJhdGl2ZUJhc2UgPSBJbXBlcmF0aXZlQmFzZU1peGluKFNpemVhYmxlKVxuICAgIEltcGVyYXRpdmVCYXNlLm1peGluID0gSW1wZXJhdGl2ZUJhc2VNaXhpblxuXG59XG5cbmV4cG9ydCB7SW1wZXJhdGl2ZUJhc2UgYXMgZGVmYXVsdH1cbiJdLCJuYW1lcyI6WyJzdXBlciIsInRoaXMiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sY0FBYyxNQUFNLGtCQUFrQjtBQUM3QyxPQUFPLFFBQVEsTUFBTSxZQUFZO0FBQ2pDLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFDekIsT0FBTyxLQUFLLE1BQU0sU0FBUztBQUMzQixPQUFPLEtBQUssTUFBTSxTQUFTOzs7Ozs7O0FBTzNCLElBQUksY0FBYzs7Ozs7Ozs7QUFRbEIs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