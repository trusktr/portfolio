const instanceofSymbol = Symbol('instanceofSymbol')

const TreeNodeMixin = function (base) {
    var TreeNode = (function (base) {
        function TreeNode(options) {
            if ( options === void 0 ) options = {};

            base.call(this, options)
            this._parent = null // default to no parent.
            this._children = [];
        }

        if ( base ) TreeNode.__proto__ = base;
        TreeNode.prototype = Object.create( base && base.prototype );
        TreeNode.prototype.constructor = TreeNode;

        var prototypeAccessors = { parent: {},children: {},childCount: {} };

        /**
         * this._parent is protected (node's can access other node._parent).
         * The user should use the addChild methods, which automatically handles
         * setting a parent.
         *
         * @readonly
         */
        prototypeAccessors.parent.get = function () {
            return this._parent
        };

        /**
         * @readonly
         */
        prototypeAccessors.children.get = function () {
            // return a new array, so that the user modifying it doesn't affect
            // this node's actual children.
            return [].concat( this._children )
        };

        /**
         * Add a child node to this TreeNode.
         *
         * @param {TreeNode} childNode The child node to add.
         */
        TreeNode.prototype.addChild = function addChild (childNode) {

            if (! (childNode instanceof TreeNode))
                { throw new TypeError('TreeNode.addChild expects the childNode argument to be a TreeNode instance.') }

            if (childNode._parent === this)
                { throw new ReferenceError('childNode is already a child of this parent.') }

            if (childNode._parent)
                { childNode._parent.removeChild(childNode) }

            childNode._parent = this;

            this._children.push(childNode);

            return this
        };

        /**
         * Add all the child nodes in the given array to this node.
         *
         * @param {Array.TreeNode} nodes The nodes to add.
         */
        TreeNode.prototype.addChildren = function addChildren (nodes) {
            var this$1 = this;

            nodes.forEach(function (node) { return this$1.addChild(node); })
            return this
        };

        /**
         * Remove a child node from this node.
         *
         * @param {TreeNode} childNode The node to remove.
         */
        TreeNode.prototype.removeChild = function removeChild (childNode) {
            if (! (childNode instanceof TreeNode))
                { throw new Error("\n                    TreeNode.removeChild expects the childNode argument to be an\n                    instance of TreeNode. There should only be TreeNodes in the\n                    tree.\n                ") }

            if (childNode._parent !== this)
                { throw new ReferenceError('childNode is not a child of this parent.') }

            childNode._parent = null
            this._children.splice(this._children.indexOf(childNode), 1);

            return this
        };

        /**
         * Remove all the child nodes in the given array from this node.
         *
         * @param {Array.TreeNode} nodes The nodes to remove.
         */
        TreeNode.prototype.removeChildren = function removeChildren (nodes) {
            var this$1 = this;

            nodes.forEach(function (node) { return this$1.removeChild(node); })
            return this
        };

        /**
         * Shortcut to remove all children.
         */
        TreeNode.prototype.removeAllChildren = function removeAllChildren () {
            this.removeChildren(this._children)
            return this
        };

        /**
         * @readonly
         * @return {number} How many children this TreeNode has.
         */
        prototypeAccessors.childCount.get = function () {
            return this._children.length
        };

        Object.defineProperties( TreeNode.prototype, prototypeAccessors );

        return TreeNode;
    }(base));

    Object.defineProperty(TreeNode, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== TreeNode) { return Object.getPrototypeOf(TreeNode)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    TreeNode[instanceofSymbol] = true

    return TreeNode
}

const TreeNode = TreeNodeMixin((function () {
    function anonymous () {}

    return anonymous;
}()))
TreeNode.mixin = TreeNodeMixin

export {TreeNode as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJlZU5vZGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1RyZWVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG5jb25zdCBUcmVlTm9kZU1peGluID0gYmFzZSA9PiB7XG4gICAgY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsIC8vIGRlZmF1bHQgdG8gbm8gcGFyZW50LlxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzLl9wYXJlbnQgaXMgcHJvdGVjdGVkIChub2RlJ3MgY2FuIGFjY2VzcyBvdGhlciBub2RlLl9wYXJlbnQpLlxuICAgICAgICAgKiBUaGUgdXNlciBzaG91bGQgdXNlIHRoZSBhZGRDaGlsZCBtZXRob2RzLCB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXNcbiAgICAgICAgICogc2V0dGluZyBhIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGFycmF5LCBzbyB0aGF0IHRoZSB1c2VyIG1vZGlmeWluZyBpdCBkb2Vzbid0IGFmZmVjdFxuICAgICAgICAgICAgLy8gdGhpcyBub2RlJ3MgYWN0dWFsIGNoaWxkcmVuLlxuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9jaGlsZHJlbl1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjaGlsZCBub2RlIHRvIHRoaXMgVHJlZU5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkTm9kZSBUaGUgY2hpbGQgbm9kZSB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDaGlsZCAoY2hpbGROb2RlKSB7XG5cbiAgICAgICAgICAgIGlmICghIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJlZU5vZGUuYWRkQ2hpbGQgZXhwZWN0cyB0aGUgY2hpbGROb2RlIGFyZ3VtZW50IHRvIGJlIGEgVHJlZU5vZGUgaW5zdGFuY2UuJylcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5fcGFyZW50ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignY2hpbGROb2RlIGlzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHBhcmVudC4nKVxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKVxuXG4gICAgICAgICAgICBjaGlsZE5vZGUuX3BhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGROb2RlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYWxsIHRoZSBjaGlsZCBub2RlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdG8gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LlRyZWVOb2RlfSBub2RlcyBUaGUgbm9kZXMgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2hpbGRyZW4obm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLmFkZENoaWxkKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBjaGlsZCBub2RlIGZyb20gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZE5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAoISAoY2hpbGROb2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgICAgIFRyZWVOb2RlLnJlbW92ZUNoaWxkIGV4cGVjdHMgdGhlIGNoaWxkTm9kZSBhcmd1bWVudCB0byBiZSBhblxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSBvZiBUcmVlTm9kZS4gVGhlcmUgc2hvdWxkIG9ubHkgYmUgVHJlZU5vZGVzIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICB0cmVlLlxuICAgICAgICAgICAgICAgIGApXG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuX3BhcmVudCAhPT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2NoaWxkTm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIHBhcmVudC4nKVxuXG4gICAgICAgICAgICBjaGlsZE5vZGUuX3BhcmVudCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZSh0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkTm9kZSksIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbGwgdGhlIGNoaWxkIG5vZGVzIGluIHRoZSBnaXZlbiBhcnJheSBmcm9tIHRoaXMgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS5UcmVlTm9kZX0gbm9kZXMgVGhlIG5vZGVzIHRvIHJlbW92ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKG5vZGVzKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5yZW1vdmVDaGlsZChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgdG8gcmVtb3ZlIGFsbCBjaGlsZHJlbi5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFsbENoaWxkcmVuKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgY2hpbGRyZW4gdGhpcyBUcmVlTm9kZSBoYXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2hpbGRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmVlTm9kZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBUcmVlTm9kZSkgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmVlTm9kZSlbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHRoaXMsIG9iailcblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm90byA9IG9ialxuXG4gICAgICAgICAgICB3aGlsZShjdXJyZW50UHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50UHJvdG8sIFwiY29uc3RydWN0b3JcIilcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2MudmFsdWUgJiYgZGVzYy52YWx1ZS5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZW9mU3ltYm9sKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50UHJvdG8pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIFRyZWVOb2RlW2luc3RhbmNlb2ZTeW1ib2xdID0gdHJ1ZVxuXG4gICAgcmV0dXJuIFRyZWVOb2RlXG59XG5cbmNvbnN0IFRyZWVOb2RlID0gVHJlZU5vZGVNaXhpbihjbGFzc3t9KVxuVHJlZU5vZGUubWl4aW4gPSBUcmVlTm9kZU1peGluXG5cbmV4cG9ydCB7VHJlZU5vZGUgYXMgZGVmYXVsdH1cbiJdLCJuYW1lcyI6WyJzdXBlciIsInRoaXMiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDOztBQUVuRCxNQUFNLGFBQWEsR0FBRyxVQUFBLElBQUksQ0FBQSxDQUFDLEFBQUc7SUFDMUIsSUFBTSxRQUFRLEdBQWE7UUFBQyxBQUV4QixpQkFBVyxDQUFDLE9BQVksRUFBRSxDQUFQOzZDQUFBLEdBQUcsRUFBRTtBQUFHO1lBQ3ZCQSxJQUFLLEtBQUEsQ0FBQyxNQUFBLE9BQU8sQ0FBQztZQUNkLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFB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