import XYZValues from './XYZValues'
import Sizeable from './Sizeable'
import { makeLowercaseSetterAliases } from './Utility'

const instanceofSymbol = Symbol('instanceofSymbol')

const TransformableMixin = function (base) {

    // Transformable extends TreeNode (indirectly through Sizeable) because it
    // needs to be aware of its _parent when calculating align adjustments.
    const ParentClass = Sizeable.mixin(base)
    var Transformable = (function (ParentClass) {
        function Transformable(options) {
            if ( options === void 0 ) options = {};

            ParentClass.call(this, options)

            this._worldMatrix = null
        }

        if ( ParentClass ) Transformable.__proto__ = ParentClass;
        Transformable.prototype = Object.create( ParentClass && ParentClass.prototype );
        Transformable.prototype.constructor = Transformable;

        Transformable.prototype._setDefaultProperties = function _setDefaultProperties () {
            ParentClass.prototype._setDefaultProperties.call(this)

            Object.assign(this._properties, {
                position:   new XYZValues(0, 0, 0),
                rotation:   new XYZValues(0, 0, 0),
                scale:      new XYZValues(1, 1, 1),
                origin:     new XYZValues(0.5, 0.5, 0.5),
                align:      new XYZValues(0, 0, 0),
                mountPoint: new XYZValues(0, 0, 0),
                opacity:    1,
                transform:  new window.DOMMatrix,
            })
        };

        Transformable.prototype._setPropertyObservers = function _setPropertyObservers () {
            var this$1 = this;

            ParentClass.prototype._setPropertyObservers.call(this)

            this._properties.position.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'position'); })
            this._properties.rotation.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'rotation'); })
            this._properties.scale.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'scale'); })
            this._properties.origin.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'origin'); })
            this._properties.align.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'align'); })
            this._properties.mountPoint.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'mountPoint'); })
        };

        /**
         * Takes all the current component values (position, rotation, etc) and
         * calculates a transformation DOMMatrix from them. See "W3C Geometry
         * Interfaces" to learn about DOMMatrix.
         *
         * @method
         * @private
         * @memberOf Node
         */
        Transformable.prototype._calculateMatrix = function _calculateMatrix () {
            const matrix = new window.DOMMatrix
            const properties = this._properties

            const alignAdjustment = [0,0,0]
            if (this._parent) { // The root Scene doesn't have a parent, for example.
                const parentSize = this._parent._calculatedSize
                var align = properties.align;
                alignAdjustment[0] = parentSize.x * align.x
                alignAdjustment[1] = parentSize.y * align.y
                alignAdjustment[2] = parentSize.z * align.z
            }

            const mountPointAdjustment = [0,0,0]
            const thisSize = this._calculatedSize
            var mountPoint = properties.mountPoint;
            mountPointAdjustment[0] = thisSize.x * mountPoint.x
            mountPointAdjustment[1] = thisSize.y * mountPoint.y
            mountPointAdjustment[2] = thisSize.z * mountPoint.z

            const appliedPosition = []
            var position = properties.position;
            appliedPosition[0] = position.x + alignAdjustment[0] - mountPointAdjustment[0]
            appliedPosition[1] = position.y + alignAdjustment[1] - mountPointAdjustment[1]
            appliedPosition[2] = position.z + alignAdjustment[2] - mountPointAdjustment[2]

            matrix.translateSelf(appliedPosition[0], appliedPosition[1], appliedPosition[2])

            // origin calculation will go here:
            // - move by negative origin before rotating.

            // apply each axis rotation, in the x,y,z order.
            var rotation = properties.rotation;
            matrix.rotateAxisAngleSelf(1,0,0, rotation.x)
            matrix.rotateAxisAngleSelf(0,1,0, rotation.y)
            matrix.rotateAxisAngleSelf(0,0,1, rotation.z)

            // origin calculation will go here:
            // - move by positive origin after rotating.

            return matrix
        };

        // TODO: fix _isIdentity in DOMMatrix, it is returning true even if false.
        Transformable.prototype._calculateWorldMatricesInSubtree = function _calculateWorldMatricesInSubtree () {
            this._calculateWorldMatrixFromParent()

            const children = this._children
            for (let i=0, l=children.length; i<l; i+=1) {
                children[i]._calculateWorldMatricesInSubtree()
            }
        };

        Transformable.prototype._calculateWorldMatrixFromParent = function _calculateWorldMatrixFromParent () {
            const parent = this._parent

            if (parent instanceof Transformable)
                //this._worldMatrix = parent._worldMatrix.multiply(this._properties.transform)
                { this._worldMatrix = this._properties.transform.multiply(parent._worldMatrix) }
            else // otherwise parent is the Scene, which is Sizeable, not Transformable
                { this._worldMatrix = this._properties.transform }
        };

        Transformable.prototype._render = function _render () {
            ParentClass.prototype._render.call(this)

            // TODO: only run this when necessary (f.e. not if only opacity
            // changed)
            this._properties.transform = this._calculateMatrix()
        };

        return Transformable;
    }(ParentClass));

    var ref = Object.getOwnPropertyDescriptor(ParentClass.prototype, 'properties');
    var superPropertiesSet = ref.set;

    // We set accessors manually because Buble doesn't make them configurable
    // as per spec. Additionally we're maing these ones enumerable.
    Object.defineProperties(Transformable.prototype, {

        /**
         * Set the position of the Transformable.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis position to apply.
         * @param {number} [newValue.y] The y-axis position to apply.
         * @param {number} [newValue.z] The z-axis position to apply.
         */
        position: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'position', newValue)
            },
            get: function get() {
                return this._properties.position
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis rotation to apply.
         * @param {number} [newValue.y] The y-axis rotation to apply.
         * @param {number} [newValue.z] The z-axis rotation to apply.
         */
        rotation: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'rotation', newValue)
            },
            get: function get() {
                return this._properties.rotation
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis scale to apply.
         * @param {number} [newValue.y] The y-axis scale to apply.
         * @param {number} [newValue.z] The z-axis scale to apply.
         */
        scale: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'scale', newValue)
            },
            get: function get() {
                return this._properties.scale
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set this Node's opacity.
         *
         * @param {number} opacity A floating point number between 0 and 1
         * (inclusive). 0 is fully transparent, 1 is fully opaque.
         */
        opacity: {
            set: function set(newValue) {
                if (!isRealNumber(newValue)) { newValue = undefined }
                this._setPropertySingle(Transformable, 'opacity', newValue, 'number')
            },
            get: function get() {
                return this._properties.opacity
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the alignment of the Node. This determines at which point in this
         * Node's parent that this Node is mounted.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis align to apply.
         * @param {number} [newValue.y] The y-axis align to apply.
         * @param {number} [newValue.z] The z-axis align to apply.
         */
        align: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'align', newValue)
            },
            get: function get() {
                return this._properties.align
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the mount point of the Node.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis mountPoint to apply.
         * @param {number} [newValue.y] The y-axis mountPoint to apply.
         * @param {number} [newValue.z] The z-axis mountPoint to apply.
         */
        mountPoint: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'mountPoint', newValue)
            },
            get: function get() {
                return this._properties.mountPoint
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set all properties of a Transformable in one method.
         *
         * @param {Object} properties Properties object - see example.
         *
         * @example
         * node.properties = {
         *   position: {x:200, y:300, z:100},
         *   rotation: {z:35},
         *   scale: {y:2},
         *   opacity: .9,
         * }
         */
        properties: {
            set: function set(properties) {
                if ( properties === void 0 ) properties = {};

                superPropertiesSet.call(this, properties)

                if (properties.position)
                    { this.position = properties.position }

                if (properties.rotation)
                    { this.rotation = properties.rotation }

                if (properties.scale)
                    { this.scale = properties.scale }

                if (properties.origin)
                    { this.origin = properties.origin }

                if (properties.align)
                    { this.align = properties.align }

                if (properties.mountPoint)
                    { this.mountPoint = properties.mountPoint }

                if (properties.opacity)
                    { this.opacity = properties.opacity }
            },
            // no need for a properties getter.
            configurable: true,
        },
    })

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    makeLowercaseSetterAliases(Transformable.prototype)

    Object.defineProperty(Transformable, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== Transformable) { return Object.getPrototypeOf(Transformable)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    Transformable[instanceofSymbol] = true

    return Transformable
}

function isRealNumber(num) {
    if (
        typeof num != 'number'
        || Object.is(num, NaN)
        || Object.is(num, Infinity)
    ) { return false }
    return true
}

const Transformable = TransformableMixin((function () {
    function anonymous () {}

    return anonymous;
}()))
Transformable.mixin = TransformableMixin

export {Transformable as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtYWJsZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWFlaVmFsdWVzIGZyb20gJy4vWFlaVmFsdWVzJ1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4vU2l6ZWFibGUnXG5pbXBvcnQgeyBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyB9IGZyb20gJy4vVXRpbGl0eSdcblxuY29uc3QgaW5zdGFuY2VvZlN5bWJvbCA9IFN5bWJvbCgnaW5zdGFuY2VvZlN5bWJvbCcpXG5cbmNvbnN0IFRyYW5zZm9ybWFibGVNaXhpbiA9IGJhc2UgPT4ge1xuXG4gICAgLy8gVHJhbnNmb3JtYWJsZSBleHRlbmRzIFRyZWVOb2RlIChpbmRpcmVjdGx5IHRocm91Z2ggU2l6ZWFibGUpIGJlY2F1c2UgaXRcbiAgICAvLyBuZWVkcyB0byBiZSBhd2FyZSBvZiBpdHMgX3BhcmVudCB3aGVuIGNhbGN1bGF0aW5nIGFsaWduIGFkanVzdG1lbnRzLlxuICAgIGNvbnN0IFBhcmVudENsYXNzID0gU2l6ZWFibGUubWl4aW4oYmFzZSlcbiAgICBjbGFzcyBUcmFuc2Zvcm1hYmxlIGV4dGVuZHMgUGFyZW50Q2xhc3Mge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgc3VwZXIob3B0aW9ucylcblxuICAgICAgICAgICAgdGhpcy5fd29ybGRNYXRyaXggPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0RGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBzdXBlci5fc2V0RGVmYXVsdFByb3BlcnRpZXMoKVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogICBuZXcgWFlaVmFsdWVzKDAsIDAsIDApLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiAgIG5ldyBYWVpWYWx1ZXMoMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgc2NhbGU6ICAgICAgbmV3IFhZWlZhbHVlcygxLCAxLCAxKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46ICAgICBuZXcgWFlaVmFsdWVzKDAuNSwgMC41LCAwLjUpLFxuICAgICAgICAgICAgICAgIGFsaWduOiAgICAgIG5ldyBYWVpWYWx1ZXMoMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgbW91bnRQb2ludDogbmV3IFhZWlZhbHVlcygwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAgICAxLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogIG5ldyB3aW5kb3cuRE9NTWF0cml4LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRQcm9wZXJ0eU9ic2VydmVycygpIHtcbiAgICAgICAgICAgIHN1cGVyLl9zZXRQcm9wZXJ0eU9ic2VydmVycygpXG5cbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMucG9zaXRpb24ub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ3Bvc2l0aW9uJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnJvdGF0aW9uLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdyb3RhdGlvbicpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5zY2FsZS5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAnc2NhbGUnKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMub3JpZ2luLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdvcmlnaW4nKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuYWxpZ24ub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ2FsaWduJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLm1vdW50UG9pbnQub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ21vdW50UG9pbnQnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhbGwgdGhlIGN1cnJlbnQgY29tcG9uZW50IHZhbHVlcyAocG9zaXRpb24sIHJvdGF0aW9uLCBldGMpIGFuZFxuICAgICAgICAgKiBjYWxjdWxhdGVzIGEgdHJhbnNmb3JtYXRpb24gRE9NTWF0cml4IGZyb20gdGhlbS4gU2VlIFwiVzNDIEdlb21ldHJ5XG4gICAgICAgICAqIEludGVyZmFjZXNcIiB0byBsZWFybiBhYm91dCBET01NYXRyaXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlck9mIE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIF9jYWxjdWxhdGVNYXRyaXggKCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgIGNvbnN0IGFsaWduQWRqdXN0bWVudCA9IFswLDAsMF1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHsgLy8gVGhlIHJvb3QgU2NlbmUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTaXplID0gdGhpcy5fcGFyZW50Ll9jYWxjdWxhdGVkU2l6ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHthbGlnbn0gPSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgYWxpZ25BZGp1c3RtZW50WzBdID0gcGFyZW50U2l6ZS54ICogYWxpZ24ueFxuICAgICAgICAgICAgICAgIGFsaWduQWRqdXN0bWVudFsxXSA9IHBhcmVudFNpemUueSAqIGFsaWduLnlcbiAgICAgICAgICAgICAgICBhbGlnbkFkanVzdG1lbnRbMl0gPSBwYXJlbnRTaXplLnogKiBhbGlnbi56XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1vdW50UG9pbnRBZGp1c3RtZW50ID0gWzAsMCwwXVxuICAgICAgICAgICAgY29uc3QgdGhpc1NpemUgPSB0aGlzLl9jYWxjdWxhdGVkU2l6ZVxuICAgICAgICAgICAgY29uc3Qge21vdW50UG9pbnR9ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgbW91bnRQb2ludEFkanVzdG1lbnRbMF0gPSB0aGlzU2l6ZS54ICogbW91bnRQb2ludC54XG4gICAgICAgICAgICBtb3VudFBvaW50QWRqdXN0bWVudFsxXSA9IHRoaXNTaXplLnkgKiBtb3VudFBvaW50LnlcbiAgICAgICAgICAgIG1vdW50UG9pbnRBZGp1c3RtZW50WzJdID0gdGhpc1NpemUueiAqIG1vdW50UG9pbnQuelxuXG4gICAgICAgICAgICBjb25zdCBhcHBsaWVkUG9zaXRpb24gPSBbXVxuICAgICAgICAgICAgY29uc3Qge3Bvc2l0aW9ufSA9IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGFwcGxpZWRQb3NpdGlvblswXSA9IHBvc2l0aW9uLnggKyBhbGlnbkFkanVzdG1lbnRbMF0gLSBtb3VudFBvaW50QWRqdXN0bWVudFswXVxuICAgICAgICAgICAgYXBwbGllZFBvc2l0aW9uWzFdID0gcG9zaXRpb24ueSArIGFsaWduQWRqdXN0bWVudFsxXSAtIG1vdW50UG9pbnRBZGp1c3RtZW50WzFdXG4gICAgICAgICAgICBhcHBsaWVkUG9zaXRpb25bMl0gPSBwb3NpdGlvbi56ICsgYWxpZ25BZGp1c3RtZW50WzJdIC0gbW91bnRQb2ludEFkanVzdG1lbnRbMl1cblxuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZVNlbGYoYXBwbGllZFBvc2l0aW9uWzBdLCBhcHBsaWVkUG9zaXRpb25bMV0sIGFwcGxpZWRQb3NpdGlvblsyXSlcblxuICAgICAgICAgICAgLy8gb3JpZ2luIGNhbGN1bGF0aW9uIHdpbGwgZ28gaGVyZTpcbiAgICAgICAgICAgIC8vIC0gbW92ZSBieSBuZWdhdGl2ZSBvcmlnaW4gYmVmb3JlIHJvdGF0aW5nLlxuXG4gICAgICAgICAgICAvLyBhcHBseSBlYWNoIGF4aXMgcm90YXRpb24sIGluIHRoZSB4LHkseiBvcmRlci5cbiAgICAgICAgICAgIGNvbnN0IHtyb3RhdGlvbn0gPSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBtYXRyaXgucm90YXRlQXhpc0FuZ2xlU2VsZigxLDAsMCwgcm90YXRpb24ueClcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGVBeGlzQW5nbGVTZWxmKDAsMSwwLCByb3RhdGlvbi55KVxuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZUF4aXNBbmdsZVNlbGYoMCwwLDEsIHJvdGF0aW9uLnopXG5cbiAgICAgICAgICAgIC8vIG9yaWdpbiBjYWxjdWxhdGlvbiB3aWxsIGdvIGhlcmU6XG4gICAgICAgICAgICAvLyAtIG1vdmUgYnkgcG9zaXRpdmUgb3JpZ2luIGFmdGVyIHJvdGF0aW5nLlxuXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmaXggX2lzSWRlbnRpdHkgaW4gRE9NTWF0cml4LCBpdCBpcyByZXR1cm5pbmcgdHJ1ZSBldmVuIGlmIGZhbHNlLlxuICAgICAgICBfY2FsY3VsYXRlV29ybGRNYXRyaWNlc0luU3VidHJlZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVdvcmxkTWF0cml4RnJvbVBhcmVudCgpXG5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9jYWxjdWxhdGVXb3JsZE1hdHJpY2VzSW5TdWJ0cmVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9jYWxjdWxhdGVXb3JsZE1hdHJpeEZyb21QYXJlbnQoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnRcblxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFRyYW5zZm9ybWFibGUpXG4gICAgICAgICAgICAgICAgLy90aGlzLl93b3JsZE1hdHJpeCA9IHBhcmVudC5fd29ybGRNYXRyaXgubXVsdGlwbHkodGhpcy5fcHJvcGVydGllcy50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRNYXRyaXggPSB0aGlzLl9wcm9wZXJ0aWVzLnRyYW5zZm9ybS5tdWx0aXBseShwYXJlbnQuX3dvcmxkTWF0cml4KVxuICAgICAgICAgICAgZWxzZSAvLyBvdGhlcndpc2UgcGFyZW50IGlzIHRoZSBTY2VuZSwgd2hpY2ggaXMgU2l6ZWFibGUsIG5vdCBUcmFuc2Zvcm1hYmxlXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRNYXRyaXggPSB0aGlzLl9wcm9wZXJ0aWVzLnRyYW5zZm9ybVxuICAgICAgICB9XG5cbiAgICAgICAgX3JlbmRlcigpIHtcbiAgICAgICAgICAgIHN1cGVyLl9yZW5kZXIoKVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBvbmx5IHJ1biB0aGlzIHdoZW4gbmVjZXNzYXJ5IChmLmUuIG5vdCBpZiBvbmx5IG9wYWNpdHlcbiAgICAgICAgICAgIC8vIGNoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnRyYW5zZm9ybSA9IHRoaXMuX2NhbGN1bGF0ZU1hdHJpeCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7c2V0OiBzdXBlclByb3BlcnRpZXNTZXR9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihQYXJlbnRDbGFzcy5wcm90b3R5cGUsICdwcm9wZXJ0aWVzJylcblxuICAgIC8vIFdlIHNldCBhY2Nlc3NvcnMgbWFudWFsbHkgYmVjYXVzZSBCdWJsZSBkb2Vzbid0IG1ha2UgdGhlbSBjb25maWd1cmFibGVcbiAgICAvLyBhcyBwZXIgc3BlYy4gQWRkaXRpb25hbGx5IHdlJ3JlIG1haW5nIHRoZXNlIG9uZXMgZW51bWVyYWJsZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZSwge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBUcmFuc2Zvcm1hYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS54XSBUaGUgeC1heGlzIHBvc2l0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgcG9zaXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBwb3NpdGlvbiB0byBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihUcmFuc2Zvcm1hYmxlLCAncG9zaXRpb24nLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMucG9zaXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS54XSBUaGUgeC1heGlzIHJvdGF0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgcm90YXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyByb3RhdGlvbiB0byBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihUcmFuc2Zvcm1hYmxlLCAncm90YXRpb24nLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMucm90YXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS54XSBUaGUgeC1heGlzIHNjYWxlIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgc2NhbGUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBzY2FsZSB0byBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihUcmFuc2Zvcm1hYmxlLCAnc2NhbGUnLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMuc2NhbGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBOb2RlJ3Mgb3BhY2l0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgQSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAqIChpbmNsdXNpdmUpLiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCAxIGlzIGZ1bGx5IG9wYXF1ZS5cbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNSZWFsTnVtYmVyKG5ld1ZhbHVlKSkgbmV3VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVNpbmdsZShUcmFuc2Zvcm1hYmxlLCAnb3BhY2l0eScsIG5ld1ZhbHVlLCAnbnVtYmVyJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMub3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgYWxpZ25tZW50IG9mIHRoZSBOb2RlLiBUaGlzIGRldGVybWluZXMgYXQgd2hpY2ggcG9pbnQgaW4gdGhpc1xuICAgICAgICAgKiBOb2RlJ3MgcGFyZW50IHRoYXQgdGhpcyBOb2RlIGlzIG1vdW50ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgYWxpZ24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBhbGlnbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIGFsaWduIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdhbGlnbicsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5hbGlnblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbW91bnQgcG9pbnQgb2YgdGhlIE5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgbW91bnRQb2ludCB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS55XSBUaGUgeS1heGlzIG1vdW50UG9pbnQgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBtb3VudFBvaW50IHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRQb2ludDoge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHlYWVooVHJhbnNmb3JtYWJsZSwgJ21vdW50UG9pbnQnLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMubW91bnRQb2ludFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBhbGwgcHJvcGVydGllcyBvZiBhIFRyYW5zZm9ybWFibGUgaW4gb25lIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgUHJvcGVydGllcyBvYmplY3QgLSBzZWUgZXhhbXBsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgKiAgIHBvc2l0aW9uOiB7eDoyMDAsIHk6MzAwLCB6OjEwMH0sXG4gICAgICAgICAqICAgcm90YXRpb246IHt6OjM1fSxcbiAgICAgICAgICogICBzY2FsZToge3k6Mn0sXG4gICAgICAgICAqICAgb3BhY2l0eTogLjksXG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHNldChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICAgICAgICAgICAgICBzdXBlclByb3BlcnRpZXNTZXQuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzKVxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMucG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wZXJ0aWVzLnBvc2l0aW9uXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5yb3RhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHByb3BlcnRpZXMucm90YXRpb25cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnNjYWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gcHJvcGVydGllcy5zY2FsZVxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMub3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbiA9IHByb3BlcnRpZXMub3JpZ2luXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5hbGlnbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbiA9IHByb3BlcnRpZXMuYWxpZ25cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLm1vdW50UG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW91bnRQb2ludCA9IHByb3BlcnRpZXMubW91bnRQb2ludFxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMub3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gcHJvcGVydGllcy5vcGFjaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gbm8gbmVlZCBmb3IgYSBwcm9wZXJ0aWVzIGdldHRlci5cbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gZm9yIHVzZSBieSBNb3RvckhUTUwsIGNvbnZlbmllbnQgc2luY2UgSFRNTEVsZW1lbnQgYXR0cmlidXRlcyBhcmUgYWxsXG4gICAgLy8gY29udmVydGVkIHRvIGxvd2VyY2FzZSBieSBkZWZhdWx0LCBzbyBpZiB3ZSBkb24ndCBkbyB0aGlzIHRoZW4gd2Ugd29uJ3QgYmVcbiAgICAvLyBhYmxlIHRvIG1hcCBhdHRyaWJ1dGVzIHRvIE5vZGUgc2V0dGVycyBhcyBlYXNpbHkuXG4gICAgbWFrZUxvd2VyY2FzZVNldHRlckFsaWFzZXMoVHJhbnNmb3JtYWJsZS5wcm90b3R5cGUpXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtYWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBUcmFuc2Zvcm1hYmxlKSByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyYW5zZm9ybWFibGUpW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbCh0aGlzLCBvYmopXG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvdG8gPSBvYmpcblxuICAgICAgICAgICAgd2hpbGUoY3VycmVudFByb3RvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFByb3RvLCBcImNvbnN0cnVjdG9yXCIpXG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLnZhbHVlICYmIGRlc2MudmFsdWUuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VvZlN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudFByb3RvKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBUcmFuc2Zvcm1hYmxlW2luc3RhbmNlb2ZTeW1ib2xdID0gdHJ1ZVxuXG4gICAgcmV0dXJuIFRyYW5zZm9ybWFibGVcbn1cblxuZnVuY3Rpb24gaXNSZWFsTnVtYmVyKG51bSkge1xuICAgIGlmIChcbiAgICAgICAgdHlwZW9mIG51bSAhPSAnbnVtYmVyJ1xuICAgICAgICB8fCBPYmplY3QuaXMobnVtLCBOYU4pXG4gICAgICAgIHx8IE9iamVjdC5pcyhudW0sIEluZmluaXR5KVxuICAgICkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbn1cblxuY29uc3QgVHJhbnNmb3JtYWJsZSA9IFRyYW5zZm9ybWFibGVNaXhpbihjbGFzc3t9KVxuVHJhbnNmb3JtYWJsZS5taXhpbiA9IFRyYW5zZm9ybWFibGVNaXhpblxuXG5leHBvcnQge1RyYW5zZm9ybWFibGUgYXMgZGVmYXVsdH1cbiJdLCJuYW1lcyI6WyJzdXBlciIsInRoaXMiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxNQUFNLGFBQWE7QUFDbkMsT0FBTyxRQUFRLE1BQU0sWUFBWTtBQUNqQyxTQUFTLDBCQUEwQixRQUFRLFdBQVc7O0FBRXRELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDOztBQUVuRCxNQUFNLGtCQUFrQixHQUFHLFVBQUEsSUFBSSxDQUFBLENBQUMsQUFBRzs7OztJQUkvQixNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztJQUN4QyxJQUFNLGFBQWEsR0FBb0I7UUFBQyxBQUVwQyxzQkFBVyxDQUFDLE9BQVksRUFBRSxDQUFQOzZDQUFBLEdBQUcsRUFBRTtBQUFHO1lBQ3ZCQSxXQUFLLEtBQUEsQ0FBQyxNQUFBLE9BQU8sQ0FBQzs7WUFFZCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUk7U0FDM0I7Ozs7NERBQUE7O1FBRUQs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