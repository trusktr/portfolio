import { makeLowercaseSetterAliases } from './Utility'
import TreeNode from './TreeNode'
import XYZValues from './XYZValues'
import Observable from './Observable'
import Motor from './Motor'

// fallback to experimental CSS transform if browser doesn't have it (fix for Safari 9)
if (typeof document.createElement('div').style.transform == 'undefined') {
    Object.defineProperty(CSSStyleDeclaration.prototype, 'transform', {
        set: function set(value) {
            this.webkitTransform = value
        },
        get: function get() {
            return this.webkitTransform
        },
        enumerable: true,
    })
}

const instanceofSymbol = Symbol('instanceofSymbol')

const SizeableMixin = function (base) {

    // Sizeable extends TreeNode because Sizeable knows about its _parent when
    // calculating proportionalSize. Also Transformable knows about it's parent
    // in order to calculate it's world matrix based on it's parent's.
    var Sizeable = (function (superclass) {
        function Sizeable(options) {
            if ( options === void 0 ) options = {};

            superclass.call(this, options)

            this._propertyFunctions = null
            this._calculatedSize = { x:0, y:0, z:0 }
            this._properties = {}
            this._setDefaultProperties()
            this._setPropertyObservers()
            this.properties = options
        }

        if ( superclass ) Sizeable.__proto__ = superclass;
        Sizeable.prototype = Object.create( superclass && superclass.prototype );
        Sizeable.prototype.constructor = Sizeable;

        Sizeable.prototype._setDefaultProperties = function _setDefaultProperties () {
            Object.assign(this._properties, {
                sizeMode:         new XYZValues('absolute', 'absolute', 'absolute'),
                absoluteSize:     new XYZValues(0, 0, 0),
                proportionalSize: new XYZValues(1, 1, 1),
            })
        };

        Sizeable.prototype._setPropertyObservers = function _setPropertyObservers () {
            var this$1 = this;

            this._properties.sizeMode.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'sizeMode'); })
            this._properties.absoluteSize.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'absoluteSize'); })
            this._properties.proportionalSize.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'proportionalSize'); })
        };

        Sizeable.prototype._calcSize = function _calcSize () {
            const calculatedSize = this._calculatedSize
            const previousSize = Object.assign({}, calculatedSize)
            const props = this._properties
            const parentSize = this._getParentSize()

            if (props.sizeMode._x == 'absolute') {
                calculatedSize.x = props.absoluteSize._x
            }
            else { // proportional
                calculatedSize.x = parentSize.x * props.proportionalSize._x
            }

            if (props.sizeMode._y == 'absolute') {
                calculatedSize.y = props.absoluteSize._y
            }
            else { // proportional
                calculatedSize.y = parentSize.y * props.proportionalSize._y
            }

            if (props.sizeMode._z == 'absolute') {
                calculatedSize.z = props.absoluteSize._z
            }
            else { // proportional
                calculatedSize.z = parentSize.z * props.proportionalSize._z
            }

            if (
                previousSize.x !== calculatedSize.x
                || previousSize.y !== calculatedSize.y
                || previousSize.z !== calculatedSize.z
            ) {
                this.triggerEvent('sizechange', Object.assign({}, calculatedSize))
            }
        };

        Sizeable.prototype._getParentSize = function _getParentSize () {
            return this._parent ? this._parent._calculatedSize : {x:0,y:0,z:0}
        };

        Sizeable.prototype._setPropertyXYZ = function _setPropertyXYZ (Class, name, newValue) {
            var this$1 = this;

            if (!(
                newValue instanceof Object ||
                newValue instanceof Array ||
                newValue instanceof Function
            )) {
                throw new TypeError(("Invalid value for " + (Class.name) + "#" + name + "."))
            }

            let change = false

            if (newValue instanceof Function) {
                // remove previous task if any.
                if (!this._propertyFunctions) { this._propertyFunctions = new Map }

                if (this._propertyFunctions.has(name))
                    { Motor.removeRenderTask(this._propertyFunctions.get(name)) }

                this._propertyFunctions.set(name,
                    Motor.addRenderTask(function (time) {
                        const result = newValue(
                            this$1._properties[name]._x,
                            this$1._properties[name]._y,
                            this$1._properties[name]._z,
                            time
                        )

                        if (result === false) {
                            this$1._propertyFunctions.delete(name)
                            return false
                        }

                        this$1[name] = result
                    })
                )
            }
            else if (newValue instanceof Array) {
                if (typeof newValue[0] != 'undefined') { this._properties[name]._x = newValue[0]; change = true }
                if (typeof newValue[1] != 'undefined') { this._properties[name]._y = newValue[1]; change = true }
                if (typeof newValue[2] != 'undefined') { this._properties[name]._z = newValue[2]; change = true }
            }
            else {
                if (typeof newValue.x != 'undefined') { this._properties[name]._x = newValue.x; change = true }
                if (typeof newValue.y != 'undefined') { this._properties[name]._y = newValue.y; change = true }
                if (typeof newValue.z != 'undefined') { this._properties[name]._z = newValue.z; change = true }
            }

            if (change) { this.triggerEvent('propertychange', name) }
        };

        Sizeable.prototype._setPropertySingle = function _setPropertySingle (Class, name, newValue, type) {
            var this$1 = this;

            if (!(typeof newValue == type || newValue instanceof Function))
                { throw new TypeError(("Invalid value for " + (Class.name) + "#" + name + ".")) }

            if (newValue instanceof Function) {
                // remove previous task if any.
                Motor.addRenderTask(function (time) {
                    const result = newValue(
                        this$1._properties[name],
                        time
                    )

                    if (result === false) { return false }

                    this$1[name] = result
                })
            }
            else {
                this._properties[name] = newValue
                this.triggerEvent('propertychange', name)
            }
        };

        Sizeable.prototype._render = function _render () {
            // nothing yet, but needed because ImperativeBase calls
            // `super._render()`, which will call either Transformable's
            // _render or Sizeable's _render for Node and Scene classes,
            // respectively.
        };

        return Sizeable;
    }(TreeNode.mixin(Observable.mixin(base))));

    // We set accessors manually because Buble doesn't make them configurable
    // as per spec. Additionally we're maing these ones enumerable.
    Object.defineProperties(Sizeable.prototype, {

        /**
         * Set the size mode for each axis. Possible size modes are "absolute" and "proportional".
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis sizeMode to apply.
         * @param {number} [newValue.y] The y-axis sizeMode to apply.
         * @param {number} [newValue.z] The z-axis sizeMode to apply.
         */
        sizeMode: {
            set: function set(newValue) {
                this._setPropertyXYZ(Sizeable, 'sizeMode', newValue)
            },
            get: function get() {
                return this._properties.sizeMode
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis absoluteSize to apply.
         * @param {number} [newValue.y] The y-axis absoluteSize to apply.
         * @param {number} [newValue.z] The z-axis absoluteSize to apply.
         */
        absoluteSize: {
            set: function set(newValue) {
                this._setPropertyXYZ(Sizeable, 'absoluteSize', newValue)
            },
            get: function get() {
                return this._properties.absoluteSize
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Get the actual size of the Node. This can be useful when size is
         * proportional, as the actual size of the Node depends on the size of
         * it's parent.
         *
         * @readonly
         *
         * @return {Array.number} An Oject with x, y, and z properties, each
         * property representing the computed size of the x, y, and z axes
         * respectively.
         */
        actualSize: {
            get: function get() {
                var ref = this._calculatedSize;
                var x = ref.x;
                var y = ref.y;
                var z = ref.z;
                return {x: x,y: y,z: z}
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the size of a Node proportional to the size of it's parent Node. The
         * values are a real number between 0 and 1 inclusive where 0 means 0% of
         * the parent size and 1 means 100% of the parent size.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis proportionalSize to apply.
         * @param {number} [newValue.y] The y-axis proportionalSize to apply.
         * @param {number} [newValue.z] The z-axis proportionalSize to apply.
         */
        proportionalSize: {
            set: function set(newValue) {
                this._setPropertyXYZ(Sizeable, 'proportionalSize', newValue)
            },
            get: function get() {
                return this._properties.proportionalSize
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set all properties of a Sizeable in one method.
         *
         * @param {Object} properties Properties object - see example
         *
         * @example
         * node.properties = {
         *   sizeMode: {x:'absolute', y:'proportional', z:'absolute'},
         *   absoluteSize: {x:300, y:100, z:200},
         *   proportionalSize: {x:1, z:0.5}
         * }
         */
        properties: {
            set: function set(properties) {
                if ( properties === void 0 ) properties = {};

                if (properties.sizeMode)
                    { this.sizeMode = properties.sizeMode }

                if (properties.absoluteSize)
                    { this.absoluteSize = properties.absoluteSize }

                if (properties.proportionalSize)
                    { this.proportionalSize = properties.proportionalSize }
            },
            // no need for a properties getter.
            configurable: true,
        },
    })

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    makeLowercaseSetterAliases(Sizeable.prototype)

    Object.defineProperty(Sizeable, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== Sizeable) { return Object.getPrototypeOf(Sizeable)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while (currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    Sizeable[instanceofSymbol] = true

    return Sizeable
}

const Sizeable = SizeableMixin((function () {
    function anonymous () {}

    return anonymous;
}()))
Sizeable.mixin = SizeableMixin

export {Sizeable as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2l6ZWFibGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1NpemVhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VMb3dlcmNhc2VTZXR0ZXJBbGlhc2VzIH0gZnJvbSAnLi9VdGlsaXR5J1xuaW1wb3J0IFRyZWVOb2RlIGZyb20gJy4vVHJlZU5vZGUnXG5pbXBvcnQgWFlaVmFsdWVzIGZyb20gJy4vWFlaVmFsdWVzJ1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi9PYnNlcnZhYmxlJ1xuaW1wb3J0IE1vdG9yIGZyb20gJy4vTW90b3InXG5cbi8vIGZhbGxiYWNrIHRvIGV4cGVyaW1lbnRhbCBDU1MgdHJhbnNmb3JtIGlmIGJyb3dzZXIgZG9lc24ndCBoYXZlIGl0IChmaXggZm9yIFNhZmFyaSA5KVxuaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZS50cmFuc2Zvcm0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsICd0cmFuc2Zvcm0nLCB7XG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53ZWJraXRUcmFuc2Zvcm0gPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJraXRUcmFuc2Zvcm1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9KVxufVxuXG5jb25zdCBpbnN0YW5jZW9mU3ltYm9sID0gU3ltYm9sKCdpbnN0YW5jZW9mU3ltYm9sJylcblxuY29uc3QgU2l6ZWFibGVNaXhpbiA9IGJhc2UgPT4ge1xuXG4gICAgLy8gU2l6ZWFibGUgZXh0ZW5kcyBUcmVlTm9kZSBiZWNhdXNlIFNpemVhYmxlIGtub3dzIGFib3V0IGl0cyBfcGFyZW50IHdoZW5cbiAgICAvLyBjYWxjdWxhdGluZyBwcm9wb3J0aW9uYWxTaXplLiBBbHNvIFRyYW5zZm9ybWFibGUga25vd3MgYWJvdXQgaXQncyBwYXJlbnRcbiAgICAvLyBpbiBvcmRlciB0byBjYWxjdWxhdGUgaXQncyB3b3JsZCBtYXRyaXggYmFzZWQgb24gaXQncyBwYXJlbnQncy5cbiAgICBjbGFzcyBTaXplYWJsZSBleHRlbmRzIFRyZWVOb2RlLm1peGluKE9ic2VydmFibGUubWl4aW4oYmFzZSkpIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5RnVuY3Rpb25zID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZFNpemUgPSB7IHg6MCwgeTowLCB6OjAgfVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHt9XG4gICAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllcygpXG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eU9ic2VydmVycygpXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0RGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICBzaXplTW9kZTogICAgICAgICBuZXcgWFlaVmFsdWVzKCdhYnNvbHV0ZScsICdhYnNvbHV0ZScsICdhYnNvbHV0ZScpLFxuICAgICAgICAgICAgICAgIGFic29sdXRlU2l6ZTogICAgIG5ldyBYWVpWYWx1ZXMoMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgcHJvcG9ydGlvbmFsU2l6ZTogbmV3IFhZWlZhbHVlcygxLCAxLCAxKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UHJvcGVydHlPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnNpemVNb2RlLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdzaXplTW9kZScpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5hYnNvbHV0ZVNpemUub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ2Fic29sdXRlU2l6ZScpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5wcm9wb3J0aW9uYWxTaXplLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdwcm9wb3J0aW9uYWxTaXplJykpXG4gICAgICAgIH1cblxuICAgICAgICBfY2FsY1NpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxjdWxhdGVkU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZWRTaXplXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1NpemUgPSB7Li4uY2FsY3VsYXRlZFNpemV9XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFNpemUgPSB0aGlzLl9nZXRQYXJlbnRTaXplKClcblxuICAgICAgICAgICAgaWYgKHByb3BzLnNpemVNb2RlLl94ID09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkU2l6ZS54ID0gcHJvcHMuYWJzb2x1dGVTaXplLl94XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gcHJvcG9ydGlvbmFsXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueCA9IHBhcmVudFNpemUueCAqIHByb3BzLnByb3BvcnRpb25hbFNpemUuX3hcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BzLnNpemVNb2RlLl95ID09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkU2l6ZS55ID0gcHJvcHMuYWJzb2x1dGVTaXplLl95XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gcHJvcG9ydGlvbmFsXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueSA9IHBhcmVudFNpemUueSAqIHByb3BzLnByb3BvcnRpb25hbFNpemUuX3lcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BzLnNpemVNb2RlLl96ID09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkU2l6ZS56ID0gcHJvcHMuYWJzb2x1dGVTaXplLl96XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gcHJvcG9ydGlvbmFsXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueiA9IHBhcmVudFNpemUueiAqIHByb3BzLnByb3BvcnRpb25hbFNpemUuX3pcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2l6ZS54ICE9PSBjYWxjdWxhdGVkU2l6ZS54XG4gICAgICAgICAgICAgICAgfHwgcHJldmlvdXNTaXplLnkgIT09IGNhbGN1bGF0ZWRTaXplLnlcbiAgICAgICAgICAgICAgICB8fCBwcmV2aW91c1NpemUueiAhPT0gY2FsY3VsYXRlZFNpemUuelxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ3NpemVjaGFuZ2UnLCB7Li4uY2FsY3VsYXRlZFNpemV9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldFBhcmVudFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Ll9jYWxjdWxhdGVkU2l6ZSA6IHt4OjAseTowLHo6MH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRQcm9wZXJ0eVhZWihDbGFzcywgbmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghKFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0IHx8XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAke0NsYXNzLm5hbWV9IyR7bmFtZX0uYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoYW5nZSA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIHRhc2sgaWYgYW55LlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvcGVydHlGdW5jdGlvbnMpIHRoaXMuX3Byb3BlcnR5RnVuY3Rpb25zID0gbmV3IE1hcFxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnR5RnVuY3Rpb25zLmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgTW90b3IucmVtb3ZlUmVuZGVyVGFzayh0aGlzLl9wcm9wZXJ0eUZ1bmN0aW9ucy5nZXQobmFtZSkpXG5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUZ1bmN0aW9ucy5zZXQobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgTW90b3IuYWRkUmVuZGVyVGFzayh0aW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0uX3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1tuYW1lXS5feSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLl96LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUZ1bmN0aW9ucy5kZWxldGUobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlWzBdICE9ICd1bmRlZmluZWQnKSB7IHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0uX3ggPSBuZXdWYWx1ZVswXTsgY2hhbmdlID0gdHJ1ZSB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZVsxXSAhPSAndW5kZWZpbmVkJykgeyB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLl95ID0gbmV3VmFsdWVbMV07IGNoYW5nZSA9IHRydWUgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWVbMl0gIT0gJ3VuZGVmaW5lZCcpIHsgdGhpcy5fcHJvcGVydGllc1tuYW1lXS5feiA9IG5ld1ZhbHVlWzJdOyBjaGFuZ2UgPSB0cnVlIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUueCAhPSAndW5kZWZpbmVkJykgeyB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLl94ID0gbmV3VmFsdWUueDsgY2hhbmdlID0gdHJ1ZSB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZS55ICE9ICd1bmRlZmluZWQnKSB7IHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0uX3kgPSBuZXdWYWx1ZS55OyBjaGFuZ2UgPSB0cnVlIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlLnogIT0gJ3VuZGVmaW5lZCcpIHsgdGhpcy5fcHJvcGVydGllc1tuYW1lXS5feiA9IG5ld1ZhbHVlLno7IGNoYW5nZSA9IHRydWUgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlKSB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCBuYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgX3NldFByb3BlcnR5U2luZ2xlKENsYXNzLCBuYW1lLCBuZXdWYWx1ZSwgdHlwZSkge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIG5ld1ZhbHVlID09IHR5cGUgfHwgbmV3VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJHtDbGFzcy5uYW1lfSMke25hbWV9LmApXG5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIHRhc2sgaWYgYW55LlxuICAgICAgICAgICAgICAgIE1vdG9yLmFkZFJlbmRlclRhc2sodGltZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1tuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gcmVzdWx0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0gPSBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsIG5hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfcmVuZGVyKCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB5ZXQsIGJ1dCBuZWVkZWQgYmVjYXVzZSBJbXBlcmF0aXZlQmFzZSBjYWxsc1xuICAgICAgICAgICAgLy8gYHN1cGVyLl9yZW5kZXIoKWAsIHdoaWNoIHdpbGwgY2FsbCBlaXRoZXIgVHJhbnNmb3JtYWJsZSdzXG4gICAgICAgICAgICAvLyBfcmVuZGVyIG9yIFNpemVhYmxlJ3MgX3JlbmRlciBmb3IgTm9kZSBhbmQgU2NlbmUgY2xhc3NlcyxcbiAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseS5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIHNldCBhY2Nlc3NvcnMgbWFudWFsbHkgYmVjYXVzZSBCdWJsZSBkb2Vzbid0IG1ha2UgdGhlbSBjb25maWd1cmFibGVcbiAgICAvLyBhcyBwZXIgc3BlYy4gQWRkaXRpb25hbGx5IHdlJ3JlIG1haW5nIHRoZXNlIG9uZXMgZW51bWVyYWJsZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTaXplYWJsZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBzaXplIG1vZGUgZm9yIGVhY2ggYXhpcy4gUG9zc2libGUgc2l6ZSBtb2RlcyBhcmUgXCJhYnNvbHV0ZVwiIGFuZCBcInByb3BvcnRpb25hbFwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS54XSBUaGUgeC1heGlzIHNpemVNb2RlIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgc2l6ZU1vZGUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBzaXplTW9kZSB0byBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIHNpemVNb2RlOiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihTaXplYWJsZSwgJ3NpemVNb2RlJywgbmV3VmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLnNpemVNb2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBhYnNvbHV0ZVNpemUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBhYnNvbHV0ZVNpemUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBhYnNvbHV0ZVNpemUgdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBhYnNvbHV0ZVNpemU6IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFNpemVhYmxlLCAnYWJzb2x1dGVTaXplJywgbmV3VmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLmFic29sdXRlU2l6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIE5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHNpemUgaXNcbiAgICAgICAgICogcHJvcG9ydGlvbmFsLCBhcyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIE5vZGUgZGVwZW5kcyBvbiB0aGUgc2l6ZSBvZlxuICAgICAgICAgKiBpdCdzIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Lm51bWJlcn0gQW4gT2plY3Qgd2l0aCB4LCB5LCBhbmQgeiBwcm9wZXJ0aWVzLCBlYWNoXG4gICAgICAgICAqIHByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgY29tcHV0ZWQgc2l6ZSBvZiB0aGUgeCwgeSwgYW5kIHogYXhlc1xuICAgICAgICAgKiByZXNwZWN0aXZlbHkuXG4gICAgICAgICAqL1xuICAgICAgICBhY3R1YWxTaXplOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge3gseSx6fSA9IHRoaXMuX2NhbGN1bGF0ZWRTaXplXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4LHksen1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHNpemUgb2YgYSBOb2RlIHByb3BvcnRpb25hbCB0byB0aGUgc2l6ZSBvZiBpdCdzIHBhcmVudCBOb2RlLiBUaGVcbiAgICAgICAgICogdmFsdWVzIGFyZSBhIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUgd2hlcmUgMCBtZWFucyAwJSBvZlxuICAgICAgICAgKiB0aGUgcGFyZW50IHNpemUgYW5kIDEgbWVhbnMgMTAwJSBvZiB0aGUgcGFyZW50IHNpemUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgcHJvcG9ydGlvbmFsU2l6ZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS55XSBUaGUgeS1heGlzIHByb3BvcnRpb25hbFNpemUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUuel0gVGhlIHotYXhpcyBwcm9wb3J0aW9uYWxTaXplIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcG9ydGlvbmFsU2l6ZToge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHlYWVooU2l6ZWFibGUsICdwcm9wb3J0aW9uYWxTaXplJywgbmV3VmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLnByb3BvcnRpb25hbFNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYWxsIHByb3BlcnRpZXMgb2YgYSBTaXplYWJsZSBpbiBvbmUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG9iamVjdCAtIHNlZSBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUucHJvcGVydGllcyA9IHtcbiAgICAgICAgICogICBzaXplTW9kZToge3g6J2Fic29sdXRlJywgeToncHJvcG9ydGlvbmFsJywgejonYWJzb2x1dGUnfSxcbiAgICAgICAgICogICBhYnNvbHV0ZVNpemU6IHt4OjMwMCwgeToxMDAsIHo6MjAwfSxcbiAgICAgICAgICogICBwcm9wb3J0aW9uYWxTaXplOiB7eDoxLCB6OjAuNX1cbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgc2V0KHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnNpemVNb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVNb2RlID0gcHJvcGVydGllcy5zaXplTW9kZVxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuYWJzb2x1dGVTaXplKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlU2l6ZSA9IHByb3BlcnRpZXMuYWJzb2x1dGVTaXplXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wcm9wb3J0aW9uYWxTaXplKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BvcnRpb25hbFNpemUgPSBwcm9wZXJ0aWVzLnByb3BvcnRpb25hbFNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBubyBuZWVkIGZvciBhIHByb3BlcnRpZXMgZ2V0dGVyLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pXG5cbiAgICAvLyBmb3IgdXNlIGJ5IE1vdG9ySFRNTCwgY29udmVuaWVudCBzaW5jZSBIVE1MRWxlbWVudCBhdHRyaWJ1dGVzIGFyZSBhbGxcbiAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGJ5IGRlZmF1bHQsIHNvIGlmIHdlIGRvbid0IGRvIHRoaXMgdGhlbiB3ZSB3b24ndCBiZVxuICAgIC8vIGFibGUgdG8gbWFwIGF0dHJpYnV0ZXMgdG8gTm9kZSBzZXR0ZXJzIGFzIGVhc2lseS5cbiAgICBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyhTaXplYWJsZS5wcm90b3R5cGUpXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2l6ZWFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAodGhpcyAhPT0gU2l6ZWFibGUpIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2l6ZWFibGUpW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbCh0aGlzLCBvYmopXG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvdG8gPSBvYmpcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRQcm90bykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRQcm90bywgXCJjb25zdHJ1Y3RvclwiKVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy52YWx1ZSAmJiBkZXNjLnZhbHVlLmhhc093blByb3BlcnR5KGluc3RhbmNlb2ZTeW1ib2wpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgY3VycmVudFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRQcm90bylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgU2l6ZWFibGVbaW5zdGFuY2VvZlN5bWJvbF0gPSB0cnVlXG5cbiAgICByZXR1cm4gU2l6ZWFibGVcbn1cblxuY29uc3QgU2l6ZWFibGUgPSBTaXplYWJsZU1peGluKGNsYXNze30pXG5TaXplYWJsZS5taXhpbiA9IFNpemVhYmxlTWl4aW5cblxuZXhwb3J0IHtTaXplYWJsZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbInN1cGVyIiwidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUywwQkFBMEIsUUFBUSxXQUFXO0FBQ3RELE9BQU8sUUFBUSxNQUFNLFlBQVk7QUFDakMsT0FBTyxTQUFTLE1BQU0sYUFBYTtBQUNuQyxPQUFPLFVBQVUsTUFBTSxjQUFjO0FBQ3JDLE9BQU8sS0FBSyxNQUFNLFNBQVM7OztBQUczQixJQUFJLE9BQU8sUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLFdBQVcsRUFBRTtJQUNyRSxNQUFNLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUU7UUFDOUQsR0FBRyxjQUFBLENBQUMsS0FBSyxFQUFFO1lBQ1AsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLO1NBQy9CO1FBQ0QsR0FBRyxjQUFBLEdBQUc7WUFDRixPQUFPLElBQUksQ0FBQyxlQUFlO1NBQzlCO1FBQ0QsVUFBVSxFQUFFLElBQUk7S0FDbkIsQ0FBQztDQUNMOztBQUVELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDOztBQUVuRCxNQUFNLGFBQWEsR0FBRyxVQUFBLElBQUksQ0FBQSxDQUFDLEFBQUc7Ozs7O0lBSzFCLElBQU0sUUFBUSxHQUErQztRQUFDLEFBRTFELGlCQUFXLENBQUMsT0FBWSxFQUFFLENBQVA7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