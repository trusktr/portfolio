
// although Transformable is not used in this file, importing it first prevent
// a cyclical dependeny problem when an App imports Scene before Node (Sizeable
// imports Motor imports Transformable). See:
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem
// TODO: write a test that imports public interfaces in every possible
// permutation to detect circular dependency errors.
import Transformable from './Transformable'

import Sizeable from './Sizeable'
import ImperativeBase, {initImperativeBase} from './ImperativeBase'
import XYZValues from './XYZValues'
import MotorHTMLScene from '../html/scene'
import documentReady from 'awaitbox/dom/documentReady'

initImperativeBase()

// Scene is Sizeable, which is currently a subset of Transformable.
const ParentClass = ImperativeBase.mixin(Sizeable)
var Scene = (function (ParentClass) {
    function Scene(options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

        ParentClass.call(this, options)

        // NOTE: z size is always 0, since native DOM elements are always flat.
        this._elementParentSize = {x:0, y:0, z:0}

        this._onElementParentSizeChange = function (newSize) {
            this$1._elementParentSize = newSize
            this$1._calcSize()
            this$1._needsToBeRendered()
        }

        this._calcSize()
        this._needsToBeRendered()
    }

    if ( ParentClass ) Scene.__proto__ = ParentClass;
    Scene.prototype = Object.create( ParentClass && ParentClass.prototype );
    Scene.prototype.constructor = Scene;

    Scene.prototype._setDefaultProperties = function _setDefaultProperties () {
        ParentClass.prototype._setDefaultProperties.call(this)

        Object.assign(this._properties, {
            sizeMode: new XYZValues('proportional', 'proportional', 'absolute'),
        })
    };

    Scene.prototype._startOrStopSizePolling = function _startOrStopSizePolling () {
        if (
            this._mounted &&
            (this._properties.sizeMode.x == 'proportional'
            || this._properties.sizeMode.y == 'proportional'
            || this._properties.sizeMode.z == 'proportional')
        ) {
            this._startSizePolling()
        }
        else {
            this._stopSizePolling()
        }
    };

    // observe size changes on the scene element.
    Scene.prototype._startSizePolling = function _startSizePolling () {
        if (!this._elementManager) { return }
        this._elementManager.element._startSizePolling()
        this._elementManager.element.on('parentsizechange', this._onElementParentSizeChange)
    };

    // Don't observe size changes on the scene element.
    Scene.prototype._stopSizePolling = function _stopSizePolling () {
        if (!this._elementManager) { return }
        this._elementManager.element.off('parentsizechange', this._onElementParentSizeChange)
        this._elementManager.element._stopSizePolling()
    };

    /** @override */
    Scene.prototype._getParentSize = function _getParentSize () {
        return this._mounted ? this._elementParentSize : {x:0,y:0,z:0}
    };

    /**
     * @override
     */
    Scene.prototype._makeElement = function _makeElement () {
        return new MotorHTMLScene
    };

    /**
     * Mount the scene into the given target.
     * Resolves the Scene's mountPromise, which can be use to do something once
     * the scene is mounted.
     *
     * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,
     * the mount point will be selected from the DOM. If an HTMLElement is
     * provided, that will be the mount point. If no mount point is provided,
     * the scene will be mounted into document.body.
     */
    Scene.prototype.mount = function mount (mountPoint) {
        var this$1 = this;

        const mountLogic = function () {
            // if no mountPoint was provided, just mount onto the <body> element.
            if (mountPoint === undefined) { mountPoint = document.body }

            // if the user supplied a selector, mount there.
            else if (typeof mountPoint === 'string')
                { mountPoint = document.querySelector(mountPoint) }

            // if we have an actual mount point (the user may have supplied one)
            if (!(mountPoint instanceof window.HTMLElement))
                { throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.') }

            if (this$1._mounted) { this$1.unmount() }

            if (mountPoint !== this$1._elementManager.element.parentNode)
                { mountPoint.appendChild(this$1._elementManager.element) }

            this$1._mounted = true

            if (this$1._mountPromise) { this$1._resolveMountPromise() }

            this$1._elementManager.shouldRender()
            this$1._startOrStopSizePolling()
        }

        // Wait for the document to be ready before mounting, otherwise the
        // target mount point might not exist yet when this function is called.
        if (document.readyState == 'loading') { return documentReady().then(mountLogic) }
        else {
            mountLogic()
            return Promise.resolve()
        }
    };
    //async mount(mountPoint) {
        //// Wait for the document to be ready before mounting, otherwise the
        //// target mount point might not exist yet when this function is called.
        //if (document.readyState == 'loading') await documentReady()

        //// if no mountPoint was provided, just mount onto the <body> element.
        //if (mountPoint === undefined) mountPoint = document.body

        //// if the user supplied a selector, mount there.
        //else if (typeof mountPoint === 'string')
            //mountPoint = document.querySelector(mountPoint)

        //// if we have an actual mount point (the user may have supplied one)
        //if (!(mountPoint instanceof window.HTMLElement))
            //throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.')

        //if (this._mounted) this.unmount()

        //if (mountPoint !== this._elementManager.element.parentNode)
            //mountPoint.appendChild(this._elementManager.element)

        //this._mounted = true

        //if (this._mountPromise) this._resolveMountPromise()

        //this._elementManager.shouldRender()
        //this._startOrStopSizePolling()
    //}

    /**
     * Unmount the scene from it's mount point. Resets the Scene's
     * mountPromise.
     */
    Scene.prototype.unmount = function unmount () {
        if (!this._mounted) { return }

        this._elementManager.shouldNotRender()
        this._stopSizePolling()

        if (this._elementManager.element.parentNode)
            { this._elementManager.element.parentNode.removeChild(this._elementManager.element) }

        if (this._mountPromise) { this._rejectMountPromise('mountcancel') }
        this._resetMountPromise()
    };

    return Scene;
}(ParentClass));

// Here we know that `super` is Sizeable
var ref = Object.getOwnPropertyDescriptor(Sizeable.prototype, 'sizeMode');
var superSizeModeSet = ref.set;
var superSizeModeGet = ref.get;

Object.defineProperties(Scene.prototype, {

    // When we set the scene's size mode, we should start polling if it has
    // proportional sizing.
    sizeMode: {
        set: function(value) {
            superSizeModeSet.call(this, value)
            this._startOrStopSizePolling()
        },
        get: function() {
            return superSizeModeGet.call(this)
        },
        configurable: true,
        enumerable: true,
    }

})

export {Scene as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NlbmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1NjZW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLy8gYWx0aG91Z2ggVHJhbnNmb3JtYWJsZSBpcyBub3QgdXNlZCBpbiB0aGlzIGZpbGUsIGltcG9ydGluZyBpdCBmaXJzdCBwcmV2ZW50XG4vLyBhIGN5Y2xpY2FsIGRlcGVuZGVueSBwcm9ibGVtIHdoZW4gYW4gQXBwIGltcG9ydHMgU2NlbmUgYmVmb3JlIE5vZGUgKFNpemVhYmxlXG4vLyBpbXBvcnRzIE1vdG9yIGltcG9ydHMgVHJhbnNmb3JtYWJsZSkuIFNlZTpcbi8vIGh0dHBzOi8vZXNkaXNjdXNzLm9yZy90b3BpYy9ob3ctdG8tc29sdmUtdGhpcy1iYXNpYy1lczYtbW9kdWxlLWNpcmN1bGFyLWRlcGVuZGVuY3ktcHJvYmxlbVxuLy8gVE9ETzogd3JpdGUgYSB0ZXN0IHRoYXQgaW1wb3J0cyBwdWJsaWMgaW50ZXJmYWNlcyBpbiBldmVyeSBwb3NzaWJsZVxuLy8gcGVybXV0YXRpb24gdG8gZGV0ZWN0IGNpcmN1bGFyIGRlcGVuZGVuY3kgZXJyb3JzLlxuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnLi9UcmFuc2Zvcm1hYmxlJ1xuXG5pbXBvcnQgU2l6ZWFibGUgZnJvbSAnLi9TaXplYWJsZSdcbmltcG9ydCBJbXBlcmF0aXZlQmFzZSwge2luaXRJbXBlcmF0aXZlQmFzZX0gZnJvbSAnLi9JbXBlcmF0aXZlQmFzZSdcbmltcG9ydCBYWVpWYWx1ZXMgZnJvbSAnLi9YWVpWYWx1ZXMnXG5pbXBvcnQgTW90b3JIVE1MU2NlbmUgZnJvbSAnLi4vaHRtbC9zY2VuZSdcbmltcG9ydCBkb2N1bWVudFJlYWR5IGZyb20gJ2F3YWl0Ym94L2RvbS9kb2N1bWVudFJlYWR5J1xuXG5pbml0SW1wZXJhdGl2ZUJhc2UoKVxuXG4vLyBTY2VuZSBpcyBTaXplYWJsZSwgd2hpY2ggaXMgY3VycmVudGx5IGEgc3Vic2V0IG9mIFRyYW5zZm9ybWFibGUuXG5jb25zdCBQYXJlbnRDbGFzcyA9IEltcGVyYXRpdmVCYXNlLm1peGluKFNpemVhYmxlKVxuY2xhc3MgU2NlbmUgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAgICAgLy8gTk9URTogeiBzaXplIGlzIGFsd2F5cyAwLCBzaW5jZSBuYXRpdmUgRE9NIGVsZW1lbnRzIGFyZSBhbHdheXMgZmxhdC5cbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcmVudFNpemUgPSB7eDowLCB5OjAsIHo6MH1cblxuICAgICAgICB0aGlzLl9vbkVsZW1lbnRQYXJlbnRTaXplQ2hhbmdlID0gKG5ld1NpemUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRQYXJlbnRTaXplID0gbmV3U2l6ZVxuICAgICAgICAgICAgdGhpcy5fY2FsY1NpemUoKVxuICAgICAgICAgICAgdGhpcy5fbmVlZHNUb0JlUmVuZGVyZWQoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsY1NpemUoKVxuICAgICAgICB0aGlzLl9uZWVkc1RvQmVSZW5kZXJlZCgpXG4gICAgfVxuXG4gICAgX3NldERlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgICAgICBzdXBlci5fc2V0RGVmYXVsdFByb3BlcnRpZXMoKVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fcHJvcGVydGllcywge1xuICAgICAgICAgICAgc2l6ZU1vZGU6IG5ldyBYWVpWYWx1ZXMoJ3Byb3BvcnRpb25hbCcsICdwcm9wb3J0aW9uYWwnLCAnYWJzb2x1dGUnKSxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBfc3RhcnRPclN0b3BTaXplUG9sbGluZygpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fbW91bnRlZCAmJlxuICAgICAgICAgICAgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGUueCA9PSAncHJvcG9ydGlvbmFsJ1xuICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS55ID09ICdwcm9wb3J0aW9uYWwnXG4gICAgICAgICAgICB8fCB0aGlzLl9wcm9wZXJ0aWVzLnNpemVNb2RlLnogPT0gJ3Byb3BvcnRpb25hbCcpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRTaXplUG9sbGluZygpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wU2l6ZVBvbGxpbmcoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gb2JzZXJ2ZSBzaXplIGNoYW5nZXMgb24gdGhlIHNjZW5lIGVsZW1lbnQuXG4gICAgX3N0YXJ0U2l6ZVBvbGxpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudE1hbmFnZXIpIHJldHVyblxuICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50Ll9zdGFydFNpemVQb2xsaW5nKClcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudC5vbigncGFyZW50c2l6ZWNoYW5nZScsIHRoaXMuX29uRWxlbWVudFBhcmVudFNpemVDaGFuZ2UpXG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgb2JzZXJ2ZSBzaXplIGNoYW5nZXMgb24gdGhlIHNjZW5lIGVsZW1lbnQuXG4gICAgX3N0b3BTaXplUG9sbGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50TWFuYWdlcikgcmV0dXJuXG4gICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQub2ZmKCdwYXJlbnRzaXplY2hhbmdlJywgdGhpcy5fb25FbGVtZW50UGFyZW50U2l6ZUNoYW5nZSlcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudC5fc3RvcFNpemVQb2xsaW5nKClcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgX2dldFBhcmVudFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VudGVkID8gdGhpcy5fZWxlbWVudFBhcmVudFNpemUgOiB7eDowLHk6MCx6OjB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vdG9ySFRNTFNjZW5lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91bnQgdGhlIHNjZW5lIGludG8gdGhlIGdpdmVuIHRhcmdldC5cbiAgICAgKiBSZXNvbHZlcyB0aGUgU2NlbmUncyBtb3VudFByb21pc2UsIHdoaWNoIGNhbiBiZSB1c2UgdG8gZG8gc29tZXRoaW5nIG9uY2VcbiAgICAgKiB0aGUgc2NlbmUgaXMgbW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbbW91bnRQb2ludD1kb2N1bWVudC5ib2R5XSBJZiBhIHN0cmluZyBzZWxlY3RvciBpcyBwcm92aWRlZCxcbiAgICAgKiB0aGUgbW91bnQgcG9pbnQgd2lsbCBiZSBzZWxlY3RlZCBmcm9tIHRoZSBET00uIElmIGFuIEhUTUxFbGVtZW50IGlzXG4gICAgICogcHJvdmlkZWQsIHRoYXQgd2lsbCBiZSB0aGUgbW91bnQgcG9pbnQuIElmIG5vIG1vdW50IHBvaW50IGlzIHByb3ZpZGVkLFxuICAgICAqIHRoZSBzY2VuZSB3aWxsIGJlIG1vdW50ZWQgaW50byBkb2N1bWVudC5ib2R5LlxuICAgICAqL1xuICAgIG1vdW50KG1vdW50UG9pbnQpIHtcbiAgICAgICAgY29uc3QgbW91bnRMb2dpYyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vIG1vdW50UG9pbnQgd2FzIHByb3ZpZGVkLCBqdXN0IG1vdW50IG9udG8gdGhlIDxib2R5PiBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKG1vdW50UG9pbnQgPT09IHVuZGVmaW5lZCkgbW91bnRQb2ludCA9IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBzZWxlY3RvciwgbW91bnQgdGhlcmUuXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW91bnRQb2ludCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgbW91bnRQb2ludCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobW91bnRQb2ludClcblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBhY3R1YWwgbW91bnQgcG9pbnQgKHRoZSB1c2VyIG1heSBoYXZlIHN1cHBsaWVkIG9uZSlcbiAgICAgICAgICAgIGlmICghKG1vdW50UG9pbnQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb3VudCBwb2ludCBzcGVjaWZpZWQgaW4gU2NlbmUubW91bnQoKSBjYWxsLiBQYXNzIGEgc2VsZWN0b3IsIGFuIGFjdHVhbCBIVE1MRWxlbWVudCwgb3IgZG9uXFwndCBwYXNzIGFueXRoaW5nIHRvIG1vdW50IHRvIDxib2R5Pi4nKVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fbW91bnRlZCkgdGhpcy51bm1vdW50KClcblxuICAgICAgICAgICAgaWYgKG1vdW50UG9pbnQgIT09IHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBtb3VudFBvaW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQpXG5cbiAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3VudFByb21pc2UpIHRoaXMuX3Jlc29sdmVNb3VudFByb21pc2UoKVxuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGRSZW5kZXIoKVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRPclN0b3BTaXplUG9sbGluZygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZHkgYmVmb3JlIG1vdW50aW5nLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vIHRhcmdldCBtb3VudCBwb2ludCBtaWdodCBub3QgZXhpc3QgeWV0IHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09ICdsb2FkaW5nJykgcmV0dXJuIGRvY3VtZW50UmVhZHkoKS50aGVuKG1vdW50TG9naWMpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW91bnRMb2dpYygpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2FzeW5jIG1vdW50KG1vdW50UG9pbnQpIHtcbiAgICAgICAgLy8vLyBXYWl0IGZvciB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZHkgYmVmb3JlIG1vdW50aW5nLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vLy8gdGFyZ2V0IG1vdW50IHBvaW50IG1pZ2h0IG5vdCBleGlzdCB5ZXQgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICAgICAgLy9pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnbG9hZGluZycpIGF3YWl0IGRvY3VtZW50UmVhZHkoKVxuXG4gICAgICAgIC8vLy8gaWYgbm8gbW91bnRQb2ludCB3YXMgcHJvdmlkZWQsIGp1c3QgbW91bnQgb250byB0aGUgPGJvZHk+IGVsZW1lbnQuXG4gICAgICAgIC8vaWYgKG1vdW50UG9pbnQgPT09IHVuZGVmaW5lZCkgbW91bnRQb2ludCA9IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAvLy8vIGlmIHRoZSB1c2VyIHN1cHBsaWVkIGEgc2VsZWN0b3IsIG1vdW50IHRoZXJlLlxuICAgICAgICAvL2Vsc2UgaWYgKHR5cGVvZiBtb3VudFBvaW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC8vbW91bnRQb2ludCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobW91bnRQb2ludClcblxuICAgICAgICAvLy8vIGlmIHdlIGhhdmUgYW4gYWN0dWFsIG1vdW50IHBvaW50ICh0aGUgdXNlciBtYXkgaGF2ZSBzdXBwbGllZCBvbmUpXG4gICAgICAgIC8vaWYgKCEobW91bnRQb2ludCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBtb3VudCBwb2ludCBzcGVjaWZpZWQgaW4gU2NlbmUubW91bnQoKSBjYWxsLiBQYXNzIGEgc2VsZWN0b3IsIGFuIGFjdHVhbCBIVE1MRWxlbWVudCwgb3IgZG9uXFwndCBwYXNzIGFueXRoaW5nIHRvIG1vdW50IHRvIDxib2R5Pi4nKVxuXG4gICAgICAgIC8vaWYgKHRoaXMuX21vdW50ZWQpIHRoaXMudW5tb3VudCgpXG5cbiAgICAgICAgLy9pZiAobW91bnRQb2ludCAhPT0gdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLy9tb3VudFBvaW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQpXG5cbiAgICAgICAgLy90aGlzLl9tb3VudGVkID0gdHJ1ZVxuXG4gICAgICAgIC8vaWYgKHRoaXMuX21vdW50UHJvbWlzZSkgdGhpcy5fcmVzb2x2ZU1vdW50UHJvbWlzZSgpXG5cbiAgICAgICAgLy90aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGRSZW5kZXIoKVxuICAgICAgICAvL3RoaXMuX3N0YXJ0T3JTdG9wU2l6ZVBvbGxpbmcoKVxuICAgIC8vfVxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudCB0aGUgc2NlbmUgZnJvbSBpdCdzIG1vdW50IHBvaW50LiBSZXNldHMgdGhlIFNjZW5lJ3NcbiAgICAgKiBtb3VudFByb21pc2UuXG4gICAgICovXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3VudGVkKSByZXR1cm5cblxuICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGROb3RSZW5kZXIoKVxuICAgICAgICB0aGlzLl9zdG9wU2l6ZVBvbGxpbmcoKVxuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudClcblxuICAgICAgICBpZiAodGhpcy5fbW91bnRQcm9taXNlKSB0aGlzLl9yZWplY3RNb3VudFByb21pc2UoJ21vdW50Y2FuY2VsJylcbiAgICAgICAgdGhpcy5fcmVzZXRNb3VudFByb21pc2UoKVxuICAgIH1cblxufVxuXG4vLyBIZXJlIHdlIGtub3cgdGhhdCBgc3VwZXJgIGlzIFNpemVhYmxlXG5jb25zdCB7c2V0OiBzdXBlclNpemVNb2RlU2V0LCBnZXQ6IHN1cGVyU2l6ZU1vZGVHZXR9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTaXplYWJsZS5wcm90b3R5cGUsICdzaXplTW9kZScpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNjZW5lLnByb3RvdHlwZSwge1xuXG4gICAgLy8gV2hlbiB3ZSBzZXQgdGhlIHNjZW5lJ3Mgc2l6ZSBtb2RlLCB3ZSBzaG91bGQgc3RhcnQgcG9sbGluZyBpZiBpdCBoYXNcbiAgICAvLyBwcm9wb3J0aW9uYWwgc2l6aW5nLlxuICAgIHNpemVNb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyU2l6ZU1vZGVTZXQuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T3JTdG9wU2l6ZVBvbGxpbmcoKVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2l6ZU1vZGVHZXQuY2FsbCh0aGlzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxuXG59KVxuXG5leHBvcnQge1NjZW5lIGFzIGRlZmF1bHR9XG4iXSwibmFtZXMiOlsic3VwZXIiLCJ0aGlzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BLE9BQU8sYUFBYSxNQUFNLGlCQUFpQjs7QUFFM0MsT0FBTyxRQUFRLE1BQU0sWUFBWTtBQUNqQyxPQUFPLGNBQWMsR0FBRyxrQkFBa0IsT0FBTyxrQkFBa0I7QUFDbkUsT0FBTyxTQUFTLE1BQU0sYUFBYTtBQUNuQyxPQUFPLGNBQWMsTUFBTSxlQUFlO0FBQzFDLE9BQU8sYUFBYSxNQUFNLDRCQUE0Qjs7QUFFdEQsa0JBQWtCLEVBQUU7OztBQUdwQixNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztBQUNsRCxJQUFNLEtBQUssR0FBb0I7SUFBQyxBQUM1QixjQUFXLENBQUMsT0FBWSxFQUFFLENBQUM7MEJBQVI7eUNBQUEsR0FBRyxFQUFFO0FBQUc7UUFDdkJBLFdBQUssS0FBQSxDQUFDLE1BQUEsT0FBTyxDQUFDOzs7UUFHZCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFFekMsSUFBSSxDQUFDLDBCQUEwQixHQUFHLFNBQUEsQ0FBQyxPQUFPLEVBQUUsQUFBRztZQUMzQ0MsTUFBSSxDQUFDLGtCQUFrQixHQUFHLE9BQU87WUFDakNBLE1BQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEJBLE1BQUksQ0FBQyxrQkFBa0IsRUFBRTtTQUM1Qjs7UUFFRCxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtLQUM1Qjs7Ozt3Q0FBQTs7SUFFRCxnQkFBQSxxQkFBcUIsa0NBQUEsR0FBRztRQUNwQkQscUJBQUssQ0FBQyxxQkFBcUIsS0FBQSxDQUFDLElBQUEsQ0FBQzs7UUFFN0IsTUFBTSxDQUFD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