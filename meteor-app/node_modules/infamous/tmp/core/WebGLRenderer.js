import {
    createWebGLContext,
    //removeWebGLContext,
    setGlResolution,
    v3,
    m4,
    vertShaderSource,
    fragShaderSource,
    createShader,
    createProgram,
    Cube,
    Quad,
    FourSidedPyramid,
    IsoscelesTriangle,
    SymmetricTrapezoid,
} from './webglUtils'

const updateResolution = function (state) {
    const resolution = [
        parseFloat(getComputedStyle(state.gl.canvas).width) * window.devicePixelRatio,
        parseFloat(getComputedStyle(state.gl.canvas).height) * window.devicePixelRatio,
        1000 ]

    setGlResolution.apply(void 0, [ state.gl ].concat( resolution ))
    state.projectionMatrix = m4.perspective(45, resolution[0] / resolution[1], 1, 2000)
}

var WebGlRenderer = function WebGlRenderer () {};

WebGlRenderer.prototype.initGl = function initGl (scene) {
    const gl = createWebGLContext(scene)
    const state = scene.webGlRendererState
    state.gl = gl

    if (!gl) { console.log('You need WebGL.') }

    const vertShader = createShader(gl, gl.VERTEX_SHADER, vertShaderSource)
    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource)
    const program = createProgram(gl, vertShader, fragShader)
    gl.useProgram(program)


    state.colorsBuffer = gl.createBuffer()
    state.colorAttributeLocation = gl.getAttribLocation(program, 'a_color')
    gl.enableVertexAttribArray(state.colorAttributeLocation)

    state.vertexBuffer = gl.createBuffer()
    state.vertexAttributeLocation = gl.getAttribLocation(program, "a_vertexPosition")
    gl.enableVertexAttribArray(state.vertexAttributeLocation)

    state.normalsBuffer = gl.createBuffer()
    state.normalAttributeLocation = gl.getAttribLocation(program, 'a_normal')
    gl.enableVertexAttribArray(state.normalAttributeLocation)

    state.textureCoordinatesBuffer = gl.createBuffer()
    state.textureCoordinateLocation = gl.getAttribLocation(program, 'a_textureCoordinate')

    // cull_face doesn't work, because I've drawn my vertices in the wrong
    // order. They should be clockwise to be front facing (I seem to have done
    // them counter-clockwise). See "CULL_FACE" at
    // https://webglfundamentals.org/webgl/lessons/webgl-3d-orthographic.html
    //gl.enable(gl.CULL_FACE)

    // enables depth sorting, so pixels aren't drawn in order of appearance, but order only if they are visible (on top of other pixels).
    gl.enable(gl.DEPTH_TEST)

    // enable alpha blending (transparency)
    // XXX: For blending (transparency) to work, we have to disable depth testing.
    // TODO: Maybe we have to selectively enable depth testing and disable
    // blending, or vice versa, depending on the object we want to draw...
    // ...Or perhaps we must draw things in a certain order, from back to front,
    // so we can have depth testing AND blending at the same time.
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
    gl.enable(gl.BLEND)
    //gl.disable(gl.DEPTH_TEST)

    state.projectionMatrix = m4.identity

    updateResolution(state)
    scene.on('parentsizechange', function () { return updateResolution(state); })

    state.worldViewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_worldViewProjectionMatrix')
    //const worldInverseTransposeMatrixLocation = gl.getUniformLocation(program, 'u_worldInverseTransposeMatrix')
    state.worldMatrixLocation = gl.getUniformLocation(program, 'u_worldMatrix')
    //const reverseLightDirectionLocation = gl.getUniformLocation(program, 'reverseLightDirection')
    //gl.uniform3fv(reverseLightDirectionLocation, v3.normalize([0.5, 0.7, 1]))
    state.lightWorldPositionLocation = gl.getUniformLocation(program, 'u_lightWorldPosition')
    state.cameraWorldPositionLocation = gl.getUniformLocation(program, 'u_cameraWorldPosition')
    const shininessLocation = gl.getUniformLocation(program, 'u_shininess')
    const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor')
    const specularColorLocation = gl.getUniformLocation(program, 'u_specularColor')
    state.textureLocation = gl.getUniformLocation(program, 'u_texture')
    state.hasTextureLocation = gl.getUniformLocation(program, 'u_hasTexture')

    let shininess = 200
    gl.uniform1f(shininessLocation, shininess)

    const red = [1, 0.6, 0.6]
    const white = [1, 1, 1]

    let lightColor = white
    gl.uniform3fv(lightColorLocation, v3.normalize(lightColor))

    let specularColor = white
    gl.uniform3fv(specularColorLocation, v3.normalize(specularColor))


    state.lightAnimParam = 0
    state.lightWorldPosition = [20,30,50]
    state.cameraAngle = 0
    state.cameraRadius   = 200
};

WebGlRenderer.prototype.drawScene = function drawScene (scene) {
        var this$1 = this;

    const state = scene.webGlRendererState
    var gl = state.gl;

    // TODO: light does not affect the back side of polygons?...
    state.lightAnimParam += 0.05
    state.lightWorldPosition = [
        300*Math.sin(state.lightAnimParam),
        300*Math.sin(state.lightAnimParam*2),

        Math.abs(300*Math.cos(state.lightAnimParam))
        //300
    ]

    gl.uniform3fv(state.lightWorldPositionLocation, state.lightWorldPosition)

    let backgroundColor = scene.getAttribute('background')

    if (typeof backgroundColor == 'string')
        { backgroundColor = backgroundColor.split(' ').map(function (rgbPart) { return parseFloat(rgbPart); }) }
    else
        { backgroundColor = [0, 0, 0, 0] }

    gl.clearColor.apply(gl, backgroundColor)
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // why do we need to do this?

    //state.cameraAngle++
    let cameraMatrix  = m4.identity
    cameraMatrix  = m4.multiply(cameraMatrix, m4.yRotation(state.cameraAngle))
    cameraMatrix  = m4.multiply(cameraMatrix, m4.translation(0, 0, state.cameraRadius * 1.5))
    const viewMatrix  = m4.inverse(cameraMatrix)

    state.viewProjectionMatrix = m4.multiply(state.projectionMatrix, viewMatrix)

    const cameraWorldPosition = [cameraMatrix[12], cameraMatrix[13], cameraMatrix[14]]
    gl.uniform3fv(state.cameraWorldPositionLocation, cameraWorldPosition)

    // TODO: we need to use the traversal that takes into consideration ShadowDOM.
    const children = scene.imperativeCounterpart._children
    for (let i=0, l=children.length; i<l; i+=1) {
        this$1.drawNodeAndRecurse(state, children[i])
    }
};

WebGlRenderer.prototype.drawNodeAndRecurse = function drawNodeAndRecurse (state, node) {
        var this$1 = this;

    var gl = state.gl;

    const meshAttr = node.element.getAttribute('mesh')

    if (meshAttr) {
        const size = node._calculatedSize

        const svgElement = Array.from(node.element.children)
            .find(function (child) { return child instanceof SVGSVGElement; })

        const hasTexture = !!svgElement

        if (meshAttr == 'cube') {
            if (!(node.__shape instanceof Cube))
                { node.__shape = new Cube(0, 0, size.x) }
            // TODO else, like quad or symtrap
        }
        else if (meshAttr == 'quad') {
            if (!(node.__shape instanceof Quad))
                { node.__shape = new Quad(size.x, size.y) }
            else {
                node.__shape.width = size.x
                node.__shape.height = size.y
                node.__shape._calcVerts()
            }

            if (hasTexture) {

                // TODO we would create one per Geometry (and eventually multiple per
                // geometry), but for now just one texture for all quads to get it working.
                // TODO Make the texture only once, not each tick.
                if (!node.__texture) {

                    // XXX this will eventually be set with a texture map feature
                    // TODO: for now, we should at least set default
                    // coordinates for each geometry, even if that's not
                    // ideal; it's more ideal than nothing.
                    node.__shape.textureCoordinates = new Float32Array([
                        0, 0,
                        1, 0,
                        1, 1,
                        1, 1,
                        0, 1,
                        0, 0 ])

                    node.__texture = gl.createTexture()
                }

                ///// SVG TEXTURE FROM TWO.JS {
                if (!node.__two) {
                    node.__two = new Two({
                        type: Two.Types.webgl,
                        fullscreen: false,
                        autostart: false,
                    })

                    node.__two.interpret(svgElement)
                }

                node.__two.update()

                const image = node.__two.renderer.domElement
                const isPowerOf2 = function (value) { return (value & (value - 1)) == 0; }

                // copy the pixi canvas image to the texture.
                gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                // TODO: unbind from buffers and textures when done
                // using them, to prevent modification from outside

                // Mip maps can only be generated on images whose width and height are a power of 2.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    gl.generateMipmap(gl.TEXTURE_2D)
                    // TODO make filters configurable?
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                    // Using just NEAREST or LINEAR only can increase performance, for example.
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                }
                else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                    // TODO make filters configurable?
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                }
                ///// }

                ///// SVG TEXTURE FROM PIXI-SVG {
                //if (!node.__pixiRenderer) {
                    //node.__pixiRenderer = PIXI.autoDetectRenderer({

                        //width: node._calculatedSize.x * window.devicePixelRatio,
                        //height: node._calculatedSize.y * window.devicePixelRatio,
                        ////width: 300 * window.devicePixelRatio,
                        ////height: 300 * window.devicePixelRatio,

                        //resolution: window.devicePixelRatio,
                    //});

                    //node.__pixiStage = new PIXI.Container()
                    //window.stage = node.__pixiStage
                //}

                //node.__pixiStage.removeChild(node.__svgGraphic)

                //node.__svgGraphic = new SVG(svgElement)

                //node.__pixiStage.addChild(node.__svgGraphic)

                //node.__pixiRenderer.render(node.__pixiStage);

                //const image = node.__pixiRenderer.view
                //const isPowerOf2 = value => (value & (value - 1)) == 0

                //// copy the pixi canvas image to the texture.
                //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                //// TODO: unbind from buffers and textures when done
                //// using them, to prevent modification from outside

                //// Mip maps can only be generated on images whose width and height are a power of 2.
                //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    //gl.generateMipmap(gl.TEXTURE_2D)
                    //// TODO make filters configurable?
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                    //// Using just NEAREST or LINEAR only can increase performance, for example.
                    ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                //}
                //else {
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                    //// TODO make filters configurable?
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                //}

                ///// }

                ///// PRE-DEFINED TEXTURE FROM IMAGE {

                //// set a temporary solid color texture for the meantime
                //// while the following texture loads.
                //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                //// Fill the texture with a 1x1 blue pixel to start with.
                //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]))
                //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                //const image = new Image
                //const isPowerOf2 = value => (value & (value - 1)) == 0
                //image.addEventListener('load', () => {
                    //// Now that the image has loaded copy it to the texture.
                    //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                    //// TODO: unbind from buffers and textures when done
                    //// using them, to prevent modification from outside

                    //// Mip maps can only be generated on images whose width and height are a power of 2.
                    //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        //gl.generateMipmap(gl.TEXTURE_2D)
                        //// TODO make filters configurable?
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                        //// Using just NEAREST or LINEAR only can increase performance, for example.
                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    //}
                    //else {
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                        //// TODO make filters configurable?
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    //}
                //})
                //image.src = imageUrl // imageUrl should be a data URL
                //// }
            }
        }
        else if (meshAttr == 'isotriangle') {
            if (!(node.__shape instanceof IsoscelesTriangle))
                { node.__shape = new IsoscelesTriangle(size.x, size.y) }
            // TODO else, like quad or symtrap
        }
        else if (meshAttr == 'pyramid4') {
            if (!(node.__shape instanceof FourSidedPyramid))
                { node.__shape = new FourSidedPyramid(size.x, size.y) }
            // TODO else, like quad or symtrap
        }
        else if (meshAttr == 'symtrap') {
            if (!(node.__shape instanceof SymmetricTrapezoid))
                { node.__shape = new SymmetricTrapezoid(size.x/2, size.x, size.y) }
            else {
                node.__shape.baseWidth = size.x/2
                node.__shape.topWidth = size.x
                node.__shape.height = size.y
                node.__shape._calcVerts()
            }
        }
        //else node.__shape = null
        else {
            if (!(node.__shape instanceof Quad))
                { node.__shape = new Quad(size.x, size.y) }
            else {
                node.__shape.width = size.x
                node.__shape.height = size.y
                node.__shape._calcVerts()
            }
            // TODO this will eventually be set with a texture map feature
            if (hasTexture) {
                node.__shape.textureCoordinates = new Float32Array([
                    0, 0,
                    1, 0,
                    1, 1,
                    1, 1,
                    0, 1,
                    0, 0 ])
            }
        }

        if (node.__shape) {
            // COLORS /////////////////////////////////
            node.__shape.color = node.element.getAttribute('color')

            gl.bindBuffer(gl.ARRAY_BUFFER, state.colorsBuffer)
            gl.bufferData(gl.ARRAY_BUFFER, node.__shape._colors, gl.STATIC_DRAW)

            // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
            const colorSize = 4      // components per iteration
            const colorType = gl.FLOAT
            const normalizeColorData = false // don't normalize the data
            const colorStride = 0    // 0 = move forward colorSize * sizeof(colorType) each iteration to get the next vertex
            const colorOffset = 0    // start at the beginning of the buffer
            gl.vertexAttribPointer(
                state.colorAttributeLocation, colorSize, colorType, normalizeColorData, colorStride, colorOffset)

            // VERTICES /////////////////////////////////
            gl.bindBuffer(gl.ARRAY_BUFFER, state.vertexBuffer)
            gl.bufferData(gl.ARRAY_BUFFER, node.__shape.verts, gl.STATIC_DRAW)

            // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
            const vertexSize = 3      // components per iteration
            const type = gl.FLOAT
            const normalizeVertexData = false // don't normalize the data
            const stride = 0    // 0 = move forward vertexSize * sizeof(type) each iteration to get the next vertex
            const offset = 0    // start at the beginning of the buffer
            gl.vertexAttribPointer(
                state.vertexAttributeLocation, vertexSize, type, normalizeVertexData, stride, offset)

            // NORMALS /////////////////////////////////
            gl.bindBuffer(gl.ARRAY_BUFFER, state.normalsBuffer)
            gl.bufferData(gl.ARRAY_BUFFER, node.__shape.normals, gl.STATIC_DRAW)

            // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
            const normalSize = 3      // components per iteration
            const normalType = gl.FLOAT
            const normalizeNormalsData = false // don't normalize the data
            const normalStride = 0    // 0 = move forward normalSize * sizeof(normalType) each iteration to get the next vertex
            const normalOffset = 0    // start at the beginning of the buffer
            gl.vertexAttribPointer(
                state.normalAttributeLocation, normalSize, normalType, normalizeNormalsData, normalStride, normalOffset)

            // TEXTURE COORDINATES /////////////////////////////////
            if (hasTexture) {
                gl.uniform1i(state.hasTextureLocation, +true)

                gl.bindBuffer(gl.ARRAY_BUFFER, state.textureCoordinatesBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, node.__shape.textureCoordinates, gl.STATIC_DRAW)

                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
                const textureCoordinateSize = 2      // components per iteration
                const textureCoordinateType = gl.FLOAT
                const normalizeTextureCoordinateData = false // don't normalize the data
                const textureCoordinateStride = 0    // 0 = move forward textureCoordinateSize * sizeof(textureCoordinateType) each iteration to get the next vertex
                const textureCoordinateOffset = 0    // start at the beginning of the buffer
                gl.enableVertexAttribArray(state.textureCoordinateLocation)
                gl.vertexAttribPointer(
                    state.textureCoordinateLocation, textureCoordinateSize, textureCoordinateType, normalizeTextureCoordinateData, textureCoordinateStride, textureCoordinateOffset)

                // Tell the shader to use texture unit 0 for u_texture
                // TODO: Get index of the node's texture, but right now there's only one texture.
                gl.uniform1i(state.textureLocation, 0)
            }
            else {
                gl.uniform1i(state.hasTextureLocation, +false)
                gl.disableVertexAttribArray(state.textureCoordinateLocation)
            }

            // TRANFORMS /////////////////////////////////
            gl.uniformMatrix4fv(state.worldMatrixLocation, false, node._worldMatrix.toFloat32Array())

            // for correct lighting normals
            // TODO: waiting for transpose() method on DOMMatrix
            //const worldInverseTransposeMatrix = m4.transpose(m4.inverse(node._worldMatrix))
            //gl.uniformMatrix4fv(worldInverseTransposeMatrixLocation, false, worldInverseTransposeMatrix)

            const worldViewProjectionMatrix = m4.multiply(state.viewProjectionMatrix, node._worldMatrix.toFloat32Array())
            gl.uniformMatrix4fv(state.worldViewProjectionMatrixLocation, false, worldViewProjectionMatrix)

            const count = node.__shape.verts.length / 3
            gl.drawArrays(gl.TRIANGLES, offset, count)
        }
    }

    const children = node._children
    for (let i=0, l=children.length; i<l; i+=1) {
        this$1.drawNodeAndRecurse(state, children[i])
    }
};

let instance = null

export default
function getWebGlRenderer() {
    if (instance) { return instance }
    else { return instance = new WebGlRenderer }
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViR0xSZW5kZXJlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvV2ViR0xSZW5kZXJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGNyZWF0ZVdlYkdMQ29udGV4dCxcbiAgICAvL3JlbW92ZVdlYkdMQ29udGV4dCxcbiAgICBzZXRHbFJlc29sdXRpb24sXG4gICAgdjMsXG4gICAgbTQsXG4gICAgdmVydFNoYWRlclNvdXJjZSxcbiAgICBmcmFnU2hhZGVyU291cmNlLFxuICAgIGNyZWF0ZVNoYWRlcixcbiAgICBjcmVhdGVQcm9ncmFtLFxuICAgIEN1YmUsXG4gICAgUXVhZCxcbiAgICBGb3VyU2lkZWRQeXJhbWlkLFxuICAgIElzb3NjZWxlc1RyaWFuZ2xlLFxuICAgIFN5bW1ldHJpY1RyYXBlem9pZCxcbn0gZnJvbSAnLi93ZWJnbFV0aWxzJ1xuXG5jb25zdCB1cGRhdGVSZXNvbHV0aW9uID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSBbXG4gICAgICAgIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5nbC5jYW52YXMpLndpZHRoKSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZ2wuY2FudmFzKS5oZWlnaHQpICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIDEwMDAsXG4gICAgXVxuXG4gICAgc2V0R2xSZXNvbHV0aW9uKHN0YXRlLmdsLCAuLi5yZXNvbHV0aW9uKVxuICAgIHN0YXRlLnByb2plY3Rpb25NYXRyaXggPSBtNC5wZXJzcGVjdGl2ZSg0NSwgcmVzb2x1dGlvblswXSAvIHJlc29sdXRpb25bMV0sIDEsIDIwMDApXG59XG5cbmNsYXNzIFdlYkdsUmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFdlYkdMIHByb2dyYW0gZm9yIHRoZSBnaXZlbiBzY2VuZS5cbiAgICAgKi9cbiAgICBpbml0R2woc2NlbmUpIHtcbiAgICAgICAgY29uc3QgZ2wgPSBjcmVhdGVXZWJHTENvbnRleHQoc2NlbmUpXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc2NlbmUud2ViR2xSZW5kZXJlclN0YXRlXG4gICAgICAgIHN0YXRlLmdsID0gZ2xcblxuICAgICAgICBpZiAoIWdsKSB7IGNvbnNvbGUubG9nKCdZb3UgbmVlZCBXZWJHTC4nKSB9XG5cbiAgICAgICAgY29uc3QgdmVydFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydFNoYWRlclNvdXJjZSlcbiAgICAgICAgY29uc3QgZnJhZ1NoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnU2hhZGVyU291cmNlKVxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcilcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKVxuXG5cbiAgICAgICAgc3RhdGUuY29sb3JzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgICAgc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJylcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgICAgICBzdGF0ZS52ZXJ0ZXhBdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV92ZXJ0ZXhQb3NpdGlvblwiKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS52ZXJ0ZXhBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS5ub3JtYWxzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgICAgc3RhdGUubm9ybWFsQXR0cmlidXRlTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9ub3JtYWwnKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS5ub3JtYWxBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgICAgICBzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGV4dHVyZUNvb3JkaW5hdGUnKVxuXG4gICAgICAgIC8vIGN1bGxfZmFjZSBkb2Vzbid0IHdvcmssIGJlY2F1c2UgSSd2ZSBkcmF3biBteSB2ZXJ0aWNlcyBpbiB0aGUgd3JvbmdcbiAgICAgICAgLy8gb3JkZXIuIFRoZXkgc2hvdWxkIGJlIGNsb2Nrd2lzZSB0byBiZSBmcm9udCBmYWNpbmcgKEkgc2VlbSB0byBoYXZlIGRvbmVcbiAgICAgICAgLy8gdGhlbSBjb3VudGVyLWNsb2Nrd2lzZSkuIFNlZSBcIkNVTExfRkFDRVwiIGF0XG4gICAgICAgIC8vIGh0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtM2Qtb3J0aG9ncmFwaGljLmh0bWxcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKVxuXG4gICAgICAgIC8vIGVuYWJsZXMgZGVwdGggc29ydGluZywgc28gcGl4ZWxzIGFyZW4ndCBkcmF3biBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLCBidXQgb3JkZXIgb25seSBpZiB0aGV5IGFyZSB2aXNpYmxlIChvbiB0b3Agb2Ygb3RoZXIgcGl4ZWxzKS5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpXG5cbiAgICAgICAgLy8gZW5hYmxlIGFscGhhIGJsZW5kaW5nICh0cmFuc3BhcmVuY3kpXG4gICAgICAgIC8vIFhYWDogRm9yIGJsZW5kaW5nICh0cmFuc3BhcmVuY3kpIHRvIHdvcmssIHdlIGhhdmUgdG8gZGlzYWJsZSBkZXB0aCB0ZXN0aW5nLlxuICAgICAgICAvLyBUT0RPOiBNYXliZSB3ZSBoYXZlIHRvIHNlbGVjdGl2ZWx5IGVuYWJsZSBkZXB0aCB0ZXN0aW5nIGFuZCBkaXNhYmxlXG4gICAgICAgIC8vIGJsZW5kaW5nLCBvciB2aWNlIHZlcnNhLCBkZXBlbmRpbmcgb24gdGhlIG9iamVjdCB3ZSB3YW50IHRvIGRyYXcuLi5cbiAgICAgICAgLy8gLi4uT3IgcGVyaGFwcyB3ZSBtdXN0IGRyYXcgdGhpbmdzIGluIGEgY2VydGFpbiBvcmRlciwgZnJvbSBiYWNrIHRvIGZyb250LFxuICAgICAgICAvLyBzbyB3ZSBjYW4gaGF2ZSBkZXB0aCB0ZXN0aW5nIEFORCBibGVuZGluZyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORClcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpXG5cbiAgICAgICAgc3RhdGUucHJvamVjdGlvbk1hdHJpeCA9IG00LmlkZW50aXR5XG5cbiAgICAgICAgdXBkYXRlUmVzb2x1dGlvbihzdGF0ZSlcbiAgICAgICAgc2NlbmUub24oJ3BhcmVudHNpemVjaGFuZ2UnLCAoKSA9PiB1cGRhdGVSZXNvbHV0aW9uKHN0YXRlKSlcblxuICAgICAgICBzdGF0ZS53b3JsZFZpZXdQcm9qZWN0aW9uTWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfd29ybGRWaWV3UHJvamVjdGlvbk1hdHJpeCcpXG4gICAgICAgIC8vY29uc3Qgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4JylcbiAgICAgICAgc3RhdGUud29ybGRNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV93b3JsZE1hdHJpeCcpXG4gICAgICAgIC8vY29uc3QgcmV2ZXJzZUxpZ2h0RGlyZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3JldmVyc2VMaWdodERpcmVjdGlvbicpXG4gICAgICAgIC8vZ2wudW5pZm9ybTNmdihyZXZlcnNlTGlnaHREaXJlY3Rpb25Mb2NhdGlvbiwgdjMubm9ybWFsaXplKFswLjUsIDAuNywgMV0pKVxuICAgICAgICBzdGF0ZS5saWdodFdvcmxkUG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodFdvcmxkUG9zaXRpb24nKVxuICAgICAgICBzdGF0ZS5jYW1lcmFXb3JsZFBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfY2FtZXJhV29ybGRQb3NpdGlvbicpXG4gICAgICAgIGNvbnN0IHNoaW5pbmVzc0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NoaW5pbmVzcycpXG4gICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodENvbG9yJylcbiAgICAgICAgY29uc3Qgc3BlY3VsYXJDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NwZWN1bGFyQ29sb3InKVxuICAgICAgICBzdGF0ZS50ZXh0dXJlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4dHVyZScpXG4gICAgICAgIHN0YXRlLmhhc1RleHR1cmVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9oYXNUZXh0dXJlJylcblxuICAgICAgICBsZXQgc2hpbmluZXNzID0gMjAwXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGluaW5lc3NMb2NhdGlvbiwgc2hpbmluZXNzKVxuXG4gICAgICAgIGNvbnN0IHJlZCA9IFsxLCAwLjYsIDAuNl1cbiAgICAgICAgY29uc3Qgd2hpdGUgPSBbMSwgMSwgMV1cblxuICAgICAgICBsZXQgbGlnaHRDb2xvciA9IHdoaXRlXG4gICAgICAgIGdsLnVuaWZvcm0zZnYobGlnaHRDb2xvckxvY2F0aW9uLCB2My5ub3JtYWxpemUobGlnaHRDb2xvcikpXG5cbiAgICAgICAgbGV0IHNwZWN1bGFyQ29sb3IgPSB3aGl0ZVxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNwZWN1bGFyQ29sb3JMb2NhdGlvbiwgdjMubm9ybWFsaXplKHNwZWN1bGFyQ29sb3IpKVxuXG5cbiAgICAgICAgc3RhdGUubGlnaHRBbmltUGFyYW0gPSAwXG4gICAgICAgIHN0YXRlLmxpZ2h0V29ybGRQb3NpdGlvbiA9IFsyMCwzMCw1MF1cbiAgICAgICAgc3RhdGUuY2FtZXJhQW5nbGUgPSAwXG4gICAgICAgIHN0YXRlLmNhbWVyYVJhZGl1cyAgID0gMjAwXG4gICAgfVxuXG4gICAgZHJhd1NjZW5lKHNjZW5lKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc2NlbmUud2ViR2xSZW5kZXJlclN0YXRlXG4gICAgICAgIGNvbnN0IHtnbH0gPSBzdGF0ZVxuXG4gICAgICAgIC8vIFRPRE86IGxpZ2h0IGRvZXMgbm90IGFmZmVjdCB0aGUgYmFjayBzaWRlIG9mIHBvbHlnb25zPy4uLlxuICAgICAgICBzdGF0ZS5saWdodEFuaW1QYXJhbSArPSAwLjA1XG4gICAgICAgIHN0YXRlLmxpZ2h0V29ybGRQb3NpdGlvbiA9IFtcbiAgICAgICAgICAgIDMwMCpNYXRoLnNpbihzdGF0ZS5saWdodEFuaW1QYXJhbSksXG4gICAgICAgICAgICAzMDAqTWF0aC5zaW4oc3RhdGUubGlnaHRBbmltUGFyYW0qMiksXG5cbiAgICAgICAgICAgIE1hdGguYWJzKDMwMCpNYXRoLmNvcyhzdGF0ZS5saWdodEFuaW1QYXJhbSkpXG4gICAgICAgICAgICAvLzMwMFxuICAgICAgICBdXG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzdGF0ZS5saWdodFdvcmxkUG9zaXRpb25Mb2NhdGlvbiwgc3RhdGUubGlnaHRXb3JsZFBvc2l0aW9uKVxuXG4gICAgICAgIGxldCBiYWNrZ3JvdW5kQ29sb3IgPSBzY2VuZS5nZXRBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZENvbG9yID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yLnNwbGl0KCcgJykubWFwKHJnYlBhcnQgPT4gcGFyc2VGbG9hdChyZ2JQYXJ0KSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gWzAsIDAsIDAsIDBdXG5cbiAgICAgICAgZ2wuY2xlYXJDb2xvciguLi5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKSAvLyB3aHkgZG8gd2UgbmVlZCB0byBkbyB0aGlzP1xuXG4gICAgICAgIC8vc3RhdGUuY2FtZXJhQW5nbGUrK1xuICAgICAgICBsZXQgY2FtZXJhTWF0cml4ICA9IG00LmlkZW50aXR5XG4gICAgICAgIGNhbWVyYU1hdHJpeCAgICAgID0gbTQubXVsdGlwbHkoY2FtZXJhTWF0cml4LCBtNC55Um90YXRpb24oc3RhdGUuY2FtZXJhQW5nbGUpKVxuICAgICAgICBjYW1lcmFNYXRyaXggICAgICA9IG00Lm11bHRpcGx5KGNhbWVyYU1hdHJpeCwgbTQudHJhbnNsYXRpb24oMCwgMCwgc3RhdGUuY2FtZXJhUmFkaXVzICogMS41KSlcbiAgICAgICAgY29uc3Qgdmlld01hdHJpeCAgPSBtNC5pbnZlcnNlKGNhbWVyYU1hdHJpeClcblxuICAgICAgICBzdGF0ZS52aWV3UHJvamVjdGlvbk1hdHJpeCA9IG00Lm11bHRpcGx5KHN0YXRlLnByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpXG5cbiAgICAgICAgY29uc3QgY2FtZXJhV29ybGRQb3NpdGlvbiA9IFtjYW1lcmFNYXRyaXhbMTJdLCBjYW1lcmFNYXRyaXhbMTNdLCBjYW1lcmFNYXRyaXhbMTRdXVxuICAgICAgICBnbC51bmlmb3JtM2Z2KHN0YXRlLmNhbWVyYVdvcmxkUG9zaXRpb25Mb2NhdGlvbiwgY2FtZXJhV29ybGRQb3NpdGlvbilcblxuICAgICAgICAvLyBUT0RPOiB3ZSBuZWVkIHRvIHVzZSB0aGUgdHJhdmVyc2FsIHRoYXQgdGFrZXMgaW50byBjb25zaWRlcmF0aW9uIFNoYWRvd0RPTS5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzY2VuZS5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX2NoaWxkcmVuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZUFuZFJlY3Vyc2Uoc3RhdGUsIGNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhd05vZGVBbmRSZWN1cnNlKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHtnbH0gPSBzdGF0ZVxuXG4gICAgICAgIGNvbnN0IG1lc2hBdHRyID0gbm9kZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVzaCcpXG5cbiAgICAgICAgaWYgKG1lc2hBdHRyKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gbm9kZS5fY2FsY3VsYXRlZFNpemVcblxuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IEFycmF5LmZyb20obm9kZS5lbGVtZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIC5maW5kKGNoaWxkID0+IGNoaWxkIGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudClcblxuICAgICAgICAgICAgY29uc3QgaGFzVGV4dHVyZSA9ICEhc3ZnRWxlbWVudFxuXG4gICAgICAgICAgICBpZiAobWVzaEF0dHIgPT0gJ2N1YmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZS5fX3NoYXBlIGluc3RhbmNlb2YgQ3ViZSkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBDdWJlKDAsIDAsIHNpemUueClcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGVsc2UsIGxpa2UgcXVhZCBvciBzeW10cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNoQXR0ciA9PSAncXVhZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBRdWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlID0gbmV3IFF1YWQoc2l6ZS54LCBzaXplLnkpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS53aWR0aCA9IHNpemUueFxuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuaGVpZ2h0ID0gc2l6ZS55XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5fY2FsY1ZlcnRzKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd2Ugd291bGQgY3JlYXRlIG9uZSBwZXIgR2VvbWV0cnkgKGFuZCBldmVudHVhbGx5IG11bHRpcGxlIHBlclxuICAgICAgICAgICAgICAgICAgICAvLyBnZW9tZXRyeSksIGJ1dCBmb3Igbm93IGp1c3Qgb25lIHRleHR1cmUgZm9yIGFsbCBxdWFkcyB0byBnZXQgaXQgd29ya2luZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNYWtlIHRoZSB0ZXh0dXJlIG9ubHkgb25jZSwgbm90IGVhY2ggdGljay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLl9fdGV4dHVyZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFggdGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgc2V0IHdpdGggYSB0ZXh0dXJlIG1hcCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB3ZSBzaG91bGQgYXQgbGVhc3Qgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIGZvciBlYWNoIGdlb21ldHJ5LCBldmVuIGlmIHRoYXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkZWFsOyBpdCdzIG1vcmUgaWRlYWwgdGhhbiBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLnRleHR1cmVDb29yZGluYXRlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIFNWRyBURVhUVVJFIEZST00gVFdPLkpTIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLl9fdHdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9fdHdvID0gbmV3IFR3byh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdvLlR5cGVzLndlYmdsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9zdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9fdHdvLmludGVycHJldChzdmdFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3R3by51cGRhdGUoKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbm9kZS5fX3R3by5yZW5kZXJlci5kb21FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUG93ZXJPZjIgPSB2YWx1ZSA9PiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT0gMFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHBpeGkgY2FudmFzIGltYWdlIHRvIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdW5iaW5kIGZyb20gYnVmZmVycyBhbmQgdGV4dHVyZXMgd2hlbiBkb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZW0sIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uIGZyb20gb3V0c2lkZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pcCBtYXBzIGNhbiBvbmx5IGJlIGdlbmVyYXRlZCBvbiBpbWFnZXMgd2hvc2Ugd2lkdGggYW5kIGhlaWdodCBhcmUgYSBwb3dlciBvZiAyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb3dlck9mMihpbWFnZS53aWR0aCkgJiYgaXNQb3dlck9mMihpbWFnZS5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBtYWtlIGZpbHRlcnMgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUilcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcganVzdCBORUFSRVNUIG9yIExJTkVBUiBvbmx5IGNhbiBpbmNyZWFzZSBwZXJmb3JtYW5jZSwgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBmaWx0ZXJzIGNvbmZpZ3VyYWJsZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIH1cblxuICAgICAgICAgICAgICAgICAgICAvLy8vLyBTVkcgVEVYVFVSRSBGUk9NIFBJWEktU1ZHIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoIW5vZGUuX19waXhpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9kZS5fX3BpeGlSZW5kZXJlciA9IFBJWEkuYXV0b0RldGVjdFJlbmRlcmVyKHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2lkdGg6IG5vZGUuX2NhbGN1bGF0ZWRTaXplLnggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hlaWdodDogbm9kZS5fY2FsY3VsYXRlZFNpemUueSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy93aWR0aDogMzAwICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL2hlaWdodDogMzAwICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc29sdXRpb246IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy99KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fcGl4aVN0YWdlID0gbmV3IFBJWEkuQ29udGFpbmVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2luZG93LnN0YWdlID0gbm9kZS5fX3BpeGlTdGFnZVxuICAgICAgICAgICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuX19waXhpU3RhZ2UucmVtb3ZlQ2hpbGQobm9kZS5fX3N2Z0dyYXBoaWMpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fc3ZnR3JhcGhpYyA9IG5ldyBTVkcoc3ZnRWxlbWVudClcblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuX19waXhpU3RhZ2UuYWRkQ2hpbGQobm9kZS5fX3N2Z0dyYXBoaWMpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fcGl4aVJlbmRlcmVyLnJlbmRlcihub2RlLl9fcGl4aVN0YWdlKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGltYWdlID0gbm9kZS5fX3BpeGlSZW5kZXJlci52aWV3XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgaXNQb3dlck9mMiA9IHZhbHVlID0+ICh2YWx1ZSAmICh2YWx1ZSAtIDEpKSA9PSAwXG5cbiAgICAgICAgICAgICAgICAgICAgLy8vLyBjb3B5IHRoZSBwaXhpIGNhbnZhcyBpbWFnZSB0byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSlcblxuICAgICAgICAgICAgICAgICAgICAvLy8vIFRPRE86IHVuYmluZCBmcm9tIGJ1ZmZlcnMgYW5kIHRleHR1cmVzIHdoZW4gZG9uZVxuICAgICAgICAgICAgICAgICAgICAvLy8vIHVzaW5nIHRoZW0sIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uIGZyb20gb3V0c2lkZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gTWlwIG1hcHMgY2FuIG9ubHkgYmUgZ2VuZXJhdGVkIG9uIGltYWdlcyB3aG9zZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIDIuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGlzUG93ZXJPZjIoaW1hZ2Uud2lkdGgpICYmIGlzUG93ZXJPZjIoaW1hZ2UuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUilcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBVc2luZyBqdXN0IE5FQVJFU1Qgb3IgTElORUFSIG9ubHkgY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAvL2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIH1cblxuICAgICAgICAgICAgICAgICAgICAvLy8vLyBQUkUtREVGSU5FRCBURVhUVVJFIEZST00gSU1BR0Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gc2V0IGEgdGVtcG9yYXJ5IHNvbGlkIGNvbG9yIHRleHR1cmUgZm9yIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICAvLy8vIHdoaWxlIHRoZSBmb2xsb3dpbmcgdGV4dHVyZSBsb2Fkcy5cbiAgICAgICAgICAgICAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy8vLyBGaWxsIHRoZSB0ZXh0dXJlIHdpdGggYSAxeDEgYmx1ZSBwaXhlbCB0byBzdGFydCB3aXRoLlxuICAgICAgICAgICAgICAgICAgICAvL2dsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDI1NSwgMjU1XSkpXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBpbWFnZSA9IG5ldyBJbWFnZVxuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGlzUG93ZXJPZjIgPSB2YWx1ZSA9PiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT0gMFxuICAgICAgICAgICAgICAgICAgICAvL2ltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy8vIE5vdyB0aGF0IHRoZSBpbWFnZSBoYXMgbG9hZGVkIGNvcHkgaXQgdG8gdGhlIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG5vZGUuX190ZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPOiB1bmJpbmQgZnJvbSBidWZmZXJzIGFuZCB0ZXh0dXJlcyB3aGVuIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gdXNpbmcgdGhlbSwgdG8gcHJldmVudCBtb2RpZmljYXRpb24gZnJvbSBvdXRzaWRlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gTWlwIG1hcHMgY2FuIG9ubHkgYmUgZ2VuZXJhdGVkIG9uIGltYWdlcyB3aG9zZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIDIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChpc1Bvd2VyT2YyKGltYWdlLndpZHRoKSAmJiBpc1Bvd2VyT2YyKGltYWdlLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBVc2luZyBqdXN0IE5FQVJFU1Qgb3IgTElORUFSIG9ubHkgY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gVE9ETyBtYWtlIGZpbHRlcnMgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgLy99KVxuICAgICAgICAgICAgICAgICAgICAvL2ltYWdlLnNyYyA9IGltYWdlVXJsIC8vIGltYWdlVXJsIHNob3VsZCBiZSBhIGRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc2hBdHRyID09ICdpc290cmlhbmdsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBJc29zY2VsZXNUcmlhbmdsZSkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBJc29zY2VsZXNUcmlhbmdsZShzaXplLngsIHNpemUueSlcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGVsc2UsIGxpa2UgcXVhZCBvciBzeW10cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNoQXR0ciA9PSAncHlyYW1pZDQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZS5fX3NoYXBlIGluc3RhbmNlb2YgRm91clNpZGVkUHlyYW1pZCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBGb3VyU2lkZWRQeXJhbWlkKHNpemUueCwgc2l6ZS55KVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZWxzZSwgbGlrZSBxdWFkIG9yIHN5bXRyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc2hBdHRyID09ICdzeW10cmFwJykge1xuICAgICAgICAgICAgICAgIGlmICghKG5vZGUuX19zaGFwZSBpbnN0YW5jZW9mIFN5bW1ldHJpY1RyYXBlem9pZCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBTeW1tZXRyaWNUcmFwZXpvaWQoc2l6ZS54LzIsIHNpemUueCwgc2l6ZS55KVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuYmFzZVdpZHRoID0gc2l6ZS54LzJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLnRvcFdpZHRoID0gc2l6ZS54XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5oZWlnaHQgPSBzaXplLnlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLl9jYWxjVmVydHMoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZWxzZSBub2RlLl9fc2hhcGUgPSBudWxsXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBRdWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlID0gbmV3IFF1YWQoc2l6ZS54LCBzaXplLnkpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS53aWR0aCA9IHNpemUueFxuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuaGVpZ2h0ID0gc2l6ZS55XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5fY2FsY1ZlcnRzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHdpbGwgZXZlbnR1YWxseSBiZSBzZXQgd2l0aCBhIHRleHR1cmUgbWFwIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUudGV4dHVyZUNvb3JkaW5hdGVzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5fX3NoYXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ09MT1JTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5jb2xvciA9IG5vZGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbG9yJylcblxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBzdGF0ZS5jb2xvcnNCdWZmZXIpXG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vZGUuX19zaGFwZS5fY29sb3JzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yU2l6ZSA9IDQgICAgICAgICAgLy8gY29tcG9uZW50cyBwZXIgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JUeXBlID0gZ2wuRkxPQVRcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVDb2xvckRhdGEgPSBmYWxzZSAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclN0cmlkZSA9IDAgICAgICAgIC8vIDAgPSBtb3ZlIGZvcndhcmQgY29sb3JTaXplICogc2l6ZW9mKGNvbG9yVHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yT2Zmc2V0ID0gMCAgICAgICAgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbiwgY29sb3JTaXplLCBjb2xvclR5cGUsIG5vcm1hbGl6ZUNvbG9yRGF0YSwgY29sb3JTdHJpZGUsIGNvbG9yT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgLy8gVkVSVElDRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHN0YXRlLnZlcnRleEJ1ZmZlcilcbiAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbm9kZS5fX3NoYXBlLnZlcnRzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleFNpemUgPSAzICAgICAgICAgIC8vIGNvbXBvbmVudHMgcGVyIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnbC5GTE9BVFxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZVZlcnRleERhdGEgPSBmYWxzZSAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpZGUgPSAwICAgICAgICAvLyAwID0gbW92ZSBmb3J3YXJkIHZlcnRleFNpemUgKiBzaXplb2YodHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IDAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZlcnRleEF0dHJpYnV0ZUxvY2F0aW9uLCB2ZXJ0ZXhTaXplLCB0eXBlLCBub3JtYWxpemVWZXJ0ZXhEYXRhLCBzdHJpZGUsIG9mZnNldClcblxuICAgICAgICAgICAgICAgIC8vIE5PUk1BTFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHN0YXRlLm5vcm1hbHNCdWZmZXIpXG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vZGUuX19zaGFwZS5ub3JtYWxzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbFNpemUgPSAzICAgICAgICAgIC8vIGNvbXBvbmVudHMgcGVyIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbFR5cGUgPSBnbC5GTE9BVFxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZU5vcm1hbHNEYXRhID0gZmFsc2UgLy8gZG9uJ3Qgbm9ybWFsaXplIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsU3RyaWRlID0gMCAgICAgICAgLy8gMCA9IG1vdmUgZm9yd2FyZCBub3JtYWxTaXplICogc2l6ZW9mKG5vcm1hbFR5cGUpIGVhY2ggaXRlcmF0aW9uIHRvIGdldCB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxPZmZzZXQgPSAwICAgICAgICAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxBdHRyaWJ1dGVMb2NhdGlvbiwgbm9ybWFsU2l6ZSwgbm9ybWFsVHlwZSwgbm9ybWFsaXplTm9ybWFsc0RhdGEsIG5vcm1hbFN0cmlkZSwgbm9ybWFsT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgLy8gVEVYVFVSRSBDT09SRElOQVRFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoc3RhdGUuaGFzVGV4dHVyZUxvY2F0aW9uLCArdHJ1ZSlcblxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgc3RhdGUudGV4dHVyZUNvb3JkaW5hdGVzQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbm9kZS5fX3NoYXBlLnRleHR1cmVDb29yZGluYXRlcywgZ2wuU1RBVElDX0RSQVcpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCB0aGUgYXR0cmlidXRlIGhvdyB0byBnZXQgZGF0YSBvdXQgb2YgdmVydGV4QnVmZmVyIChBUlJBWV9CVUZGRVIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlU2l6ZSA9IDIgICAgICAgICAgLy8gY29tcG9uZW50cyBwZXIgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlVHlwZSA9IGdsLkZMT0FUXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZVRleHR1cmVDb29yZGluYXRlRGF0YSA9IGZhbHNlIC8vIGRvbid0IG5vcm1hbGl6ZSB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZVN0cmlkZSA9IDAgICAgICAgIC8vIDAgPSBtb3ZlIGZvcndhcmQgdGV4dHVyZUNvb3JkaW5hdGVTaXplICogc2l6ZW9mKHRleHR1cmVDb29yZGluYXRlVHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZU9mZnNldCA9IDAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZUxvY2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4dHVyZUNvb3JkaW5hdGVMb2NhdGlvbiwgdGV4dHVyZUNvb3JkaW5hdGVTaXplLCB0ZXh0dXJlQ29vcmRpbmF0ZVR5cGUsIG5vcm1hbGl6ZVRleHR1cmVDb29yZGluYXRlRGF0YSwgdGV4dHVyZUNvb3JkaW5hdGVTdHJpZGUsIHRleHR1cmVDb29yZGluYXRlT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIHNoYWRlciB0byB1c2UgdGV4dHVyZSB1bml0IDAgZm9yIHVfdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBHZXQgaW5kZXggb2YgdGhlIG5vZGUncyB0ZXh0dXJlLCBidXQgcmlnaHQgbm93IHRoZXJlJ3Mgb25seSBvbmUgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHN0YXRlLnRleHR1cmVMb2NhdGlvbiwgMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzdGF0ZS5oYXNUZXh0dXJlTG9jYXRpb24sICtmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHN0YXRlLnRleHR1cmVDb29yZGluYXRlTG9jYXRpb24pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVFJBTkZPUk1TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc3RhdGUud29ybGRNYXRyaXhMb2NhdGlvbiwgZmFsc2UsIG5vZGUuX3dvcmxkTWF0cml4LnRvRmxvYXQzMkFycmF5KCkpXG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgY29ycmVjdCBsaWdodGluZyBub3JtYWxzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FpdGluZyBmb3IgdHJhbnNwb3NlKCkgbWV0aG9kIG9uIERPTU1hdHJpeFxuICAgICAgICAgICAgICAgIC8vY29uc3Qgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4ID0gbTQudHJhbnNwb3NlKG00LmludmVyc2Uobm9kZS5fd29ybGRNYXRyaXgpKVxuICAgICAgICAgICAgICAgIC8vZ2wudW5pZm9ybU1hdHJpeDRmdih3b3JsZEludmVyc2VUcmFuc3Bvc2VNYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHdvcmxkSW52ZXJzZVRyYW5zcG9zZU1hdHJpeClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmxkVmlld1Byb2plY3Rpb25NYXRyaXggPSBtNC5tdWx0aXBseShzdGF0ZS52aWV3UHJvamVjdGlvbk1hdHJpeCwgbm9kZS5fd29ybGRNYXRyaXgudG9GbG9hdDMyQXJyYXkoKSlcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHN0YXRlLndvcmxkVmlld1Byb2plY3Rpb25NYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHdvcmxkVmlld1Byb2plY3Rpb25NYXRyaXgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IG5vZGUuX19zaGFwZS52ZXJ0cy5sZW5ndGggLyAzXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIG9mZnNldCwgY291bnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuX2NoaWxkcmVuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZUFuZFJlY3Vyc2Uoc3RhdGUsIGNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5sZXQgaW5zdGFuY2UgPSBudWxsXG5cbmV4cG9ydCBkZWZhdWx0XG5mdW5jdGlvbiBnZXRXZWJHbFJlbmRlcmVyKCkge1xuICAgIGlmIChpbnN0YW5jZSkgcmV0dXJuIGluc3RhbmNlXG4gICAgZWxzZSByZXR1cm4gaW5zdGFuY2UgPSBuZXcgV2ViR2xSZW5kZXJlclxufVxuIl0sIm5hbWVzIjpbInRoaXMiXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksa0JBQWtCOztJQUVsQixlQUFlO0lBQ2YsRUFBRTtJQUNGLEVBQUU7SUFDRixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWixhQUFhO0lBQ2IsSUFBSTtJQUNKLElBQUk7SUFDSixnQkFBZ0I7SUFDaEIsaUJBQWlCO0lBQ2pCLGtCQUFrQjtPQUNmLGNBQWM7O0FBRXJCLE1BQU0sZ0JBQWdCLEdBQUcsVUFBQSxLQUFLLENBQUEsQ0FBQyxBQUFHO0lBQzlCLE1BQU0sVUFBVSxHQUFHO1FBQ2YsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLGdCQUFnQjtRQUM3RSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsZ0JBQWdCO1FBQzlFLElBQUksQ0FDUixDQUFDOztJQUVELGVBQWUsTUFBQSxDQUFDLFVBQUEsS0FBSyxDQUFDLEVBQUUsV0FBRSxBQUFHLFVBQVUsRUFBQSxDQUFDO0lBQ3hDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM7Q0FDdEY7O0FBRUQsSUFBTSxhQUFhLEdBQUM7O0FBQUEsQUFDcEIsQUFBSSxBQUNILEFBQUksQUFDSixBQUFJLEFBQ0wsQUFBSSx3QkFBQSxNQUFNLG1CQUFBLENBQUMsS0FBSyxFQUFFO0lBQ2QsQUFBSSxNQUFNLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUM7SUFDeEMs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