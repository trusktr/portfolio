import documentReady from 'awaitbox/dom/documentReady'
import Transformable from './Transformable'
import getWebGlRenderer from './WebGLRenderer'

import {
    //animationFrame,
} from './Utility'

let documentIsReady = false
let webGLRenderer = null

var Motor = function Motor() {
    this._inFrame = false // true when inside a requested animation frame.
    this._rAF = null // the current animation frame, or null.
    this._animationLoopStarted = false
    this._allRenderTasks = []
    this._taskIterationIndex = 0
    this._numberOfTasks = 0
    this._nodesToBeRendered = []
    this._modifiedScenes = []

    // A set of nodes that are the root nodes of subtrees where all nodes
    // in each subtree need to have their world matrices updated.
    this._worldMatrixRootNodes = []
};

/**
 * Starts an rAF loop and runs the render tasks in the _renderTasks stack.
 * As long as there are tasks in the stack, the loop continues. When the
 * stack becomes empty due to removal of tasks, the rAF stops and the app
 * sits there doing nothing -- silence, crickets.
 */
Motor.prototype._startAnimationLoop = function _startAnimationLoop () {
        var this$1 = this;

    if (this._animationLoopStarted) { return Promise.resolve() }

    this._animationLoopStarted = true

    const logic = function () {
        // DIRECT ANIMATION LOOP ///////////////////////////////////
        // So now we can render after the scene is mounted.
        const motorLoop = function (timestamp) {
            this$1._inFrame = true

            this$1._runRenderTasks(timestamp)
            this$1._renderNodes(timestamp)

            // If any tasks are left to run, continue the animation loop.
            if (this$1._allRenderTasks.length)
                { this$1._rAF = requestAnimationFrame(motorLoop) }
            else {
                this$1._rAF = null
                this$1._animationLoopStarted = false
            }

            this$1._inFrame = false
        }

        this$1._rAF = requestAnimationFrame(motorLoop)
    }

    if (!documentIsReady) {
        return documentReady().then(function () {
            documentIsReady = true
            logic()
        })
    }

    logic()
    return Promise.resolve()
};
//async _startAnimationLoop() {
    //if (this._animationLoopStarted) return

    //this._animationLoopStarted = true

    //if (!documentIsReady) {
        //await documentReady()
        //documentIsReady = true
    //}

    //// DIRECT ANIMATION LOOP ///////////////////////////////////
    //// So now we can render after the scene is mounted.
    //const motorLoop = timestamp => {
        //this._inFrame = true

        //this._runRenderTasks(timestamp)
        //this._renderNodes(timestamp)

        //// If any tasks are left to run, continue the animation loop.
        //if (this._allRenderTasks.length)
            //this._rAF = requestAnimationFrame(motorLoop)
        //else {
            //this._rAF = null
            //this._animationLoopStarted = false
        //}

        //this._inFrame = false
    //}

    //this._rAF = requestAnimationFrame(motorLoop)

    //// ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////
    ////this._rAF = true
    ////let timestamp = null
    ////while (this._rAF) {
        ////timestamp = await animationFrame()
        ////this._inFrame = true

        ////this._runRenderTasks(timestamp)
        ////this._renderNodes(timestamp)

        ////// If any tasks are left to run, continue the animation loop.
        ////if (!this._allRenderTasks.length) {
            ////this._rAF = null
            ////this._animationLoopStarted = false
        ////}

        ////this._inFrame = false
    ////}
//}

/**
 * When a render tasks is added a new rAF loop will be started if there
 * isn't one currently.
 *
 * A render task is simply a function that will be called over and over
 * again, in the Motor's animation loop. That's all, nothing special.
 * However, if a Node setter is used inside of a render task, then the Node
 * will tell Motor that it needs to be re-rendered, which will happen at
 * the end of the current frame. If a Node setter is used outside of a
 * render task (i.e. outside of the Motor's animation loop), then the Node
 * tells Motor to re-render the Node on the next animation loop tick.
 * Basically, regardless of where the Node's setters are used (inside or
 * outside of the Motor's animation loop), rendering always happens inside
 * the loop.
 *
 * @param {Function} fn The render task to add.
 * @return {Function} A reference to the render task. Useful for saving to
 * a variable so that it can later be passed to Motor.removeRenderTask().
 */
Motor.prototype.addRenderTask = function addRenderTask (fn) {
    if (typeof fn != 'function')
        { throw new Error('Render task must be a function.') }

    if (this._allRenderTasks.includes(fn)) { return }

    this._allRenderTasks.push(fn)
    this._numberOfTasks += 1

    // If the render loop isn't started, start it.
    if (!this._animationLoopStarted)
        { this._startAnimationLoop() }

    return fn
};

Motor.prototype.removeRenderTask = function removeRenderTask (fn) {
    const taskIndex = this._allRenderTasks.indexOf(fn)

    if (taskIndex == -1) { return }

    this._allRenderTasks.splice(taskIndex, 1)
    this._numberOfTasks -= 1
    this._taskIterationIndex -= 1
};

Motor.prototype._runRenderTasks = function _runRenderTasks (timestamp) {
        var this$1 = this;

    for (this._taskIterationIndex = 0; this._taskIterationIndex < this._numberOfTasks; this._taskIterationIndex += 1) {
        const task = this$1._allRenderTasks[this$1._taskIterationIndex]

        if (task(timestamp) === false)
            { this$1.removeRenderTask(task) }
    }
};

Motor.prototype._setNodeToBeRendered = function _setNodeToBeRendered (node) {
    if (this._nodesToBeRendered.includes(node)) { return }
    this._nodesToBeRendered.push(node)
    if (!this._inFrame) { this._startAnimationLoop() }
};

Motor.prototype._renderNodes = function _renderNodes (timestamp) {
        var this$1 = this;

    if (!this._nodesToBeRendered.length) { return }

    for (let i=0, l=this._nodesToBeRendered.length; i<l; i+=1) {
        const node = this$1._nodesToBeRendered[i]

        node._render(timestamp)

        // If the node is root of a subtree containing updated nodes and
        // has no ancestors that were modified, then add it to the
        // _worldMatrixRootNodes set so we can update the world matrices of
        // all the nodes in the root node's subtree.
        if (
            // a node could be a Scene, which is not Transformable
            node instanceof Transformable &&

            // and if ancestor is not instanceof Transformable, f.e.
            // `false` if there is no ancestor to be rendered, or Sizeable
            // if the Scene is returned.
            !(node._getAncestorToBeRendered() instanceof Transformable) &&

            // and the node isn't already added.
            !this$1._worldMatrixRootNodes.includes(node)
        ) {
            this$1._worldMatrixRootNodes.push(node)
        }

        // keep track of which scenes are modified so we can render webgl
        // only for those scenes.
        // TODO FIXME: at this point, a node should always have a scene,
        // otherwise it should not ever be rendered here, but turns out
        // some nodes are getting into this queue without a scene. We
        // shouldn't need the conditional check for node._scene, and it
        // will save CPU by not allowing the code to get here in that case.
        if (node._scene && !this$1._modifiedScenes.includes(node._scene))
            { this$1._modifiedScenes.push(node._scene) }
    }

    // Update world matrices of the subtrees.
    const worldMatrixRootNodes = this._worldMatrixRootNodes
    for (let i=0, l=worldMatrixRootNodes.length; i<l; i+=1) {
        const subtreeRoot = worldMatrixRootNodes[i]
        subtreeRoot._calculateWorldMatricesInSubtree()
    }
    worldMatrixRootNodes.length = 0

    // render webgl of modified scenes.
    const modifiedScenes = this._modifiedScenes
    // TODO PERFORMANCE: store a list of webgl-enabled modified scenes, and
    // iterate only through those so we don't iterate over non-webgl
    // scenes.
    for (let i=0, l=modifiedScenes.length; i<l; i+=1) {
        const sceneElement = modifiedScenes[i].element
        // TODO we're temporarily storing stuff on the .element, but we
        // don't want that, we will move it to WebGLRenderer.
        if (
            sceneElement.webglEnabled &&
            ( webGLRenderer || (webGLRenderer = getWebGlRenderer()) ) // only ever call getWebGlRenderer once
        )
            { webGLRenderer.drawScene(sceneElement) }
    }
    modifiedScenes.length = 0

    const nodesToBeRendered = this._nodesToBeRendered
    for (let i=0, l=nodesToBeRendered.length; i<l; i+=1) {
        nodesToBeRendered[i]._willBeRendered = false
    }
    nodesToBeRendered.length = 0
};

// export a singleton instance rather than the class directly.
export default new Motor

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW90b3IuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL01vdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkb2N1bWVudFJlYWR5IGZyb20gJ2F3YWl0Ym94L2RvbS9kb2N1bWVudFJlYWR5J1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnLi9UcmFuc2Zvcm1hYmxlJ1xuaW1wb3J0IGdldFdlYkdsUmVuZGVyZXIgZnJvbSAnLi9XZWJHTFJlbmRlcmVyJ1xuXG5pbXBvcnQge1xuICAgIC8vYW5pbWF0aW9uRnJhbWUsXG59IGZyb20gJy4vVXRpbGl0eSdcblxubGV0IGRvY3VtZW50SXNSZWFkeSA9IGZhbHNlXG5sZXQgd2ViR0xSZW5kZXJlciA9IG51bGxcblxuY2xhc3MgTW90b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pbkZyYW1lID0gZmFsc2UgLy8gdHJ1ZSB3aGVuIGluc2lkZSBhIHJlcXVlc3RlZCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgIHRoaXMuX3JBRiA9IG51bGwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lLCBvciBudWxsLlxuICAgICAgICB0aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCA9IGZhbHNlXG4gICAgICAgIHRoaXMuX2FsbFJlbmRlclRhc2tzID0gW11cbiAgICAgICAgdGhpcy5fdGFza0l0ZXJhdGlvbkluZGV4ID0gMFxuICAgICAgICB0aGlzLl9udW1iZXJPZlRhc2tzID0gMFxuICAgICAgICB0aGlzLl9ub2Rlc1RvQmVSZW5kZXJlZCA9IFtdXG4gICAgICAgIHRoaXMuX21vZGlmaWVkU2NlbmVzID0gW11cblxuICAgICAgICAvLyBBIHNldCBvZiBub2RlcyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlcyBvZiBzdWJ0cmVlcyB3aGVyZSBhbGwgbm9kZXNcbiAgICAgICAgLy8gaW4gZWFjaCBzdWJ0cmVlIG5lZWQgdG8gaGF2ZSB0aGVpciB3b3JsZCBtYXRyaWNlcyB1cGRhdGVkLlxuICAgICAgICB0aGlzLl93b3JsZE1hdHJpeFJvb3ROb2RlcyA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIHJBRiBsb29wIGFuZCBydW5zIHRoZSByZW5kZXIgdGFza3MgaW4gdGhlIF9yZW5kZXJUYXNrcyBzdGFjay5cbiAgICAgKiBBcyBsb25nIGFzIHRoZXJlIGFyZSB0YXNrcyBpbiB0aGUgc3RhY2ssIHRoZSBsb29wIGNvbnRpbnVlcy4gV2hlbiB0aGVcbiAgICAgKiBzdGFjayBiZWNvbWVzIGVtcHR5IGR1ZSB0byByZW1vdmFsIG9mIHRhc2tzLCB0aGUgckFGIHN0b3BzIGFuZCB0aGUgYXBwXG4gICAgICogc2l0cyB0aGVyZSBkb2luZyBub3RoaW5nIC0tIHNpbGVuY2UsIGNyaWNrZXRzLlxuICAgICAqL1xuICAgIF9zdGFydEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQgPSB0cnVlXG5cbiAgICAgICAgY29uc3QgbG9naWMgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBESVJFQ1QgQU5JTUFUSU9OIExPT1AgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFNvIG5vdyB3ZSBjYW4gcmVuZGVyIGFmdGVyIHRoZSBzY2VuZSBpcyBtb3VudGVkLlxuICAgICAgICAgICAgY29uc3QgbW90b3JMb29wID0gdGltZXN0YW1wID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkZyYW1lID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcnVuUmVuZGVyVGFza3ModGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlck5vZGVzKHRpbWVzdGFtcClcblxuICAgICAgICAgICAgICAgIC8vIElmIGFueSB0YXNrcyBhcmUgbGVmdCB0byBydW4sIGNvbnRpbnVlIHRoZSBhbmltYXRpb24gbG9vcC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWxsUmVuZGVyVGFza3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW90b3JMb29wKVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yQUYgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkxvb3BTdGFydGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbkZyYW1lID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdG9yTG9vcClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZG9jdW1lbnRJc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNSZWFkeSA9IHRydWVcbiAgICAgICAgICAgICAgICBsb2dpYygpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbG9naWMoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG4gICAgLy9hc3luYyBfc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgICAgICAvL2lmICh0aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCkgcmV0dXJuXG5cbiAgICAgICAgLy90aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCA9IHRydWVcblxuICAgICAgICAvL2lmICghZG9jdW1lbnRJc1JlYWR5KSB7XG4gICAgICAgICAgICAvL2F3YWl0IGRvY3VtZW50UmVhZHkoKVxuICAgICAgICAgICAgLy9kb2N1bWVudElzUmVhZHkgPSB0cnVlXG4gICAgICAgIC8vfVxuXG4gICAgICAgIC8vLy8gRElSRUNUIEFOSU1BVElPTiBMT09QIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vLy8gU28gbm93IHdlIGNhbiByZW5kZXIgYWZ0ZXIgdGhlIHNjZW5lIGlzIG1vdW50ZWQuXG4gICAgICAgIC8vY29uc3QgbW90b3JMb29wID0gdGltZXN0YW1wID0+IHtcbiAgICAgICAgICAgIC8vdGhpcy5faW5GcmFtZSA9IHRydWVcblxuICAgICAgICAgICAgLy90aGlzLl9ydW5SZW5kZXJUYXNrcyh0aW1lc3RhbXApXG4gICAgICAgICAgICAvL3RoaXMuX3JlbmRlck5vZGVzKHRpbWVzdGFtcClcblxuICAgICAgICAgICAgLy8vLyBJZiBhbnkgdGFza3MgYXJlIGxlZnQgdG8gcnVuLCBjb250aW51ZSB0aGUgYW5pbWF0aW9uIGxvb3AuXG4gICAgICAgICAgICAvL2lmICh0aGlzLl9hbGxSZW5kZXJUYXNrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgLy90aGlzLl9yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW90b3JMb29wKVxuICAgICAgICAgICAgLy9lbHNlIHtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX3JBRiA9IG51bGxcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2FuaW1hdGlvbkxvb3BTdGFydGVkID0gZmFsc2VcbiAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAvL3RoaXMuX2luRnJhbWUgPSBmYWxzZVxuICAgICAgICAvL31cblxuICAgICAgICAvL3RoaXMuX3JBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShtb3Rvckxvb3ApXG5cbiAgICAgICAgLy8vLyBBTklNQVRJT04gTE9PUCBVU0lORyBXSElMRSBBTkQgQVdBSVQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8vL3RoaXMuX3JBRiA9IHRydWVcbiAgICAgICAgLy8vL2xldCB0aW1lc3RhbXAgPSBudWxsXG4gICAgICAgIC8vLy93aGlsZSAodGhpcy5fckFGKSB7XG4gICAgICAgICAgICAvLy8vdGltZXN0YW1wID0gYXdhaXQgYW5pbWF0aW9uRnJhbWUoKVxuICAgICAgICAgICAgLy8vL3RoaXMuX2luRnJhbWUgPSB0cnVlXG5cbiAgICAgICAgICAgIC8vLy90aGlzLl9ydW5SZW5kZXJUYXNrcyh0aW1lc3RhbXApXG4gICAgICAgICAgICAvLy8vdGhpcy5fcmVuZGVyTm9kZXModGltZXN0YW1wKVxuXG4gICAgICAgICAgICAvLy8vLy8gSWYgYW55IHRhc2tzIGFyZSBsZWZ0IHRvIHJ1biwgY29udGludWUgdGhlIGFuaW1hdGlvbiBsb29wLlxuICAgICAgICAgICAgLy8vL2lmICghdGhpcy5fYWxsUmVuZGVyVGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8vL3RoaXMuX3JBRiA9IG51bGxcbiAgICAgICAgICAgICAgICAvLy8vdGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgLy8vL31cblxuICAgICAgICAgICAgLy8vL3RoaXMuX2luRnJhbWUgPSBmYWxzZVxuICAgICAgICAvLy8vfVxuICAgIC8vfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBhIHJlbmRlciB0YXNrcyBpcyBhZGRlZCBhIG5ldyByQUYgbG9vcCB3aWxsIGJlIHN0YXJ0ZWQgaWYgdGhlcmVcbiAgICAgKiBpc24ndCBvbmUgY3VycmVudGx5LlxuICAgICAqXG4gICAgICogQSByZW5kZXIgdGFzayBpcyBzaW1wbHkgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG92ZXIgYW5kIG92ZXJcbiAgICAgKiBhZ2FpbiwgaW4gdGhlIE1vdG9yJ3MgYW5pbWF0aW9uIGxvb3AuIFRoYXQncyBhbGwsIG5vdGhpbmcgc3BlY2lhbC5cbiAgICAgKiBIb3dldmVyLCBpZiBhIE5vZGUgc2V0dGVyIGlzIHVzZWQgaW5zaWRlIG9mIGEgcmVuZGVyIHRhc2ssIHRoZW4gdGhlIE5vZGVcbiAgICAgKiB3aWxsIHRlbGwgTW90b3IgdGhhdCBpdCBuZWVkcyB0byBiZSByZS1yZW5kZXJlZCwgd2hpY2ggd2lsbCBoYXBwZW4gYXRcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBJZiBhIE5vZGUgc2V0dGVyIGlzIHVzZWQgb3V0c2lkZSBvZiBhXG4gICAgICogcmVuZGVyIHRhc2sgKGkuZS4gb3V0c2lkZSBvZiB0aGUgTW90b3IncyBhbmltYXRpb24gbG9vcCksIHRoZW4gdGhlIE5vZGVcbiAgICAgKiB0ZWxscyBNb3RvciB0byByZS1yZW5kZXIgdGhlIE5vZGUgb24gdGhlIG5leHQgYW5pbWF0aW9uIGxvb3AgdGljay5cbiAgICAgKiBCYXNpY2FsbHksIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIE5vZGUncyBzZXR0ZXJzIGFyZSB1c2VkIChpbnNpZGUgb3JcbiAgICAgKiBvdXRzaWRlIG9mIHRoZSBNb3RvcidzIGFuaW1hdGlvbiBsb29wKSwgcmVuZGVyaW5nIGFsd2F5cyBoYXBwZW5zIGluc2lkZVxuICAgICAqIHRoZSBsb29wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHJlbmRlciB0YXNrIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlciB0YXNrLiBVc2VmdWwgZm9yIHNhdmluZyB0b1xuICAgICAqIGEgdmFyaWFibGUgc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgcGFzc2VkIHRvIE1vdG9yLnJlbW92ZVJlbmRlclRhc2soKS5cbiAgICAgKi9cbiAgICBhZGRSZW5kZXJUYXNrKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyIHRhc2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG5cbiAgICAgICAgaWYgKHRoaXMuX2FsbFJlbmRlclRhc2tzLmluY2x1ZGVzKGZuKSkgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5fYWxsUmVuZGVyVGFza3MucHVzaChmbilcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUYXNrcyArPSAxXG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlciBsb29wIGlzbid0IHN0YXJ0ZWQsIHN0YXJ0IGl0LlxuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGlvbkxvb3BTdGFydGVkKVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb25Mb29wKClcblxuICAgICAgICByZXR1cm4gZm5cbiAgICB9XG5cbiAgICByZW1vdmVSZW5kZXJUYXNrKGZuKSB7XG4gICAgICAgIGNvbnN0IHRhc2tJbmRleCA9IHRoaXMuX2FsbFJlbmRlclRhc2tzLmluZGV4T2YoZm4pXG5cbiAgICAgICAgaWYgKHRhc2tJbmRleCA9PSAtMSkgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5fYWxsUmVuZGVyVGFza3Muc3BsaWNlKHRhc2tJbmRleCwgMSlcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUYXNrcyAtPSAxXG4gICAgICAgIHRoaXMuX3Rhc2tJdGVyYXRpb25JbmRleCAtPSAxXG4gICAgfVxuXG4gICAgX3J1blJlbmRlclRhc2tzKHRpbWVzdGFtcCkge1xuICAgICAgICBmb3IgKHRoaXMuX3Rhc2tJdGVyYXRpb25JbmRleCA9IDA7IHRoaXMuX3Rhc2tJdGVyYXRpb25JbmRleCA8IHRoaXMuX251bWJlck9mVGFza3M7IHRoaXMuX3Rhc2tJdGVyYXRpb25JbmRleCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gdGhpcy5fYWxsUmVuZGVyVGFza3NbdGhpcy5fdGFza0l0ZXJhdGlvbkluZGV4XVxuXG4gICAgICAgICAgICBpZiAodGFzayh0aW1lc3RhbXApID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlbmRlclRhc2sodGFzaylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXROb2RlVG9CZVJlbmRlcmVkKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX25vZGVzVG9CZVJlbmRlcmVkLmluY2x1ZGVzKG5vZGUpKSByZXR1cm5cbiAgICAgICAgdGhpcy5fbm9kZXNUb0JlUmVuZGVyZWQucHVzaChub2RlKVxuICAgICAgICBpZiAoIXRoaXMuX2luRnJhbWUpIHRoaXMuX3N0YXJ0QW5pbWF0aW9uTG9vcCgpXG4gICAgfVxuXG4gICAgX3JlbmRlck5vZGVzKHRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMuX25vZGVzVG9CZVJlbmRlcmVkLmxlbmd0aCkgcmV0dXJuXG5cbiAgICAgICAgZm9yIChsZXQgaT0wLCBsPXRoaXMuX25vZGVzVG9CZVJlbmRlcmVkLmxlbmd0aDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNUb0JlUmVuZGVyZWRbaV1cblxuICAgICAgICAgICAgbm9kZS5fcmVuZGVyKHRpbWVzdGFtcClcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgcm9vdCBvZiBhIHN1YnRyZWUgY29udGFpbmluZyB1cGRhdGVkIG5vZGVzIGFuZFxuICAgICAgICAgICAgLy8gaGFzIG5vIGFuY2VzdG9ycyB0aGF0IHdlcmUgbW9kaWZpZWQsIHRoZW4gYWRkIGl0IHRvIHRoZVxuICAgICAgICAgICAgLy8gX3dvcmxkTWF0cml4Um9vdE5vZGVzIHNldCBzbyB3ZSBjYW4gdXBkYXRlIHRoZSB3b3JsZCBtYXRyaWNlcyBvZlxuICAgICAgICAgICAgLy8gYWxsIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBub2RlJ3Mgc3VidHJlZS5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBhIG5vZGUgY291bGQgYmUgYSBTY2VuZSwgd2hpY2ggaXMgbm90IFRyYW5zZm9ybWFibGVcbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgVHJhbnNmb3JtYWJsZSAmJlxuXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlmIGFuY2VzdG9yIGlzIG5vdCBpbnN0YW5jZW9mIFRyYW5zZm9ybWFibGUsIGYuZS5cbiAgICAgICAgICAgICAgICAvLyBgZmFsc2VgIGlmIHRoZXJlIGlzIG5vIGFuY2VzdG9yIHRvIGJlIHJlbmRlcmVkLCBvciBTaXplYWJsZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBTY2VuZSBpcyByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICAhKG5vZGUuX2dldEFuY2VzdG9yVG9CZVJlbmRlcmVkKCkgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hYmxlKSAmJlxuXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBub2RlIGlzbid0IGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgICAgICAgIXRoaXMuX3dvcmxkTWF0cml4Um9vdE5vZGVzLmluY2x1ZGVzKG5vZGUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeFJvb3ROb2Rlcy5wdXNoKG5vZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hpY2ggc2NlbmVzIGFyZSBtb2RpZmllZCBzbyB3ZSBjYW4gcmVuZGVyIHdlYmdsXG4gICAgICAgICAgICAvLyBvbmx5IGZvciB0aG9zZSBzY2VuZXMuXG4gICAgICAgICAgICAvLyBUT0RPIEZJWE1FOiBhdCB0aGlzIHBvaW50LCBhIG5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgc2NlbmUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHJlbmRlcmVkIGhlcmUsIGJ1dCB0dXJucyBvdXRcbiAgICAgICAgICAgIC8vIHNvbWUgbm9kZXMgYXJlIGdldHRpbmcgaW50byB0aGlzIHF1ZXVlIHdpdGhvdXQgYSBzY2VuZS4gV2VcbiAgICAgICAgICAgIC8vIHNob3VsZG4ndCBuZWVkIHRoZSBjb25kaXRpb25hbCBjaGVjayBmb3Igbm9kZS5fc2NlbmUsIGFuZCBpdFxuICAgICAgICAgICAgLy8gd2lsbCBzYXZlIENQVSBieSBub3QgYWxsb3dpbmcgdGhlIGNvZGUgdG8gZ2V0IGhlcmUgaW4gdGhhdCBjYXNlLlxuICAgICAgICAgICAgaWYgKG5vZGUuX3NjZW5lICYmICF0aGlzLl9tb2RpZmllZFNjZW5lcy5pbmNsdWRlcyhub2RlLl9zY2VuZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kaWZpZWRTY2VuZXMucHVzaChub2RlLl9zY2VuZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB3b3JsZCBtYXRyaWNlcyBvZiB0aGUgc3VidHJlZXMuXG4gICAgICAgIGNvbnN0IHdvcmxkTWF0cml4Um9vdE5vZGVzID0gdGhpcy5fd29ybGRNYXRyaXhSb290Tm9kZXNcbiAgICAgICAgZm9yIChsZXQgaT0wLCBsPXdvcmxkTWF0cml4Um9vdE5vZGVzLmxlbmd0aDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlUm9vdCA9IHdvcmxkTWF0cml4Um9vdE5vZGVzW2ldXG4gICAgICAgICAgICBzdWJ0cmVlUm9vdC5fY2FsY3VsYXRlV29ybGRNYXRyaWNlc0luU3VidHJlZSgpXG4gICAgICAgIH1cbiAgICAgICAgd29ybGRNYXRyaXhSb290Tm9kZXMubGVuZ3RoID0gMFxuXG4gICAgICAgIC8vIHJlbmRlciB3ZWJnbCBvZiBtb2RpZmllZCBzY2VuZXMuXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2NlbmVzID0gdGhpcy5fbW9kaWZpZWRTY2VuZXNcbiAgICAgICAgLy8gVE9ETyBQRVJGT1JNQU5DRTogc3RvcmUgYSBsaXN0IG9mIHdlYmdsLWVuYWJsZWQgbW9kaWZpZWQgc2NlbmVzLCBhbmRcbiAgICAgICAgLy8gaXRlcmF0ZSBvbmx5IHRocm91Z2ggdGhvc2Ugc28gd2UgZG9uJ3QgaXRlcmF0ZSBvdmVyIG5vbi13ZWJnbFxuICAgICAgICAvLyBzY2VuZXMuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1tb2RpZmllZFNjZW5lcy5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgY29uc3Qgc2NlbmVFbGVtZW50ID0gbW9kaWZpZWRTY2VuZXNbaV0uZWxlbWVudFxuICAgICAgICAgICAgLy8gVE9ETyB3ZSdyZSB0ZW1wb3JhcmlseSBzdG9yaW5nIHN0dWZmIG9uIHRoZSAuZWxlbWVudCwgYnV0IHdlXG4gICAgICAgICAgICAvLyBkb24ndCB3YW50IHRoYXQsIHdlIHdpbGwgbW92ZSBpdCB0byBXZWJHTFJlbmRlcmVyLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNjZW5lRWxlbWVudC53ZWJnbEVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAoIHdlYkdMUmVuZGVyZXIgfHwgKHdlYkdMUmVuZGVyZXIgPSBnZXRXZWJHbFJlbmRlcmVyKCkpICkgLy8gb25seSBldmVyIGNhbGwgZ2V0V2ViR2xSZW5kZXJlciBvbmNlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgd2ViR0xSZW5kZXJlci5kcmF3U2NlbmUoc2NlbmVFbGVtZW50KVxuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkU2NlbmVzLmxlbmd0aCA9IDBcblxuICAgICAgICBjb25zdCBub2Rlc1RvQmVSZW5kZXJlZCA9IHRoaXMuX25vZGVzVG9CZVJlbmRlcmVkXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1ub2Rlc1RvQmVSZW5kZXJlZC5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgbm9kZXNUb0JlUmVuZGVyZWRbaV0uX3dpbGxCZVJlbmRlcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBub2Rlc1RvQmVSZW5kZXJlZC5sZW5ndGggPSAwXG4gICAgfVxufVxuXG4vLyBleHBvcnQgYSBzaW5nbGV0b24gaW5zdGFuY2UgcmF0aGVyIHRoYW4gdGhlIGNsYXNzIGRpcmVjdGx5LlxuZXhwb3J0IGRlZmF1bHQgbmV3IE1vdG9yXG4iXSwibmFtZXMiOlsidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxhQUFhLE1BQU0sNEJBQTRCO0FBQ3RELE9BQU8sYUFBYSxNQUFNLGlCQUFpQjtBQUMzQyxPQUFPLGdCQUFnQixNQUFN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