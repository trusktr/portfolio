import 'geometry-interfaces'
import Transformable from './Transformable'
import ImperativeBase, {initImperativeBase} from './ImperativeBase'
import MotorHTMLNode from '../html/node'
import Scene from './Scene'

initImperativeBase()

var Node = (function (superclass) {
    function Node (options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

        superclass.call(this, options)

        // This was when using my `multiple()` implementation, we could call
        // specific constructors using specific arguments. But, we're using
        // class-factory style mixins for now, so we don't have control over the
        // specific arguments we can pass to the constructors, so we're just
        // using a single `options` parameter in all the constructors.
        //this.callSuperConstructor(Transformable, options)
        //this.callSuperConstructor(TreeNode)
        //this.callSuperConstructor(ImperativeBase)

        this._scene = null // stores a ref to this Node's root Scene.

        // This is an internal promise that resolves when this Node is added to
        // to a scene graph that has a root Scene TreeNode. The resolved value
        // is the root Scene.
        this._scenePromise = null
        this._resolveScenePromise = null

        /**
         * @private
         * This method is defined here in the consructor as an arrow function
         * because parent Nodes pass it to Observable#on and Observable#off. If
         * it were a prototype method, then it would need to be bound when
         * passed to Observable#on, which would require keeping track of the
         * bound function reference in order to be able to pass it to
         * Observable#off later. See ImperativeBase#addChild and
         * ImperativeBase#removeChild.
         */
        this._onParentSizeChange = function () {

            // We only need to recalculate sizing and matrices if this node has
            // properties that depend on parent sizing (proportional size,
            // align, and mountPoint). mountPoint isn't obvious: if this node
            // is proportionally sized, then the mountPoint will depend on the
            // size of this element which depends on the size of this element's
            // parent.
            if (
                this$1._properties.sizeMode.x === "proportional"
                || this$1._properties.sizeMode.y === "proportional"
                || this$1._properties.sizeMode.z === "proportional"

                || this$1._properties.align.x !== 0
                || this$1._properties.align.y !== 0
                || this$1._properties.align.z !== 0
            ) {
                this$1._calcSize()
                this$1._needsToBeRendered()
            }
        }

        this._calcSize()
        this._needsToBeRendered()
    }

    if ( superclass ) Node.__proto__ = superclass;
    Node.prototype = Object.create( superclass && superclass.prototype );
    Node.prototype.constructor = Node;

    var prototypeAccessors = { scene: {} };

    /**
     * @private
     */
    Node.prototype._waitForMountThenResolveMountPromise = function _waitForMountThenResolveMountPromise () {
        var this$1 = this;

        if (this._awaitingScenePromise) { return Promise.resolve() }

        const logic = function () {
            this$1._mounted = true
            this$1._resolveMountPromise()
            this$1._elementManager.shouldRender()
        }

        this._awaitingScenePromise = true

        let possibleError = undefined

        // try
        return this._getScenePromise()
        .then(function () { return this$1._scene.mountPromise; })

        .then(logic)

        // catch
        .catch(function () {
            if (e == 'mountcancel') { return }
            else { possibleError = e }
        })

        // finally
        .then(function () {
            this$1._awaitingScenePromise = false

            if (possibleError) { throw possibleError }
        })
    };
    //async _waitForMountThenResolveMountPromise() {
        //if (this._awaitingScenePromise) return
        //try {
            //this._awaitingScenePromise = true
            //await this._getScenePromise()
            //await this._scene.mountPromise
        //} catch (e) {
            //if (e == 'mountcancel') return
            //else throw e
        //} finally {
            //this._awaitingScenePromise = false
        //}

        //this._mounted = true
        //this._resolveMountPromise()
        //this._elementManager.shouldRender()
    //}

    /**
     * @override
     */
    Node.prototype._makeElement = function _makeElement () {
        return new MotorHTMLNode
    };

    /**
     * @private
     * Get a promise for the node's eventual scene.
     */
    Node.prototype._getScenePromise = function _getScenePromise () {
        var this$1 = this;

        if (!this._scenePromise) {
            this._scenePromise = new Promise(function (a, b) {
                this$1._resolveScenePromise = a
            })
        }

        if (this._scene)
            { this._resolveScenePromise() }

        return this._scenePromise
    };

    /**
     * Get the Scene that this Node is in, null if no Scene. This is recursive
     * at first, then cached.
     *
     * This traverses up the scene graph tree starting at this Node and finds
     * the root Scene, if any. It caches the value for performance. If this
     * Node is removed from a parent node with parent.removeChild(), then the
     * cache is invalidated so the traversal can happen again when this Node is
     * eventually added to a new tree. This way, if the scene is cached on a
     * parent Node that we're adding this Node to then we can get that cached
     * value instead of traversing the tree.
     *
     * @readonly
     */
    prototypeAccessors.scene.get = function () {
        // NOTE: this._scene is initally null, created in the constructor.

        // if already cached, return it. Or if no parent, return it (it'll be null).
        if (this._scene || !this._parent) { return this._scene }

        // if the parent node already has a ref to the scene, use that.
        if (this._parent._scene) {
            this._scene = this._parent._scene
        }
        else if (this._parent instanceof Scene) {
            this._scene = this._parent
        }
        // otherwise call the scene getter on the parent, which triggers
        // traversal up the scene graph in order to find the root scene (null
        // if none).
        else {
            this._scene = this._parent.scene
        }

        return this._scene
    };

    /**
     * @private
     * This method to be called only when this Node has this.scene.
     * Resolves the _scenePromise for all children of the tree of this Node.
     */
    Node.prototype._giveSceneRefToChildren = function _giveSceneRefToChildren () {
        var this$1 = this;

        const children = this._children;
        for (let i=0, l=children.length; i<l; i+=1) {
            const childNode = children[i]
            childNode._scene = this$1._scene
            if (childNode._resolveScenePromise)
                { childNode._resolveScenePromise(childNode._scene) }
            childNode._giveSceneRefToChildren();
        }
    };

    Node.prototype._resetSceneRef = function _resetSceneRef () {
        this._scene = null
        this._scenePromise = null
        this._resolveScenePromise = null
        const children = this._children;
        for (let i=0, l=children.length; i<l; i+=1) {
            children[i]._resetSceneRef();
        }
    };

    Object.defineProperties( Node.prototype, prototypeAccessors );

    return Node;
}(ImperativeBase.mixin(Transformable)));

export {Node as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2dlb21ldHJ5LWludGVyZmFjZXMnXG5pbXBvcnQgVHJhbnNmb3JtYWJsZSBmcm9tICcuL1RyYW5zZm9ybWFibGUnXG5pbXBvcnQgSW1wZXJhdGl2ZUJhc2UsIHtpbml0SW1wZXJhdGl2ZUJhc2V9IGZyb20gJy4vSW1wZXJhdGl2ZUJhc2UnXG5pbXBvcnQgTW90b3JIVE1MTm9kZSBmcm9tICcuLi9odG1sL25vZGUnXG5pbXBvcnQgU2NlbmUgZnJvbSAnLi9TY2VuZSdcblxuaW5pdEltcGVyYXRpdmVCYXNlKClcblxuY2xhc3MgTm9kZSBleHRlbmRzIEltcGVyYXRpdmVCYXNlLm1peGluKFRyYW5zZm9ybWFibGUpIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgSW5pdGlhbCBwcm9wZXJ0aWVzIHRoYXQgdGhlIG5vZGUgd2lsbFxuICAgICAqIGhhdmUuIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5vZGUsIGFsdGVybmF0aXZlbHkgdG8gdXNpbmcgdGhlXG4gICAgICogc2V0dGVycy9nZXR0ZXJzIGZvciBwb3NpdGlvbiwgcm90YXRpb24sIGV0Yy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7XG4gICAgICogICBhYnNvbHV0ZVNpemU6IHt4OjEwMCwgeToxMDAsIHo6MTAwfSxcbiAgICAgKiAgIHJvdGF0aW9uOiB7eDozMCwgeToyMCwgejoyNX1cbiAgICAgKiB9KVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucylcblxuICAgICAgICAvLyBUaGlzIHdhcyB3aGVuIHVzaW5nIG15IGBtdWx0aXBsZSgpYCBpbXBsZW1lbnRhdGlvbiwgd2UgY291bGQgY2FsbFxuICAgICAgICAvLyBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMgdXNpbmcgc3BlY2lmaWMgYXJndW1lbnRzLiBCdXQsIHdlJ3JlIHVzaW5nXG4gICAgICAgIC8vIGNsYXNzLWZhY3Rvcnkgc3R5bGUgbWl4aW5zIGZvciBub3csIHNvIHdlIGRvbid0IGhhdmUgY29udHJvbCBvdmVyIHRoZVxuICAgICAgICAvLyBzcGVjaWZpYyBhcmd1bWVudHMgd2UgY2FuIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9ycywgc28gd2UncmUganVzdFxuICAgICAgICAvLyB1c2luZyBhIHNpbmdsZSBgb3B0aW9uc2AgcGFyYW1ldGVyIGluIGFsbCB0aGUgY29uc3RydWN0b3JzLlxuICAgICAgICAvL3RoaXMuY2FsbFN1cGVyQ29uc3RydWN0b3IoVHJhbnNmb3JtYWJsZSwgb3B0aW9ucylcbiAgICAgICAgLy90aGlzLmNhbGxTdXBlckNvbnN0cnVjdG9yKFRyZWVOb2RlKVxuICAgICAgICAvL3RoaXMuY2FsbFN1cGVyQ29uc3RydWN0b3IoSW1wZXJhdGl2ZUJhc2UpXG5cbiAgICAgICAgdGhpcy5fc2NlbmUgPSBudWxsIC8vIHN0b3JlcyBhIHJlZiB0byB0aGlzIE5vZGUncyByb290IFNjZW5lLlxuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJuYWwgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhpcyBOb2RlIGlzIGFkZGVkIHRvXG4gICAgICAgIC8vIHRvIGEgc2NlbmUgZ3JhcGggdGhhdCBoYXMgYSByb290IFNjZW5lIFRyZWVOb2RlLiBUaGUgcmVzb2x2ZWQgdmFsdWVcbiAgICAgICAgLy8gaXMgdGhlIHJvb3QgU2NlbmUuXG4gICAgICAgIHRoaXMuX3NjZW5lUHJvbWlzZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVNjZW5lUHJvbWlzZSA9IG51bGxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgZGVmaW5lZCBoZXJlIGluIHRoZSBjb25zcnVjdG9yIGFzIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAgICAqIGJlY2F1c2UgcGFyZW50IE5vZGVzIHBhc3MgaXQgdG8gT2JzZXJ2YWJsZSNvbiBhbmQgT2JzZXJ2YWJsZSNvZmYuIElmXG4gICAgICAgICAqIGl0IHdlcmUgYSBwcm90b3R5cGUgbWV0aG9kLCB0aGVuIGl0IHdvdWxkIG5lZWQgdG8gYmUgYm91bmQgd2hlblxuICAgICAgICAgKiBwYXNzZWQgdG8gT2JzZXJ2YWJsZSNvbiwgd2hpY2ggd291bGQgcmVxdWlyZSBrZWVwaW5nIHRyYWNrIG9mIHRoZVxuICAgICAgICAgKiBib3VuZCBmdW5jdGlvbiByZWZlcmVuY2UgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBwYXNzIGl0IHRvXG4gICAgICAgICAqIE9ic2VydmFibGUjb2ZmIGxhdGVyLiBTZWUgSW1wZXJhdGl2ZUJhc2UjYWRkQ2hpbGQgYW5kXG4gICAgICAgICAqIEltcGVyYXRpdmVCYXNlI3JlbW92ZUNoaWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25QYXJlbnRTaXplQ2hhbmdlID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcmVjYWxjdWxhdGUgc2l6aW5nIGFuZCBtYXRyaWNlcyBpZiB0aGlzIG5vZGUgaGFzXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgZGVwZW5kIG9uIHBhcmVudCBzaXppbmcgKHByb3BvcnRpb25hbCBzaXplLFxuICAgICAgICAgICAgLy8gYWxpZ24sIGFuZCBtb3VudFBvaW50KS4gbW91bnRQb2ludCBpc24ndCBvYnZpb3VzOiBpZiB0aGlzIG5vZGVcbiAgICAgICAgICAgIC8vIGlzIHByb3BvcnRpb25hbGx5IHNpemVkLCB0aGVuIHRoZSBtb3VudFBvaW50IHdpbGwgZGVwZW5kIG9uIHRoZVxuICAgICAgICAgICAgLy8gc2l6ZSBvZiB0aGlzIGVsZW1lbnQgd2hpY2ggZGVwZW5kcyBvbiB0aGUgc2l6ZSBvZiB0aGlzIGVsZW1lbnQnc1xuICAgICAgICAgICAgLy8gcGFyZW50LlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGUueCA9PT0gXCJwcm9wb3J0aW9uYWxcIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGUueSA9PT0gXCJwcm9wb3J0aW9uYWxcIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGUueiA9PT0gXCJwcm9wb3J0aW9uYWxcIlxuXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5hbGlnbi54ICE9PSAwXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5hbGlnbi55ICE9PSAwXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5hbGlnbi56ICE9PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNUb0JlUmVuZGVyZWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsY1NpemUoKVxuICAgICAgICB0aGlzLl9uZWVkc1RvQmVSZW5kZXJlZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd2FpdEZvck1vdW50VGhlblJlc29sdmVNb3VudFByb21pc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hd2FpdGluZ1NjZW5lUHJvbWlzZSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgY29uc3QgbG9naWMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tb3VudGVkID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZU1vdW50UHJvbWlzZSgpXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGRSZW5kZXIoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXdhaXRpbmdTY2VuZVByb21pc2UgPSB0cnVlXG5cbiAgICAgICAgbGV0IHBvc3NpYmxlRXJyb3IgPSB1bmRlZmluZWRcblxuICAgICAgICAvLyB0cnlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNjZW5lUHJvbWlzZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMuX3NjZW5lLm1vdW50UHJvbWlzZSlcblxuICAgICAgICAudGhlbihsb2dpYylcblxuICAgICAgICAvLyBjYXRjaFxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gJ21vdW50Y2FuY2VsJykgcmV0dXJuXG4gICAgICAgICAgICBlbHNlIHBvc3NpYmxlRXJyb3IgPSBlXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gZmluYWxseVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdGluZ1NjZW5lUHJvbWlzZSA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUVycm9yKSB0aHJvdyBwb3NzaWJsZUVycm9yXG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8vYXN5bmMgX3dhaXRGb3JNb3VudFRoZW5SZXNvbHZlTW91bnRQcm9taXNlKCkge1xuICAgICAgICAvL2lmICh0aGlzLl9hd2FpdGluZ1NjZW5lUHJvbWlzZSkgcmV0dXJuXG4gICAgICAgIC8vdHJ5IHtcbiAgICAgICAgICAgIC8vdGhpcy5fYXdhaXRpbmdTY2VuZVByb21pc2UgPSB0cnVlXG4gICAgICAgICAgICAvL2F3YWl0IHRoaXMuX2dldFNjZW5lUHJvbWlzZSgpXG4gICAgICAgICAgICAvL2F3YWl0IHRoaXMuX3NjZW5lLm1vdW50UHJvbWlzZVxuICAgICAgICAvL30gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaWYgKGUgPT0gJ21vdW50Y2FuY2VsJykgcmV0dXJuXG4gICAgICAgICAgICAvL2Vsc2UgdGhyb3cgZVxuICAgICAgICAvL30gZmluYWxseSB7XG4gICAgICAgICAgICAvL3RoaXMuX2F3YWl0aW5nU2NlbmVQcm9taXNlID0gZmFsc2VcbiAgICAgICAgLy99XG5cbiAgICAgICAgLy90aGlzLl9tb3VudGVkID0gdHJ1ZVxuICAgICAgICAvL3RoaXMuX3Jlc29sdmVNb3VudFByb21pc2UoKVxuICAgICAgICAvL3RoaXMuX2VsZW1lbnRNYW5hZ2VyLnNob3VsZFJlbmRlcigpXG4gICAgLy99XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW90b3JIVE1MTm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogR2V0IGEgcHJvbWlzZSBmb3IgdGhlIG5vZGUncyBldmVudHVhbCBzY2VuZS5cbiAgICAgKi9cbiAgICBfZ2V0U2NlbmVQcm9taXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NjZW5lUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NlbmVQcm9taXNlID0gbmV3IFByb21pc2UoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlU2NlbmVQcm9taXNlID0gYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSlcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVTY2VuZVByb21pc2UoKVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2VuZVByb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFNjZW5lIHRoYXQgdGhpcyBOb2RlIGlzIGluLCBudWxsIGlmIG5vIFNjZW5lLiBUaGlzIGlzIHJlY3Vyc2l2ZVxuICAgICAqIGF0IGZpcnN0LCB0aGVuIGNhY2hlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgdHJhdmVyc2VzIHVwIHRoZSBzY2VuZSBncmFwaCB0cmVlIHN0YXJ0aW5nIGF0IHRoaXMgTm9kZSBhbmQgZmluZHNcbiAgICAgKiB0aGUgcm9vdCBTY2VuZSwgaWYgYW55LiBJdCBjYWNoZXMgdGhlIHZhbHVlIGZvciBwZXJmb3JtYW5jZS4gSWYgdGhpc1xuICAgICAqIE5vZGUgaXMgcmVtb3ZlZCBmcm9tIGEgcGFyZW50IG5vZGUgd2l0aCBwYXJlbnQucmVtb3ZlQ2hpbGQoKSwgdGhlbiB0aGVcbiAgICAgKiBjYWNoZSBpcyBpbnZhbGlkYXRlZCBzbyB0aGUgdHJhdmVyc2FsIGNhbiBoYXBwZW4gYWdhaW4gd2hlbiB0aGlzIE5vZGUgaXNcbiAgICAgKiBldmVudHVhbGx5IGFkZGVkIHRvIGEgbmV3IHRyZWUuIFRoaXMgd2F5LCBpZiB0aGUgc2NlbmUgaXMgY2FjaGVkIG9uIGFcbiAgICAgKiBwYXJlbnQgTm9kZSB0aGF0IHdlJ3JlIGFkZGluZyB0aGlzIE5vZGUgdG8gdGhlbiB3ZSBjYW4gZ2V0IHRoYXQgY2FjaGVkXG4gICAgICogdmFsdWUgaW5zdGVhZCBvZiB0cmF2ZXJzaW5nIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHNjZW5lKCkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzLl9zY2VuZSBpcyBpbml0YWxseSBudWxsLCBjcmVhdGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICAvLyBpZiBhbHJlYWR5IGNhY2hlZCwgcmV0dXJuIGl0LiBPciBpZiBubyBwYXJlbnQsIHJldHVybiBpdCAoaXQnbGwgYmUgbnVsbCkuXG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSB8fCAhdGhpcy5fcGFyZW50KSByZXR1cm4gdGhpcy5fc2NlbmVcblxuICAgICAgICAvLyBpZiB0aGUgcGFyZW50IG5vZGUgYWxyZWFkeSBoYXMgYSByZWYgdG8gdGhlIHNjZW5lLCB1c2UgdGhhdC5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5fc2NlbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lID0gdGhpcy5fcGFyZW50Ll9zY2VuZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIFNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZSA9IHRoaXMuX3BhcmVudFxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxsIHRoZSBzY2VuZSBnZXR0ZXIgb24gdGhlIHBhcmVudCwgd2hpY2ggdHJpZ2dlcnNcbiAgICAgICAgLy8gdHJhdmVyc2FsIHVwIHRoZSBzY2VuZSBncmFwaCBpbiBvcmRlciB0byBmaW5kIHRoZSByb290IHNjZW5lIChudWxsXG4gICAgICAgIC8vIGlmIG5vbmUpLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lID0gdGhpcy5fcGFyZW50LnNjZW5lXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRoaXMgbWV0aG9kIHRvIGJlIGNhbGxlZCBvbmx5IHdoZW4gdGhpcyBOb2RlIGhhcyB0aGlzLnNjZW5lLlxuICAgICAqIFJlc29sdmVzIHRoZSBfc2NlbmVQcm9taXNlIGZvciBhbGwgY2hpbGRyZW4gb2YgdGhlIHRyZWUgb2YgdGhpcyBOb2RlLlxuICAgICAqL1xuICAgIF9naXZlU2NlbmVSZWZUb0NoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICBjaGlsZE5vZGUuX3NjZW5lID0gdGhpcy5fc2NlbmVcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuX3Jlc29sdmVTY2VuZVByb21pc2UpXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9yZXNvbHZlU2NlbmVQcm9taXNlKGNoaWxkTm9kZS5fc2NlbmUpXG4gICAgICAgICAgICBjaGlsZE5vZGUuX2dpdmVTY2VuZVJlZlRvQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNldFNjZW5lUmVmKCkge1xuICAgICAgICB0aGlzLl9zY2VuZSA9IG51bGxcbiAgICAgICAgdGhpcy5fc2NlbmVQcm9taXNlID0gbnVsbFxuICAgICAgICB0aGlzLl9yZXNvbHZlU2NlbmVQcm9taXNlID0gbnVsbFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9yZXNldFNjZW5lUmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7Tm9kZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbInN1cGVyIiwidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxxQkFBcUI7QUFDNUIsT0FBTyxhQUFhLE1BQU0saUJBQWlCO0FBQzNDLE9BQU8sY0FBYyxHQUFHLGtCQUFrQixPQUFPLGtCQUFrQjtBQUNuRSxPQUFPLGFBQWEsTUFBTSxjQUFjO0FBQ3hDLE9BQU8sS0FBSyxNQUFNLFNBQVM7O0FBRTNCLGtCQUFrQixFQUFFOztBQUVwQixJQUFNLElBQUksR0FBNEM7SUFBQyxBQWVuRCxhQUFXLENBQUMsQ0FBQyxPQUFZLEVBQUUsQ0FBQzswQkFBUjt5Q0FBQSxHQUFHLEVBQUU7QUFBRztRQUN4QkEsVUFBSyxLQUFBLENBQUMsTUFBQSxPQUFPLENBQUM7Ozs7Ozs7Ozs7O1FBV2QsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJOzs7OztRQUtsQixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUk7UUFDekIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUk7Ozs7Ozs7Ozs7OztRQVloQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsU0FBQSxHQUFHLEFBQUc7Ozs7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