/*
 * LICENSE
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 */

import jss from './lib/jss';

import Surface from 'famous/src/core/Surface';
import Transitionable from 'famous/src/transitions/Transitionable';
import Easing from 'famous/src/transitions/Easing';
import TouchSync from 'famous/src/inputs/TouchSync';
import GenericSync from 'famous/src/inputs/GenericSync';

import Plane from './Plane';
import Molecule from './Molecule';
import {simpleExtend} from './utils'

import callAfter from 'army-knife/callAfter';

/**
 * A scenegraph with two Molecule leafnodes: the menu area and the content
 * area. The menu area is hidden beyond the edge of the screen while the
 * content area is visible. Swiping in from the edge of the screen reveals the
 * menu, putting the content area out of focus. A mouse can also be used, and
 * hovering near the edge of the screen also reveals the menu.
 *
 * Note: This layout is mostly useful if it exists at the root of a context so
 * that the menu is clipped when it is closed (off to the side), otherwise the
 * menu will be visible beyond the boundary of the container that contains the
 * PushMenuLayout.
 *
 * Note: If you've called `openMenu` or `closeMenu` with a callback, the callback
 * will be canceled if a drag or hover on the menu happens before the animation
 * has completed. Please open an issue on GitHub if you have any opinion
 * against this. :) Maybe we can add a boolean option for this behavior.
 *
 * TODO: Embed working example here.
 *
 * @class PushMenuLayout
 * @extends Molecule
 */
export class PushMenuLayout extends Molecule {

    /**
     * Creates a new PushMenuLayout.
     *
     * @constructor
     * @param {Object} options The options to instantiate a `PushMenuLayout` with.
     *
     * TODO v0.1.0: Handle `PushMenuLayout`-specific user options. Currently they
     * just get passed into super() for the Molecule constructor to handle.
     */
    constructor(initialOptions) {
        super(initialOptions);

        // Add default values for this PushMenuLayout
        // TODO: Make default options static for the class.
        simpleExtend(this._.defaultOptions, {
            menuSide: 'left', // left or right
            menuWidth: 200,
            menuHintSize: 10, // the amount of the menu that is visible before opening the menu.
            pushAreaWidth: 40, // the area on the screen edge that the user can touch and drag to push out the menu.
            animationDuration: 1000,
            animationType: 'foldDown', // options: foldDown moveBack

            // TODO: Background color for the whole layout should be the color that the fade fades to.
            // TODO: Replace fade star/end colors with a fog color value and intensity.
            fade: true, // when content recedes, it fades into the fog.
            fadeStartColor: 'rgba(255,255,255,0)',
            fadeEndColor: 'rgba(255,255,255,1)',

            blur: false, // XXX: WIP, so false by default.
            blurRadius: 5
        })

        // TODO: performance hit, this setter is invoked in the Molecule constructor, then here again.
        this.options = initialOptions

        // TODO v0.1.0: Mark these as private.
            // TODO v0.1.0: this.contentWidth should be the width of whatever is containing
            // the layout, but we're just using it as a whole-page app for now. Get
            // size from a commit? UPDATE: See the new famous/src/views/SizeAwareView
            this.contentWidth = document.body.clientWidth - this.options.menuHintSize;

            // Changing these values outside of an instance of PushMenuLayout might
            // cause the layout to break. They are designed to be modified
            // internally only.
            this.isOpen = false;
            this.isOpening = false;
            this.isClosing = false;
            this.isAnimating = false; // keep track of whether the menu is opening or closing.
            this.isBeingDragged = false; // whether the user is dragging/pushing the menu or not.
            this.transitionCallback = undefined; // holds the callback to the current open or close menu animation.

        // Set the touch sync for pulling/pushing the menu open/closed.
        GenericSync.register({
            touch: TouchSync
        });

        this._createComponents();
        this._initializeEvents();
    }

    /**
     * See Molecule.setOptions
     *
     * @override
     */
    setOptions(newOptions) {
        super.setOptions(newOptions)
    }

    /**
     * See Molecule.resetOptions
     *
     * @override
     */
    resetOptions() {
        super.resetOptions()
    }

    /**
     * Creates the menu area, content area, `Plane` for the fade effect, etc.
     *
     * @private
     */
    _createComponents() {
        var layout = this;

        this.touchSync = new GenericSync(['touch']);

        this.alignment = (this.options.menuSide == "left"? 0: 1);
        this.animationTransition = new Transitionable(0);

        this.mainMol = new Molecule();

        this.menuMol = new Molecule({
            size: [this.options.menuWidth,undefined]
        });
        this.menuMol.oldTransform = this.menuMol.transform;
        this.menuMol.transform = function() { // override
            var currentPosition = layout.animationTransition.get();
            switch(layout.options.animationType) {
                case "foldDown":
                    // XXX: this is depending on my modifications for TransitionableTransform.
                    this.oldTransform.setTranslateX(
                        layout.options.menuSide == 'left'?
                            currentPosition *  (layout.options.menuWidth-layout.options.menuHintSize)/*range*/ - (layout.options.menuWidth-layout.options.menuHintSize)/*offset*/:
                            currentPosition * -(layout.options.menuWidth-layout.options.menuHintSize)/*range*/ + (layout.options.menuWidth-layout.options.menuHintSize)/*offset*/
                    );
                    break;
                case "moveBack":
                    // XXX: this is depending on my modifications for TransitionableTransform.
                    this.oldTransform.setTranslateX(
                        layout.options.menuSide == 'left'?
                            currentPosition *  (layout.options.menuWidth-layout.options.menuHintSize)/*range*/ - (layout.options.menuWidth-layout.options.menuHintSize)/*offset*/:
                            currentPosition * -(layout.options.menuWidth-layout.options.menuHintSize)/*range*/ + (layout.options.menuWidth-layout.options.menuHintSize)/*offset*/
                    );
                    break;
            }
            return this.oldTransform.get();
        }.bind(this.menuMol);

        // contains the user's menu content.
        this.menuContentMol = new Molecule();

        this.contentMol = new Molecule({
            size: [this.contentWidth,undefined]
        });
        this.contentMol.oldTransform = this.contentMol.transform;
        this.contentMol.transform = function() { // override
            var currentPosition = layout.animationTransition.get();
            switch(layout.options.animationType) {
                case "foldDown":
                    // XXX: this is depending on my modifications for TransitionableTransform.
                    this.oldTransform.setTranslateX(
                        layout.options.menuSide == 'left'?
                            currentPosition *  (layout.options.menuWidth - layout.options.menuHintSize)/*range*/ + layout.options.menuHintSize/*offset*/:
                            currentPosition * -(layout.options.menuWidth - layout.options.menuHintSize)/*range*/ - layout.options.menuHintSize/*offset*/
                    );
                    // XXX: this is depending on my modifications for TransitionableTransform.
                    this.oldTransform.setRotateY(
                        layout.options.menuSide == 'left'?
                            currentPosition *  Math.PI/8:
                            currentPosition * -Math.PI/8
                    );
                    break;
                case "moveBack":
                    var depth = 100;
                    // XXX: this is depending on my modifications for TransitionableTransform.
                    this.oldTransform.setTranslateX(
                        layout.options.menuSide == 'left'?
                            layout.options.menuHintSize:
                            -layout.options.menuHintSize
                    );
                    this.oldTransform.setTranslateZ(
                        currentPosition * -depth
                    );
                    break;
            }
            return this.oldTransform.get();
        }.bind(this.contentMol);

        this.menuTouchPlane = new Plane({
            size: [this.options.menuWidth + this.options.pushAreaWidth - this.options.menuHintSize, undefined],
            properties: {
                zIndex: '-1000' // below everything
            }
        });

        this.mainMol.setOptions({
            origin: [this.alignment, 0.5],
            align: [this.alignment, 0.5]
        });
        this.menuMol.setOptions({
            origin: [this.alignment, 0.5],
            align: [this.alignment, 0.5]
        });
        this.contentMol.setOptions({
            origin: [this.alignment, 0.5],
            align: [this.alignment, 0.5]
        });

        // FIXME: WHY THE EFF must I also set align and origin on menuTouchPlane
        // when I've already set it on it's parent (this.menuMol)?????
        this.menuTouchPlane.setOptions({
            origin: [this.alignment, 0.5],
            align: [this.alignment, 0.5]
        });

        // Bring the menu content molecule and touch plane forward just
        // slightly so they're just above the content and content's fade plane,
        // so touch and mouse interaction works. HTML, the bad parts. ;)
        this.menuContentMol.transform.setTranslateZ(2);
        this.menuTouchPlane.transform.setTranslateZ(2);

        /*
         * Styles for the fadePlane
         */
        // TODO: move this somewhere else . it's specific for each animation
        this.updateStyles = function() {
            var startColor
            var endColor

            switch(this.options.animationType) {
                case "foldDown":
                    startColor = this.options.fadeStartColor
                    endColor = this.options.fadeEndColor
                    break;
                case "moveBack":
                    startColor = endColor = this.options.fadeEndColor
                    break;
            }

            var styles = {
                '.infamous-fadeLeft': {
                    background: [
                        endColor,
                        '-moz-linear-gradient(left, '+endColor+' 0%, '+startColor+' 100%)',
                        '-webkit-gradient(left top, right top, color-stop(0%, '+endColor+'), color-stop(100%, '+startColor+'))',
                        '-webkit-linear-gradient(left, '+endColor+' 0%, '+startColor+' 100%)',
                        '-o-linear-gradient(left, '+endColor+' 0%, '+startColor+' 100%)',
                        '-ms-linear-gradient(left, '+endColor+' 0%, '+startColor+' 100%)',
                        'linear-gradient(to right, '+endColor+' 0%, '+startColor+' 100%)'
                    ],
                    filter: 'progid:DXImageTransform.Microsoft.gradient( startColorstr=\'#cc000000\', endColorstr=\'#4d000000\', GradientType=1 )'
                },
                '.infamous-fadeRight': {
                    background: [
                        startColor,
                        '-moz-linear-gradient(left, '+startColor+' 0%, '+endColor+' 100%)',
                        '-webkit-gradient(left top, right top, color-stop(0%, '+startColor+'), color-stop(100%, '+endColor+'))',
                        '-webkit-linear-gradient(left, '+startColor+' 0%, '+endColor+' 100%)',
                        '-o-linear-gradient(left, '+startColor+' 0%, '+endColor+' 100%)',
                        '-ms-linear-gradient(left, '+startColor+' 0%, '+endColor+' 100%)',
                        'linear-gradient(to right, '+startColor+' 0%, '+endColor+' 100%)'
                    ],
                    filter: 'progid:DXImageTransform.Microsoft.gradient( startColorstr=\'#4d000000\', endColorstr=\'#cc000000\', GradientType=1 )'
                }
            };

            if (this.fadeStylesheet) { this.fadeStylesheet.detach(); }
            this.fadeStylesheet = jss.createStyleSheet(styles);
            this.fadeStylesheet.attach();
        };

        if (this.options.fade) {
            this.updateStyles();

            this.fadePlane = new Plane({
                size: [undefined,undefined],
                classes: [
                    // TODO: switch to jss namespace.
                    (this.options.menuSide == 'left'? 'infamous-fadeRight': 'infamous-fadeLeft')
                ],
                properties: {
                    zIndex: '1000',
                    pointerEvents: 'none'
                }
            });

            // FIXME: Why the EFF must I also set align and origin on fadePlane when
            // I've already set it on it's parent (this.contentMol)?????
            this.fadePlane.setOptions({
                origin: [this.alignment, 0.5],
                align: [this.alignment, 0.5]
            });

            // move the fadePlane forward by 1px so it doesn't glitch out.
            // Chrome will make the fadePlane and the surface in the content
            // area (if any) blink randomly when the two surfaces are in the
            // same exact position together.
            this.fadePlane.transform.setTranslateZ(1);

            this.fadePlane.setOptions({
                opacity: this.animationTransition
            });

            // TODO: Make fadePlane a sibling to menuMol and contentMol so that
            // contentMol contains only the user;s content. This will affect
            // the code in this.render().
            this.contentMol.add(this.fadePlane);
        }

        this.add(this.mainMol);
        this.mainMol.add(this.contentMol);
        this.menuMol.add(this.menuTouchPlane);
        this.menuMol.add(this.menuContentMol);
        this.mainMol.add(this.menuMol);
        // TODO: Also create and add a background plane for the menu area so it will catch events that might fall through the menu content.
    }

    /**
     * Sets up the events for the touch and mouse interaction that opens and
     * closes the menu.
     *
     * @private
     */
    _initializeEvents() {

        // move the menu, following the user's drag. Don't let the user drag the menu past the menu width.
        this.options.handler.on('update', function(event) { // update == drag
            this.isBeingDragged = true;

            // stop the current transitions if any, along with the current callback if any.
            this._haltAnimation(true);

            var currentPosition = this.animationTransition.get();

            // TODO: handle the right-side menu.
            switch(this.options.animationType) {
                case "foldDown":
                    this.animationTransition.set(currentPosition + event.delta[0] / (this.options.menuWidth - this.options.menuHintSize));
                    break;
                case "moveBack":
                    this.animationTransition.set(currentPosition + event.delta[0] / (this.options.menuWidth - this.options.menuHintSize));
                    break;
            }

            currentPosition = this.animationTransition.get();

            if (currentPosition > 1) {
                this.animationTransition.set(1);
            }
            else if (currentPosition < 0) {
                this.animationTransition.set(0);
            }
        }.bind(this));

        this.options.handler.on('end', function(event) {
            this.isBeingDragged = false;

            var currentPosition = this.animationTransition.get();

            if (currentPosition < 0.5) {
                this.closeMenu();
            }
            else {
                this.openMenu();
            }
        }.bind(this));

        // TODO v0.1.0: Use a SizeAwareView instead of relying on the body, since we
        // might not be directly in the body.
        window.addEventListener('resize', function(event) {
            this.contentWidth = document.body.clientWidth - this.options.menuHintSize;
            this.contentMol.setOptions({size: [this.contentWidth, undefined]});
        }.bind(this));

        /*
         * Wire up events
         * TODO: consolidate dup code here and in setMenu
         */
        this.menuTouchPlane.pipe(this.touchSync);
        this.menuTouchPlane.on('mouseenter', function() {
            if (!this.isOpening) {
                this.openMenu();
            }
        }.bind(this))
        this.menuTouchPlane.on('mouseleave', function() {
            if (!this.isClosing) {
                this.closeMenu();
            }
        }.bind(this))
        this.touchSync.pipe(this.options.handler);
    }

    /**
     * Add a scenegraph to the content area of the PushMenuLayout. You can put
     * anything you want into the content area (magical 3D things for example),
     * just be careful not to let them cover the menu or you'll block the user
     * from interacting with the menu.
     *
     * @param {module: famous/src/core/RenderNode} node A scenegraph, i.e. a
     * RenderNode with stuff in it.
     *
     * TODO: Accept plain renderables, f.e. Surfaces, etc. This change requires
     * also modifying the code in this.render() to account for renderables.
     *
     * TODO: Make a sibling method to reset the content area.
     */
    setContent(node) {
        this.contentMol.add(node)
    }

    /**
     * Add a scenegraph to the menu area of the PushMenuLayout. If the object
     * that you pass into setMenu is an infamous component, or a famo.us
     * Surface, then it's events will be piped to this PushMenuLayout's input
     * sync so that the user can open and close the menu with touch or mouse.
     * General advice here would be to keep whatever you put into the menu
     * contained within the boundaries of the menu or you might have touch and
     * mouse interaction outside of the menu.
     *
     * @param {module: famous/src/core/RenderNode} node A scenegraph, i.e. a
     * RenderNode with stuff in it.
     *
     * TODO: Accept plain renderables, f.e. Surfaces, etc.
     *
     * TODO: Remove old content before adding new content.
     */
    setMenu(node) {
        this.menuContentMol.add(node)
        if (node instanceof Molecule) {
            node.pipe(this.touchSync)
            node.on('mouseenter', function() {
                if (!this.isOpening) {
                    this.openMenu();
                }
            }.bind(this))
            node.on('mouseleave', function() {
                if (!this.isClosing) {
                    this.closeMenu();
                }
            }.bind(this))
        }
    }

    // TODO: replace menu easing with physics so the user can throw the menu,
    // using initial velocity and drag to slow it down, and stop immediately
    // when it hits the fully-open or fully-closed positions.

    /**
     * Opens the menu.
     *
     * @param {Function} callback The function to be called when the animation finishes.
     * @param {boolean} [cancelPreviousCallback=false] This is optional. If
     * true, then the callback of a previous open or close animation will be
     * canceled if that animation was still inprogress when this method is
     * called, otherwise the callback of the previous open or close animation
     * will be fired immediately before the animation for this animation begins.
     */
    openMenu(callback, cancelPreviousCallback) {
        this._haltAnimation(cancelPreviousCallback);

        this.isClosing = false;
        this.isOpening = true;

        this._animate('open', callback);
    }

    /**
     * Closes the menu.
     *
     * @param {Function} callback The function to be called when the animation finishes.
     * @param {boolean} [cancelPreviousCallback=false] This is optional. If
     * true, then the callback of a previous open or close animation will be
     * canceled if that animation was still inprogress when this method is
     * called, otherwise the callback of the previous open or close animation
     * will be fired immediately before the animation for this animation begins.
     */
    closeMenu(callback, cancelPreviousCallback) {
        this._haltAnimation(cancelPreviousCallback);

        this.isClosing = true;
        this.isOpening = false;

        this._animate('close', callback);
    }

    /**
     * Toggles the menu open or closed. If the menu is open or is opening, then it will now start
     * closing, and vice versa.
     *
     * @param {Function} callback The function to be called when the animation finishes.
     * @param {boolean} [cancelPreviousCallback=false] This is optional. If
     * true, then the callback of a previous open or close animation will be
     * canceled if that animation was still inprogress when this method is
     * called, otherwise the callback of the previous open or close animation
     * will be fired immediately before the animation for this animation begins.
     */
    toggleMenu(callback, cancelPreviousCallback) {
        if (this.isOpen || this.isOpening) {
            this.closeMenu(callback, cancelPreviousCallback);
        }
        else if (!this.isOpen || this.isClosing) {
            this.openMenu(callback, cancelPreviousCallback);
        }
    }

    /**
     * Animates the menu to it's target state.
     *
     * @private
     * @param {String} targetState The name of the state to animate to.
     * @param {Function} callback The function to call after the animation completes.
     */
    _animate(targetState, callback) {
        this.isAnimating = true;
        this.transitionCallback = callback;
        var _callback;

        var self = this;
        function setupCallback(numberOfTransitions) {
            // Fire callback after numberOfTransitions calls, when the 4 transitions are complete.
            _callback = callAfter(numberOfTransitions, function() {
                self.isAnimating = self.isOpening = self.isClosing = false;
                self.isOpen = targetState == 'open'? true: false;
                if (typeof self.transitionCallback == 'function') {
                    self.transitionCallback();
                }
                self.transitionCallback = undefined;
            }.bind(self));
        }

        setupCallback(1);
        if (targetState == 'open') {
            this.animationTransition.set(1, {duration: this.options.animationDuration, curve: Easing.outExpo}, _callback);
        }
        else if (targetState == 'close') {
            this.animationTransition.set(0, {duration: this.options.animationDuration, curve: Easing.outExpo}, _callback);
        }
    }

    /**
     * Halts the current animation, if any.
     *
     * @private
     * @param {boolean} [cancelCallback=false] Defaults to false. If true, the
     * halted animation's callback won't fire, otherwise it will be fired.
     */
    _haltAnimation(cancelCallback) {
        if (this.isAnimating) {
            if (!cancelCallback && typeof this.transitionCallback == 'function') {
                this.transitionCallback();
            }
            this.transitionCallback = undefined;
            this.animationTransition.halt();
        }
    }

    /**
     * @override
     */
    render() {

        // Blur the content if this.options.blur is true, and the animation is moveBack.
        //
        // TODO: Make the item to to be blur specifiable, perhaps with a method on
        // this.
        if (this.options.blur && this.options.fade && this.options.animationType == 'moveBack') {
            let momentaryBlur = (this.animationTransition.get() * this.options.blurRadius)
            let filter = {
                "-webkit-filter": 'blur('+momentaryBlur+'px)',
                "-moz-filter":    'blur('+momentaryBlur+'px)',
                "-ms-filter":     'blur('+momentaryBlur+'px)',
                "-o-filter":      'blur('+momentaryBlur+'px)',
                filter:           'blur('+momentaryBlur+'px)'
            }

            // TODO TODO TODO v0.1.0: Make fadePlane a sibling with menu and
            // content molecules or the following breaks if fade is false.
            // Then remove the check for this.options.fade in the previous if
            // statement above.
            if (this.contentMol._child[1].get() instanceof Surface) {
                this.contentMol.get().setProperties(filter)
            }
            else if (this.contentMol._child[1] instanceof Plane) {
                this.contentMol._child[1].surface.setProperties(filter)
            }
        }

        return super.render()
    }
}
export default PushMenuLayout;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHVzaE1lbnVMYXlvdXQuanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9QdXNoTWVudUxheW91dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTElDRU5TRVxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKlxuICovXG5cbmltcG9ydCBqc3MgZnJvbSAnLi9saWIvanNzJztcblxuaW1wb3J0IFN1cmZhY2UgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL1N1cmZhY2UnO1xuaW1wb3J0IFRyYW5zaXRpb25hYmxlIGZyb20gJ2ZhbW91cy9zcmMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnO1xuaW1wb3J0IEVhc2luZyBmcm9tICdmYW1vdXMvc3JjL3RyYW5zaXRpb25zL0Vhc2luZyc7XG5pbXBvcnQgVG91Y2hTeW5jIGZyb20gJ2ZhbW91cy9zcmMvaW5wdXRzL1RvdWNoU3luYyc7XG5pbXBvcnQgR2VuZXJpY1N5bmMgZnJvbSAnZmFtb3VzL3NyYy9pbnB1dHMvR2VuZXJpY1N5bmMnO1xuXG5pbXBvcnQgUGxhbmUgZnJvbSAnLi9QbGFuZSc7XG5pbXBvcnQgTW9sZWN1bGUgZnJvbSAnLi9Nb2xlY3VsZSc7XG5pbXBvcnQge3NpbXBsZUV4dGVuZH0gZnJvbSAnLi91dGlscydcblxuaW1wb3J0IGNhbGxBZnRlciBmcm9tICdhcm15LWtuaWZlL2NhbGxBZnRlcic7XG5cbi8qKlxuICogQSBzY2VuZWdyYXBoIHdpdGggdHdvIE1vbGVjdWxlIGxlYWZub2RlczogdGhlIG1lbnUgYXJlYSBhbmQgdGhlIGNvbnRlbnRcbiAqIGFyZWEuIFRoZSBtZW51IGFyZWEgaXMgaGlkZGVuIGJleW9uZCB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIHdoaWxlIHRoZVxuICogY29udGVudCBhcmVhIGlzIHZpc2libGUuIFN3aXBpbmcgaW4gZnJvbSB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIHJldmVhbHMgdGhlXG4gKiBtZW51LCBwdXR0aW5nIHRoZSBjb250ZW50IGFyZWEgb3V0IG9mIGZvY3VzLiBBIG1vdXNlIGNhbiBhbHNvIGJlIHVzZWQsIGFuZFxuICogaG92ZXJpbmcgbmVhciB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIGFsc28gcmV2ZWFscyB0aGUgbWVudS5cbiAqXG4gKiBOb3RlOiBUaGlzIGxheW91dCBpcyBtb3N0bHkgdXNlZnVsIGlmIGl0IGV4aXN0cyBhdCB0aGUgcm9vdCBvZiBhIGNvbnRleHQgc29cbiAqIHRoYXQgdGhlIG1lbnUgaXMgY2xpcHBlZCB3aGVuIGl0IGlzIGNsb3NlZCAob2ZmIHRvIHRoZSBzaWRlKSwgb3RoZXJ3aXNlIHRoZVxuICogbWVudSB3aWxsIGJlIHZpc2libGUgYmV5b25kIHRoZSBib3VuZGFyeSBvZiB0aGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlXG4gKiBQdXNoTWVudUxheW91dC5cbiAqXG4gKiBOb3RlOiBJZiB5b3UndmUgY2FsbGVkIGBvcGVuTWVudWAgb3IgYGNsb3NlTWVudWAgd2l0aCBhIGNhbGxiYWNrLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgY2FuY2VsZWQgaWYgYSBkcmFnIG9yIGhvdmVyIG9uIHRoZSBtZW51IGhhcHBlbnMgYmVmb3JlIHRoZSBhbmltYXRpb25cbiAqIGhhcyBjb21wbGV0ZWQuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIG9uIEdpdEh1YiBpZiB5b3UgaGF2ZSBhbnkgb3BpbmlvblxuICogYWdhaW5zdCB0aGlzLiA6KSBNYXliZSB3ZSBjYW4gYWRkIGEgYm9vbGVhbiBvcHRpb24gZm9yIHRoaXMgYmVoYXZpb3IuXG4gKlxuICogVE9ETzogRW1iZWQgd29ya2luZyBleGFtcGxlIGhlcmUuXG4gKlxuICogQGNsYXNzIFB1c2hNZW51TGF5b3V0XG4gKiBAZXh0ZW5kcyBNb2xlY3VsZVxuICovXG5leHBvcnQgY2xhc3MgUHVzaE1lbnVMYXlvdXQgZXh0ZW5kcyBNb2xlY3VsZSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFB1c2hNZW51TGF5b3V0LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gaW5zdGFudGlhdGUgYSBgUHVzaE1lbnVMYXlvdXRgIHdpdGguXG4gICAgICpcbiAgICAgKiBUT0RPIHYwLjEuMDogSGFuZGxlIGBQdXNoTWVudUxheW91dGAtc3BlY2lmaWMgdXNlciBvcHRpb25zLiBDdXJyZW50bHkgdGhleVxuICAgICAqIGp1c3QgZ2V0IHBhc3NlZCBpbnRvIHN1cGVyKCkgZm9yIHRoZSBNb2xlY3VsZSBjb25zdHJ1Y3RvciB0byBoYW5kbGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoaW5pdGlhbE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIEFkZCBkZWZhdWx0IHZhbHVlcyBmb3IgdGhpcyBQdXNoTWVudUxheW91dFxuICAgICAgICAvLyBUT0RPOiBNYWtlIGRlZmF1bHQgb3B0aW9ucyBzdGF0aWMgZm9yIHRoZSBjbGFzcy5cbiAgICAgICAgc2ltcGxlRXh0ZW5kKHRoaXMuXy5kZWZhdWx0T3B0aW9ucywge1xuICAgICAgICAgICAgbWVudVNpZGU6ICdsZWZ0JywgLy8gbGVmdCBvciByaWdodFxuICAgICAgICAgICAgbWVudVdpZHRoOiAyMDAsXG4gICAgICAgICAgICBtZW51SGludFNpemU6IDEwLCAvLyB0aGUgYW1vdW50IG9mIHRoZSBtZW51IHRoYXQgaXMgdmlzaWJsZSBiZWZvcmUgb3BlbmluZyB0aGUgbWVudS5cbiAgICAgICAgICAgIHB1c2hBcmVhV2lkdGg6IDQwLCAvLyB0aGUgYXJlYSBvbiB0aGUgc2NyZWVuIGVkZ2UgdGhhdCB0aGUgdXNlciBjYW4gdG91Y2ggYW5kIGRyYWcgdG8gcHVzaCBvdXQgdGhlIG1lbnUuXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgIGFuaW1hdGlvblR5cGU6ICdmb2xkRG93bicsIC8vIG9wdGlvbnM6IGZvbGREb3duIG1vdmVCYWNrXG5cbiAgICAgICAgICAgIC8vIFRPRE86IEJhY2tncm91bmQgY29sb3IgZm9yIHRoZSB3aG9sZSBsYXlvdXQgc2hvdWxkIGJlIHRoZSBjb2xvciB0aGF0IHRoZSBmYWRlIGZhZGVzIHRvLlxuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBmYWRlIHN0YXIvZW5kIGNvbG9ycyB3aXRoIGEgZm9nIGNvbG9yIHZhbHVlIGFuZCBpbnRlbnNpdHkuXG4gICAgICAgICAgICBmYWRlOiB0cnVlLCAvLyB3aGVuIGNvbnRlbnQgcmVjZWRlcywgaXQgZmFkZXMgaW50byB0aGUgZm9nLlxuICAgICAgICAgICAgZmFkZVN0YXJ0Q29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDApJyxcbiAgICAgICAgICAgIGZhZGVFbmRDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMSknLFxuXG4gICAgICAgICAgICBibHVyOiBmYWxzZSwgLy8gWFhYOiBXSVAsIHNvIGZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBibHVyUmFkaXVzOiA1XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gVE9ETzogcGVyZm9ybWFuY2UgaGl0LCB0aGlzIHNldHRlciBpcyBpbnZva2VkIGluIHRoZSBNb2xlY3VsZSBjb25zdHJ1Y3RvciwgdGhlbiBoZXJlIGFnYWluLlxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBpbml0aWFsT3B0aW9uc1xuXG4gICAgICAgIC8vIFRPRE8gdjAuMS4wOiBNYXJrIHRoZXNlIGFzIHByaXZhdGUuXG4gICAgICAgICAgICAvLyBUT0RPIHYwLjEuMDogdGhpcy5jb250ZW50V2lkdGggc2hvdWxkIGJlIHRoZSB3aWR0aCBvZiB3aGF0ZXZlciBpcyBjb250YWluaW5nXG4gICAgICAgICAgICAvLyB0aGUgbGF5b3V0LCBidXQgd2UncmUganVzdCB1c2luZyBpdCBhcyBhIHdob2xlLXBhZ2UgYXBwIGZvciBub3cuIEdldFxuICAgICAgICAgICAgLy8gc2l6ZSBmcm9tIGEgY29tbWl0PyBVUERBVEU6IFNlZSB0aGUgbmV3IGZhbW91cy9zcmMvdmlld3MvU2l6ZUF3YXJlVmlld1xuICAgICAgICAgICAgdGhpcy5jb250ZW50V2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC0gdGhpcy5vcHRpb25zLm1lbnVIaW50U2l6ZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlc2UgdmFsdWVzIG91dHNpZGUgb2YgYW4gaW5zdGFuY2Ugb2YgUHVzaE1lbnVMYXlvdXQgbWlnaHRcbiAgICAgICAgICAgIC8vIGNhdXNlIHRoZSBsYXlvdXQgdG8gYnJlYWsuIFRoZXkgYXJlIGRlc2lnbmVkIHRvIGJlIG1vZGlmaWVkXG4gICAgICAgICAgICAvLyBpbnRlcm5hbGx5IG9ubHkuXG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgbWVudSBpcyBvcGVuaW5nIG9yIGNsb3NpbmcuXG4gICAgICAgICAgICB0aGlzLmlzQmVpbmdEcmFnZ2VkID0gZmFsc2U7IC8vIHdoZXRoZXIgdGhlIHVzZXIgaXMgZHJhZ2dpbmcvcHVzaGluZyB0aGUgbWVudSBvciBub3QuXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DYWxsYmFjayA9IHVuZGVmaW5lZDsgLy8gaG9sZHMgdGhlIGNhbGxiYWNrIHRvIHRoZSBjdXJyZW50IG9wZW4gb3IgY2xvc2UgbWVudSBhbmltYXRpb24uXG5cbiAgICAgICAgLy8gU2V0IHRoZSB0b3VjaCBzeW5jIGZvciBwdWxsaW5nL3B1c2hpbmcgdGhlIG1lbnUgb3Blbi9jbG9zZWQuXG4gICAgICAgIEdlbmVyaWNTeW5jLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIHRvdWNoOiBUb3VjaFN5bmNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlQ29tcG9uZW50cygpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIE1vbGVjdWxlLnNldE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHNldE9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgICAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdGlvbnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIE1vbGVjdWxlLnJlc2V0T3B0aW9uc1xuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzZXRPcHRpb25zKCkge1xuICAgICAgICBzdXBlci5yZXNldE9wdGlvbnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1lbnUgYXJlYSwgY29udGVudCBhcmVhLCBgUGxhbmVgIGZvciB0aGUgZmFkZSBlZmZlY3QsIGV0Yy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNvbXBvbmVudHMoKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hTeW5jID0gbmV3IEdlbmVyaWNTeW5jKFsndG91Y2gnXSk7XG5cbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSAodGhpcy5vcHRpb25zLm1lbnVTaWRlID09IFwibGVmdFwiPyAwOiAxKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuXG4gICAgICAgIHRoaXMubWFpbk1vbCA9IG5ldyBNb2xlY3VsZSgpO1xuXG4gICAgICAgIHRoaXMubWVudU1vbCA9IG5ldyBNb2xlY3VsZSh7XG4gICAgICAgICAgICBzaXplOiBbdGhpcy5vcHRpb25zLm1lbnVXaWR0aCx1bmRlZmluZWRdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lbnVNb2wub2xkVHJhbnNmb3JtID0gdGhpcy5tZW51TW9sLnRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5tZW51TW9sLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkgeyAvLyBvdmVycmlkZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IGxheW91dC5hbmltYXRpb25UcmFuc2l0aW9uLmdldCgpO1xuICAgICAgICAgICAgc3dpdGNoKGxheW91dC5vcHRpb25zLmFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZERvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiB0aGlzIGlzIGRlcGVuZGluZyBvbiBteSBtb2RpZmljYXRpb25zIGZvciBUcmFuc2l0aW9uYWJsZVRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbGRUcmFuc2Zvcm0uc2V0VHJhbnNsYXRlWChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5vcHRpb25zLm1lbnVTaWRlID09ICdsZWZ0Jz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKiAgKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypyYW5nZSovIC0gKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypvZmZzZXQqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKiAtKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypyYW5nZSovICsgKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypvZmZzZXQqL1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibW92ZUJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiB0aGlzIGlzIGRlcGVuZGluZyBvbiBteSBtb2RpZmljYXRpb25zIGZvciBUcmFuc2l0aW9uYWJsZVRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbGRUcmFuc2Zvcm0uc2V0VHJhbnNsYXRlWChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5vcHRpb25zLm1lbnVTaWRlID09ICdsZWZ0Jz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKiAgKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypyYW5nZSovIC0gKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypvZmZzZXQqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKiAtKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypyYW5nZSovICsgKGxheW91dC5vcHRpb25zLm1lbnVXaWR0aC1sYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypvZmZzZXQqL1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZFRyYW5zZm9ybS5nZXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMubWVudU1vbCk7XG5cbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHVzZXIncyBtZW51IGNvbnRlbnQuXG4gICAgICAgIHRoaXMubWVudUNvbnRlbnRNb2wgPSBuZXcgTW9sZWN1bGUoKTtcblxuICAgICAgICB0aGlzLmNvbnRlbnRNb2wgPSBuZXcgTW9sZWN1bGUoe1xuICAgICAgICAgICAgc2l6ZTogW3RoaXMuY29udGVudFdpZHRoLHVuZGVmaW5lZF1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udGVudE1vbC5vbGRUcmFuc2Zvcm0gPSB0aGlzLmNvbnRlbnRNb2wudHJhbnNmb3JtO1xuICAgICAgICB0aGlzLmNvbnRlbnRNb2wudHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7IC8vIG92ZXJyaWRlXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gbGF5b3V0LmFuaW1hdGlvblRyYW5zaXRpb24uZ2V0KCk7XG4gICAgICAgICAgICBzd2l0Y2gobGF5b3V0Lm9wdGlvbnMuYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmb2xkRG93blwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IHRoaXMgaXMgZGVwZW5kaW5nIG9uIG15IG1vZGlmaWNhdGlvbnMgZm9yIFRyYW5zaXRpb25hYmxlVHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sZFRyYW5zZm9ybS5zZXRUcmFuc2xhdGVYKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Lm9wdGlvbnMubWVudVNpZGUgPT0gJ2xlZnQnP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiAqICAobGF5b3V0Lm9wdGlvbnMubWVudVdpZHRoIC0gbGF5b3V0Lm9wdGlvbnMubWVudUhpbnRTaXplKS8qcmFuZ2UqLyArIGxheW91dC5vcHRpb25zLm1lbnVIaW50U2l6ZS8qb2Zmc2V0Ki86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICogLShsYXlvdXQub3B0aW9ucy5tZW51V2lkdGggLSBsYXlvdXQub3B0aW9ucy5tZW51SGludFNpemUpLypyYW5nZSovIC0gbGF5b3V0Lm9wdGlvbnMubWVudUhpbnRTaXplLypvZmZzZXQqL1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IHRoaXMgaXMgZGVwZW5kaW5nIG9uIG15IG1vZGlmaWNhdGlvbnMgZm9yIFRyYW5zaXRpb25hYmxlVHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sZFRyYW5zZm9ybS5zZXRSb3RhdGVZKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Lm9wdGlvbnMubWVudVNpZGUgPT0gJ2xlZnQnP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiAqICBNYXRoLlBJLzg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICogLU1hdGguUEkvOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibW92ZUJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IHRoaXMgaXMgZGVwZW5kaW5nIG9uIG15IG1vZGlmaWNhdGlvbnMgZm9yIFRyYW5zaXRpb25hYmxlVHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sZFRyYW5zZm9ybS5zZXRUcmFuc2xhdGVYKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Lm9wdGlvbnMubWVudVNpZGUgPT0gJ2xlZnQnP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5vcHRpb25zLm1lbnVIaW50U2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtbGF5b3V0Lm9wdGlvbnMubWVudUhpbnRTaXplXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2xkVHJhbnNmb3JtLnNldFRyYW5zbGF0ZVooXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKiAtZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbGRUcmFuc2Zvcm0uZ2V0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzLmNvbnRlbnRNb2wpO1xuXG4gICAgICAgIHRoaXMubWVudVRvdWNoUGxhbmUgPSBuZXcgUGxhbmUoe1xuICAgICAgICAgICAgc2l6ZTogW3RoaXMub3B0aW9ucy5tZW51V2lkdGggKyB0aGlzLm9wdGlvbnMucHVzaEFyZWFXaWR0aCAtIHRoaXMub3B0aW9ucy5tZW51SGludFNpemUsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgekluZGV4OiAnLTEwMDAnIC8vIGJlbG93IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluTW9sLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgb3JpZ2luOiBbdGhpcy5hbGlnbm1lbnQsIDAuNV0sXG4gICAgICAgICAgICBhbGlnbjogW3RoaXMuYWxpZ25tZW50LCAwLjVdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lbnVNb2wuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBvcmlnaW46IFt0aGlzLmFsaWdubWVudCwgMC41XSxcbiAgICAgICAgICAgIGFsaWduOiBbdGhpcy5hbGlnbm1lbnQsIDAuNV1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udGVudE1vbC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG9yaWdpbjogW3RoaXMuYWxpZ25tZW50LCAwLjVdLFxuICAgICAgICAgICAgYWxpZ246IFt0aGlzLmFsaWdubWVudCwgMC41XVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGSVhNRTogV0hZIFRIRSBFRkYgbXVzdCBJIGFsc28gc2V0IGFsaWduIGFuZCBvcmlnaW4gb24gbWVudVRvdWNoUGxhbmVcbiAgICAgICAgLy8gd2hlbiBJJ3ZlIGFscmVhZHkgc2V0IGl0IG9uIGl0J3MgcGFyZW50ICh0aGlzLm1lbnVNb2wpPz8/Pz9cbiAgICAgICAgdGhpcy5tZW51VG91Y2hQbGFuZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG9yaWdpbjogW3RoaXMuYWxpZ25tZW50LCAwLjVdLFxuICAgICAgICAgICAgYWxpZ246IFt0aGlzLmFsaWdubWVudCwgMC41XVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBCcmluZyB0aGUgbWVudSBjb250ZW50IG1vbGVjdWxlIGFuZCB0b3VjaCBwbGFuZSBmb3J3YXJkIGp1c3RcbiAgICAgICAgLy8gc2xpZ2h0bHkgc28gdGhleSdyZSBqdXN0IGFib3ZlIHRoZSBjb250ZW50IGFuZCBjb250ZW50J3MgZmFkZSBwbGFuZSxcbiAgICAgICAgLy8gc28gdG91Y2ggYW5kIG1vdXNlIGludGVyYWN0aW9uIHdvcmtzLiBIVE1MLCB0aGUgYmFkIHBhcnRzLiA7KVxuICAgICAgICB0aGlzLm1lbnVDb250ZW50TW9sLnRyYW5zZm9ybS5zZXRUcmFuc2xhdGVaKDIpO1xuICAgICAgICB0aGlzLm1lbnVUb3VjaFBsYW5lLnRyYW5zZm9ybS5zZXRUcmFuc2xhdGVaKDIpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFN0eWxlcyBmb3IgdGhlIGZhZGVQbGFuZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogbW92ZSB0aGlzIHNvbWV3aGVyZSBlbHNlIC4gaXQncyBzcGVjaWZpYyBmb3IgZWFjaCBhbmltYXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGFydENvbG9yXG4gICAgICAgICAgICB2YXIgZW5kQ29sb3JcblxuICAgICAgICAgICAgc3dpdGNoKHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvbGREb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sb3IgPSB0aGlzLm9wdGlvbnMuZmFkZVN0YXJ0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sb3IgPSB0aGlzLm9wdGlvbnMuZmFkZUVuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtb3ZlQmFja1wiOlxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbG9yID0gZW5kQ29sb3IgPSB0aGlzLm9wdGlvbnMuZmFkZUVuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICcuaW5mYW1vdXMtZmFkZUxlZnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy1tb3otbGluZWFyLWdyYWRpZW50KGxlZnQsICcrZW5kQ29sb3IrJyAwJSwgJytzdGFydENvbG9yKycgMTAwJSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtZ3JhZGllbnQobGVmdCB0b3AsIHJpZ2h0IHRvcCwgY29sb3Itc3RvcCgwJSwgJytlbmRDb2xvcisnKSwgY29sb3Itc3RvcCgxMDAlLCAnK3N0YXJ0Q29sb3IrJykpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAnK2VuZENvbG9yKycgMCUsICcrc3RhcnRDb2xvcisnIDEwMCUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctby1saW5lYXItZ3JhZGllbnQobGVmdCwgJytlbmRDb2xvcisnIDAlLCAnK3N0YXJ0Q29sb3IrJyAxMDAlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnLW1zLWxpbmVhci1ncmFkaWVudChsZWZ0LCAnK2VuZENvbG9yKycgMCUsICcrc3RhcnRDb2xvcisnIDEwMCUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICcrZW5kQ29sb3IrJyAwJSwgJytzdGFydENvbG9yKycgMTAwJSknXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj1cXCcjY2MwMDAwMDBcXCcsIGVuZENvbG9yc3RyPVxcJyM0ZDAwMDAwMFxcJywgR3JhZGllbnRUeXBlPTEgKSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcuaW5mYW1vdXMtZmFkZVJpZ2h0Jzoge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy1tb3otbGluZWFyLWdyYWRpZW50KGxlZnQsICcrc3RhcnRDb2xvcisnIDAlLCAnK2VuZENvbG9yKycgMTAwJSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtZ3JhZGllbnQobGVmdCB0b3AsIHJpZ2h0IHRvcCwgY29sb3Itc3RvcCgwJSwgJytzdGFydENvbG9yKycpLCBjb2xvci1zdG9wKDEwMCUsICcrZW5kQ29sb3IrJykpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAnK3N0YXJ0Q29sb3IrJyAwJSwgJytlbmRDb2xvcisnIDEwMCUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICctby1saW5lYXItZ3JhZGllbnQobGVmdCwgJytzdGFydENvbG9yKycgMCUsICcrZW5kQ29sb3IrJyAxMDAlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnLW1zLWxpbmVhci1ncmFkaWVudChsZWZ0LCAnK3N0YXJ0Q29sb3IrJyAwJSwgJytlbmRDb2xvcisnIDEwMCUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICcrc3RhcnRDb2xvcisnIDAlLCAnK2VuZENvbG9yKycgMTAwJSknXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj1cXCcjNGQwMDAwMDBcXCcsIGVuZENvbG9yc3RyPVxcJyNjYzAwMDAwMFxcJywgR3JhZGllbnRUeXBlPTEgKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5mYWRlU3R5bGVzaGVldCkgeyB0aGlzLmZhZGVTdHlsZXNoZWV0LmRldGFjaCgpOyB9XG4gICAgICAgICAgICB0aGlzLmZhZGVTdHlsZXNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuZmFkZVN0eWxlc2hlZXQuYXR0YWNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlcygpO1xuXG4gICAgICAgICAgICB0aGlzLmZhZGVQbGFuZSA9IG5ldyBQbGFuZSh7XG4gICAgICAgICAgICAgICAgc2l6ZTogW3VuZGVmaW5lZCx1bmRlZmluZWRdLFxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc3dpdGNoIHRvIGpzcyBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMubWVudVNpZGUgPT0gJ2xlZnQnPyAnaW5mYW1vdXMtZmFkZVJpZ2h0JzogJ2luZmFtb3VzLWZhZGVMZWZ0JylcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVhNRTogV2h5IHRoZSBFRkYgbXVzdCBJIGFsc28gc2V0IGFsaWduIGFuZCBvcmlnaW4gb24gZmFkZVBsYW5lIHdoZW5cbiAgICAgICAgICAgIC8vIEkndmUgYWxyZWFkeSBzZXQgaXQgb24gaXQncyBwYXJlbnQgKHRoaXMuY29udGVudE1vbCk/Pz8/P1xuICAgICAgICAgICAgdGhpcy5mYWRlUGxhbmUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBbdGhpcy5hbGlnbm1lbnQsIDAuNV0sXG4gICAgICAgICAgICAgICAgYWxpZ246IFt0aGlzLmFsaWdubWVudCwgMC41XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGZhZGVQbGFuZSBmb3J3YXJkIGJ5IDFweCBzbyBpdCBkb2Vzbid0IGdsaXRjaCBvdXQuXG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBtYWtlIHRoZSBmYWRlUGxhbmUgYW5kIHRoZSBzdXJmYWNlIGluIHRoZSBjb250ZW50XG4gICAgICAgICAgICAvLyBhcmVhIChpZiBhbnkpIGJsaW5rIHJhbmRvbWx5IHdoZW4gdGhlIHR3byBzdXJmYWNlcyBhcmUgaW4gdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGV4YWN0IHBvc2l0aW9uIHRvZ2V0aGVyLlxuICAgICAgICAgICAgdGhpcy5mYWRlUGxhbmUudHJhbnNmb3JtLnNldFRyYW5zbGF0ZVooMSk7XG5cbiAgICAgICAgICAgIHRoaXMuZmFkZVBsYW5lLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgZmFkZVBsYW5lIGEgc2libGluZyB0byBtZW51TW9sIGFuZCBjb250ZW50TW9sIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGNvbnRlbnRNb2wgY29udGFpbnMgb25seSB0aGUgdXNlcjtzIGNvbnRlbnQuIFRoaXMgd2lsbCBhZmZlY3RcbiAgICAgICAgICAgIC8vIHRoZSBjb2RlIGluIHRoaXMucmVuZGVyKCkuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRNb2wuYWRkKHRoaXMuZmFkZVBsYW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkKHRoaXMubWFpbk1vbCk7XG4gICAgICAgIHRoaXMubWFpbk1vbC5hZGQodGhpcy5jb250ZW50TW9sKTtcbiAgICAgICAgdGhpcy5tZW51TW9sLmFkZCh0aGlzLm1lbnVUb3VjaFBsYW5lKTtcbiAgICAgICAgdGhpcy5tZW51TW9sLmFkZCh0aGlzLm1lbnVDb250ZW50TW9sKTtcbiAgICAgICAgdGhpcy5tYWluTW9sLmFkZCh0aGlzLm1lbnVNb2wpO1xuICAgICAgICAvLyBUT0RPOiBBbHNvIGNyZWF0ZSBhbmQgYWRkIGEgYmFja2dyb3VuZCBwbGFuZSBmb3IgdGhlIG1lbnUgYXJlYSBzbyBpdCB3aWxsIGNhdGNoIGV2ZW50cyB0aGF0IG1pZ2h0IGZhbGwgdGhyb3VnaCB0aGUgbWVudSBjb250ZW50LlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGV2ZW50cyBmb3IgdGhlIHRvdWNoIGFuZCBtb3VzZSBpbnRlcmFjdGlvbiB0aGF0IG9wZW5zIGFuZFxuICAgICAqIGNsb3NlcyB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVFdmVudHMoKSB7XG5cbiAgICAgICAgLy8gbW92ZSB0aGUgbWVudSwgZm9sbG93aW5nIHRoZSB1c2VyJ3MgZHJhZy4gRG9uJ3QgbGV0IHRoZSB1c2VyIGRyYWcgdGhlIG1lbnUgcGFzdCB0aGUgbWVudSB3aWR0aC5cbiAgICAgICAgdGhpcy5vcHRpb25zLmhhbmRsZXIub24oJ3VwZGF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7IC8vIHVwZGF0ZSA9PSBkcmFnXG4gICAgICAgICAgICB0aGlzLmlzQmVpbmdEcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgY3VycmVudCB0cmFuc2l0aW9ucyBpZiBhbnksIGFsb25nIHdpdGggdGhlIGN1cnJlbnQgY2FsbGJhY2sgaWYgYW55LlxuICAgICAgICAgICAgdGhpcy5faGFsdEFuaW1hdGlvbih0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5nZXQoKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRoZSByaWdodC1zaWRlIG1lbnUuXG4gICAgICAgICAgICBzd2l0Y2godGhpcy5vcHRpb25zLmFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZERvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uLnNldChjdXJyZW50UG9zaXRpb24gKyBldmVudC5kZWx0YVswXSAvICh0aGlzLm9wdGlvbnMubWVudVdpZHRoIC0gdGhpcy5vcHRpb25zLm1lbnVIaW50U2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibW92ZUJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uLnNldChjdXJyZW50UG9zaXRpb24gKyBldmVudC5kZWx0YVswXSAvICh0aGlzLm9wdGlvbnMubWVudVdpZHRoIC0gdGhpcy5vcHRpb25zLm1lbnVIaW50U2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uLmdldCgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5zZXQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50UG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uLnNldCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMuaGFuZGxlci5vbignZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCZWluZ0RyYWdnZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5nZXQoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5NZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gVE9ETyB2MC4xLjA6IFVzZSBhIFNpemVBd2FyZVZpZXcgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBib2R5LCBzaW5jZSB3ZVxuICAgICAgICAvLyBtaWdodCBub3QgYmUgZGlyZWN0bHkgaW4gdGhlIGJvZHkuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50V2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC0gdGhpcy5vcHRpb25zLm1lbnVIaW50U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE1vbC5zZXRPcHRpb25zKHtzaXplOiBbdGhpcy5jb250ZW50V2lkdGgsIHVuZGVmaW5lZF19KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBXaXJlIHVwIGV2ZW50c1xuICAgICAgICAgKiBUT0RPOiBjb25zb2xpZGF0ZSBkdXAgY29kZSBoZXJlIGFuZCBpbiBzZXRNZW51XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lbnVUb3VjaFBsYW5lLnBpcGUodGhpcy50b3VjaFN5bmMpO1xuICAgICAgICB0aGlzLm1lbnVUb3VjaFBsYW5lLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIHRoaXMubWVudVRvdWNoUGxhbmUub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIHRoaXMudG91Y2hTeW5jLnBpcGUodGhpcy5vcHRpb25zLmhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNjZW5lZ3JhcGggdG8gdGhlIGNvbnRlbnQgYXJlYSBvZiB0aGUgUHVzaE1lbnVMYXlvdXQuIFlvdSBjYW4gcHV0XG4gICAgICogYW55dGhpbmcgeW91IHdhbnQgaW50byB0aGUgY29udGVudCBhcmVhIChtYWdpY2FsIDNEIHRoaW5ncyBmb3IgZXhhbXBsZSksXG4gICAgICoganVzdCBiZSBjYXJlZnVsIG5vdCB0byBsZXQgdGhlbSBjb3ZlciB0aGUgbWVudSBvciB5b3UnbGwgYmxvY2sgdGhlIHVzZXJcbiAgICAgKiBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTogZmFtb3VzL3NyYy9jb3JlL1JlbmRlck5vZGV9IG5vZGUgQSBzY2VuZWdyYXBoLCBpLmUuIGFcbiAgICAgKiBSZW5kZXJOb2RlIHdpdGggc3R1ZmYgaW4gaXQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBBY2NlcHQgcGxhaW4gcmVuZGVyYWJsZXMsIGYuZS4gU3VyZmFjZXMsIGV0Yy4gVGhpcyBjaGFuZ2UgcmVxdWlyZXNcbiAgICAgKiBhbHNvIG1vZGlmeWluZyB0aGUgY29kZSBpbiB0aGlzLnJlbmRlcigpIHRvIGFjY291bnQgZm9yIHJlbmRlcmFibGVzLlxuICAgICAqXG4gICAgICogVE9ETzogTWFrZSBhIHNpYmxpbmcgbWV0aG9kIHRvIHJlc2V0IHRoZSBjb250ZW50IGFyZWEuXG4gICAgICovXG4gICAgc2V0Q29udGVudChub2RlKSB7XG4gICAgICAgIHRoaXMuY29udGVudE1vbC5hZGQobm9kZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzY2VuZWdyYXBoIHRvIHRoZSBtZW51IGFyZWEgb2YgdGhlIFB1c2hNZW51TGF5b3V0LiBJZiB0aGUgb2JqZWN0XG4gICAgICogdGhhdCB5b3UgcGFzcyBpbnRvIHNldE1lbnUgaXMgYW4gaW5mYW1vdXMgY29tcG9uZW50LCBvciBhIGZhbW8udXNcbiAgICAgKiBTdXJmYWNlLCB0aGVuIGl0J3MgZXZlbnRzIHdpbGwgYmUgcGlwZWQgdG8gdGhpcyBQdXNoTWVudUxheW91dCdzIGlucHV0XG4gICAgICogc3luYyBzbyB0aGF0IHRoZSB1c2VyIGNhbiBvcGVuIGFuZCBjbG9zZSB0aGUgbWVudSB3aXRoIHRvdWNoIG9yIG1vdXNlLlxuICAgICAqIEdlbmVyYWwgYWR2aWNlIGhlcmUgd291bGQgYmUgdG8ga2VlcCB3aGF0ZXZlciB5b3UgcHV0IGludG8gdGhlIG1lbnVcbiAgICAgKiBjb250YWluZWQgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBtZW51IG9yIHlvdSBtaWdodCBoYXZlIHRvdWNoIGFuZFxuICAgICAqIG1vdXNlIGludGVyYWN0aW9uIG91dHNpZGUgb2YgdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTogZmFtb3VzL3NyYy9jb3JlL1JlbmRlck5vZGV9IG5vZGUgQSBzY2VuZWdyYXBoLCBpLmUuIGFcbiAgICAgKiBSZW5kZXJOb2RlIHdpdGggc3R1ZmYgaW4gaXQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBBY2NlcHQgcGxhaW4gcmVuZGVyYWJsZXMsIGYuZS4gU3VyZmFjZXMsIGV0Yy5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlbW92ZSBvbGQgY29udGVudCBiZWZvcmUgYWRkaW5nIG5ldyBjb250ZW50LlxuICAgICAqL1xuICAgIHNldE1lbnUobm9kZSkge1xuICAgICAgICB0aGlzLm1lbnVDb250ZW50TW9sLmFkZChub2RlKVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE1vbGVjdWxlKSB7XG4gICAgICAgICAgICBub2RlLnBpcGUodGhpcy50b3VjaFN5bmMpXG4gICAgICAgICAgICBub2RlLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5NZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgbm9kZS5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZXBsYWNlIG1lbnUgZWFzaW5nIHdpdGggcGh5c2ljcyBzbyB0aGUgdXNlciBjYW4gdGhyb3cgdGhlIG1lbnUsXG4gICAgLy8gdXNpbmcgaW5pdGlhbCB2ZWxvY2l0eSBhbmQgZHJhZyB0byBzbG93IGl0IGRvd24sIGFuZCBzdG9wIGltbWVkaWF0ZWx5XG4gICAgLy8gd2hlbiBpdCBoaXRzIHRoZSBmdWxseS1vcGVuIG9yIGZ1bGx5LWNsb3NlZCBwb3NpdGlvbnMuXG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbFByZXZpb3VzQ2FsbGJhY2s9ZmFsc2VdIFRoaXMgaXMgb3B0aW9uYWwuIElmXG4gICAgICogdHJ1ZSwgdGhlbiB0aGUgY2FsbGJhY2sgb2YgYSBwcmV2aW91cyBvcGVuIG9yIGNsb3NlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgICogY2FuY2VsZWQgaWYgdGhhdCBhbmltYXRpb24gd2FzIHN0aWxsIGlucHJvZ3Jlc3Mgd2hlbiB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSBjYWxsYmFjayBvZiB0aGUgcHJldmlvdXMgb3BlbiBvciBjbG9zZSBhbmltYXRpb25cbiAgICAgKiB3aWxsIGJlIGZpcmVkIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZvciB0aGlzIGFuaW1hdGlvbiBiZWdpbnMuXG4gICAgICovXG4gICAgb3Blbk1lbnUoY2FsbGJhY2ssIGNhbmNlbFByZXZpb3VzQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faGFsdEFuaW1hdGlvbihjYW5jZWxQcmV2aW91c0NhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzT3BlbmluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZSgnb3BlbicsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxQcmV2aW91c0NhbGxiYWNrPWZhbHNlXSBUaGlzIGlzIG9wdGlvbmFsLiBJZlxuICAgICAqIHRydWUsIHRoZW4gdGhlIGNhbGxiYWNrIG9mIGEgcHJldmlvdXMgb3BlbiBvciBjbG9zZSBhbmltYXRpb24gd2lsbCBiZVxuICAgICAqIGNhbmNlbGVkIGlmIHRoYXQgYW5pbWF0aW9uIHdhcyBzdGlsbCBpbnByb2dyZXNzIHdoZW4gdGhpcyBtZXRob2QgaXNcbiAgICAgKiBjYWxsZWQsIG90aGVyd2lzZSB0aGUgY2FsbGJhY2sgb2YgdGhlIHByZXZpb3VzIG9wZW4gb3IgY2xvc2UgYW5pbWF0aW9uXG4gICAgICogd2lsbCBiZSBmaXJlZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGFuaW1hdGlvbiBmb3IgdGhpcyBhbmltYXRpb24gYmVnaW5zLlxuICAgICAqL1xuICAgIGNsb3NlTWVudShjYWxsYmFjaywgY2FuY2VsUHJldmlvdXNDYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9oYWx0QW5pbWF0aW9uKGNhbmNlbFByZXZpb3VzQ2FsbGJhY2spO1xuXG4gICAgICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9hbmltYXRlKCdjbG9zZScsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBtZW51IG9wZW4gb3IgY2xvc2VkLiBJZiB0aGUgbWVudSBpcyBvcGVuIG9yIGlzIG9wZW5pbmcsIHRoZW4gaXQgd2lsbCBub3cgc3RhcnRcbiAgICAgKiBjbG9zaW5nLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbFByZXZpb3VzQ2FsbGJhY2s9ZmFsc2VdIFRoaXMgaXMgb3B0aW9uYWwuIElmXG4gICAgICogdHJ1ZSwgdGhlbiB0aGUgY2FsbGJhY2sgb2YgYSBwcmV2aW91cyBvcGVuIG9yIGNsb3NlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgICogY2FuY2VsZWQgaWYgdGhhdCBhbmltYXRpb24gd2FzIHN0aWxsIGlucHJvZ3Jlc3Mgd2hlbiB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSBjYWxsYmFjayBvZiB0aGUgcHJldmlvdXMgb3BlbiBvciBjbG9zZSBhbmltYXRpb25cbiAgICAgKiB3aWxsIGJlIGZpcmVkIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZvciB0aGlzIGFuaW1hdGlvbiBiZWdpbnMuXG4gICAgICovXG4gICAgdG9nZ2xlTWVudShjYWxsYmFjaywgY2FuY2VsUHJldmlvdXNDYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gfHwgdGhpcy5pc09wZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KGNhbGxiYWNrLCBjYW5jZWxQcmV2aW91c0NhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pc09wZW4gfHwgdGhpcy5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3Blbk1lbnUoY2FsbGJhY2ssIGNhbmNlbFByZXZpb3VzQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIG1lbnUgdG8gaXQncyB0YXJnZXQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRTdGF0ZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gYW5pbWF0ZSB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBfYW5pbWF0ZSh0YXJnZXRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHZhciBfY2FsbGJhY2s7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBzZXR1cENhbGxiYWNrKG51bWJlck9mVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEZpcmUgY2FsbGJhY2sgYWZ0ZXIgbnVtYmVyT2ZUcmFuc2l0aW9ucyBjYWxscywgd2hlbiB0aGUgNCB0cmFuc2l0aW9ucyBhcmUgY29tcGxldGUuXG4gICAgICAgICAgICBfY2FsbGJhY2sgPSBjYWxsQWZ0ZXIobnVtYmVyT2ZUcmFuc2l0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IHNlbGYuaXNPcGVuaW5nID0gc2VsZi5pc0Nsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLmlzT3BlbiA9IHRhcmdldFN0YXRlID09ICdvcGVuJz8gdHJ1ZTogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnRyYW5zaXRpb25DYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvbkNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvbkNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfS5iaW5kKHNlbGYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHVwQ2FsbGJhY2soMSk7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5zZXQoMSwge2R1cmF0aW9uOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIGN1cnZlOiBFYXNpbmcub3V0RXhwb30sIF9jYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0U3RhdGUgPT0gJ2Nsb3NlJykge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UcmFuc2l0aW9uLnNldCgwLCB7ZHVyYXRpb246IHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgY3VydmU6IEVhc2luZy5vdXRFeHBvfSwgX2NhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbHRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxDYWxsYmFjaz1mYWxzZV0gRGVmYXVsdHMgdG8gZmFsc2UuIElmIHRydWUsIHRoZVxuICAgICAqIGhhbHRlZCBhbmltYXRpb24ncyBjYWxsYmFjayB3b24ndCBmaXJlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBmaXJlZC5cbiAgICAgKi9cbiAgICBfaGFsdEFuaW1hdGlvbihjYW5jZWxDYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgaWYgKCFjYW5jZWxDYWxsYmFjayAmJiB0eXBlb2YgdGhpcy50cmFuc2l0aW9uQ2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5oYWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgLy8gQmx1ciB0aGUgY29udGVudCBpZiB0aGlzLm9wdGlvbnMuYmx1ciBpcyB0cnVlLCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBtb3ZlQmFjay5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVE9ETzogTWFrZSB0aGUgaXRlbSB0byB0byBiZSBibHVyIHNwZWNpZmlhYmxlLCBwZXJoYXBzIHdpdGggYSBtZXRob2Qgb25cbiAgICAgICAgLy8gdGhpcy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ibHVyICYmIHRoaXMub3B0aW9ucy5mYWRlICYmIHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlID09ICdtb3ZlQmFjaycpIHtcbiAgICAgICAgICAgIGxldCBtb21lbnRhcnlCbHVyID0gKHRoaXMuYW5pbWF0aW9uVHJhbnNpdGlvbi5nZXQoKSAqIHRoaXMub3B0aW9ucy5ibHVyUmFkaXVzKVxuICAgICAgICAgICAgbGV0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBcIi13ZWJraXQtZmlsdGVyXCI6ICdibHVyKCcrbW9tZW50YXJ5Qmx1cisncHgpJyxcbiAgICAgICAgICAgICAgICBcIi1tb3otZmlsdGVyXCI6ICAgICdibHVyKCcrbW9tZW50YXJ5Qmx1cisncHgpJyxcbiAgICAgICAgICAgICAgICBcIi1tcy1maWx0ZXJcIjogICAgICdibHVyKCcrbW9tZW50YXJ5Qmx1cisncHgpJyxcbiAgICAgICAgICAgICAgICBcIi1vLWZpbHRlclwiOiAgICAgICdibHVyKCcrbW9tZW50YXJ5Qmx1cisncHgpJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6ICAgICAgICAgICAnYmx1cignK21vbWVudGFyeUJsdXIrJ3B4KSdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyBUT0RPIFRPRE8gdjAuMS4wOiBNYWtlIGZhZGVQbGFuZSBhIHNpYmxpbmcgd2l0aCBtZW51IGFuZFxuICAgICAgICAgICAgLy8gY29udGVudCBtb2xlY3VsZXMgb3IgdGhlIGZvbGxvd2luZyBicmVha3MgaWYgZmFkZSBpcyBmYWxzZS5cbiAgICAgICAgICAgIC8vIFRoZW4gcmVtb3ZlIHRoZSBjaGVjayBmb3IgdGhpcy5vcHRpb25zLmZhZGUgaW4gdGhlIHByZXZpb3VzIGlmXG4gICAgICAgICAgICAvLyBzdGF0ZW1lbnQgYWJvdmUuXG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50TW9sLl9jaGlsZFsxXS5nZXQoKSBpbnN0YW5jZW9mIFN1cmZhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRNb2wuZ2V0KCkuc2V0UHJvcGVydGllcyhmaWx0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRNb2wuX2NoaWxkWzFdIGluc3RhbmNlb2YgUGxhbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRNb2wuX2NoaWxkWzFdLnN1cmZhY2Uuc2V0UHJvcGVydGllcyhmaWx0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIucmVuZGVyKClcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBQdXNoTWVudUxheW91dDtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7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