import {
    createWebGLContext,
    //removeWebGLContext,
    setGlResolution,
    v3,
    m4,
    vertShaderSource,
    fragShaderSource,
    createShader,
    createProgram,
    Cube,
    Quad,
    FourSidedPyramid,
    IsoscelesTriangle,
    SymmetricTrapezoid,
} from './webglUtils'

const updateResolution = state => {
    const resolution = [
        parseFloat(getComputedStyle(state.gl.canvas).width) * window.devicePixelRatio,
        parseFloat(getComputedStyle(state.gl.canvas).height) * window.devicePixelRatio,
        1000,
    ]

    setGlResolution(state.gl, ...resolution)
    state.projectionMatrix = m4.perspective(45, resolution[0] / resolution[1], 1, 2000)
}

class WebGlRenderer {
    /**
     * Creates the WebGL program for the given scene.
     */
    initGl(scene) {
        const gl = createWebGLContext(scene)
        const state = scene.webGlRendererState
        state.gl = gl

        if (!gl) { console.log('You need WebGL.') }

        const vertShader = createShader(gl, gl.VERTEX_SHADER, vertShaderSource)
        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource)
        const program = createProgram(gl, vertShader, fragShader)
        gl.useProgram(program)


        state.colorsBuffer = gl.createBuffer()
        state.colorAttributeLocation = gl.getAttribLocation(program, 'a_color')
        gl.enableVertexAttribArray(state.colorAttributeLocation)

        state.vertexBuffer = gl.createBuffer()
        state.vertexAttributeLocation = gl.getAttribLocation(program, "a_vertexPosition")
        gl.enableVertexAttribArray(state.vertexAttributeLocation)

        state.normalsBuffer = gl.createBuffer()
        state.normalAttributeLocation = gl.getAttribLocation(program, 'a_normal')
        gl.enableVertexAttribArray(state.normalAttributeLocation)

        state.textureCoordinatesBuffer = gl.createBuffer()
        state.textureCoordinateLocation = gl.getAttribLocation(program, 'a_textureCoordinate')

        // cull_face doesn't work, because I've drawn my vertices in the wrong
        // order. They should be clockwise to be front facing (I seem to have done
        // them counter-clockwise). See "CULL_FACE" at
        // https://webglfundamentals.org/webgl/lessons/webgl-3d-orthographic.html
        //gl.enable(gl.CULL_FACE)

        // enables depth sorting, so pixels aren't drawn in order of appearance, but order only if they are visible (on top of other pixels).
        gl.enable(gl.DEPTH_TEST)

        // enable alpha blending (transparency)
        // XXX: For blending (transparency) to work, we have to disable depth testing.
        // TODO: Maybe we have to selectively enable depth testing and disable
        // blending, or vice versa, depending on the object we want to draw...
        // ...Or perhaps we must draw things in a certain order, from back to front,
        // so we can have depth testing AND blending at the same time.
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
        gl.enable(gl.BLEND)
        //gl.disable(gl.DEPTH_TEST)

        state.projectionMatrix = m4.identity

        updateResolution(state)
        scene.on('parentsizechange', () => updateResolution(state))

        state.worldViewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_worldViewProjectionMatrix')
        //const worldInverseTransposeMatrixLocation = gl.getUniformLocation(program, 'u_worldInverseTransposeMatrix')
        state.worldMatrixLocation = gl.getUniformLocation(program, 'u_worldMatrix')
        //const reverseLightDirectionLocation = gl.getUniformLocation(program, 'reverseLightDirection')
        //gl.uniform3fv(reverseLightDirectionLocation, v3.normalize([0.5, 0.7, 1]))
        state.lightWorldPositionLocation = gl.getUniformLocation(program, 'u_lightWorldPosition')
        state.cameraWorldPositionLocation = gl.getUniformLocation(program, 'u_cameraWorldPosition')
        const shininessLocation = gl.getUniformLocation(program, 'u_shininess')
        const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor')
        const specularColorLocation = gl.getUniformLocation(program, 'u_specularColor')
        state.textureLocation = gl.getUniformLocation(program, 'u_texture')
        state.hasTextureLocation = gl.getUniformLocation(program, 'u_hasTexture')

        let shininess = 200
        gl.uniform1f(shininessLocation, shininess)

        const red = [1, 0.6, 0.6]
        const white = [1, 1, 1]

        let lightColor = white
        gl.uniform3fv(lightColorLocation, v3.normalize(lightColor))

        let specularColor = white
        gl.uniform3fv(specularColorLocation, v3.normalize(specularColor))


        state.lightAnimParam = 0
        state.lightWorldPosition = [20,30,50]
        state.cameraAngle = 0
        state.cameraRadius   = 200
    }

    drawScene(scene) {
        const state = scene.webGlRendererState
        var gl = state.gl;

        // TODO: light does not affect the back side of polygons?...
        state.lightAnimParam += 0.05
        state.lightWorldPosition = [
            300*Math.sin(state.lightAnimParam),
            300*Math.sin(state.lightAnimParam*2),

            Math.abs(300*Math.cos(state.lightAnimParam))
            //300
        ]

        gl.uniform3fv(state.lightWorldPositionLocation, state.lightWorldPosition)

        let backgroundColor = scene.getAttribute('background')

        if (typeof backgroundColor == 'string')
            { backgroundColor = backgroundColor.split(' ').map(rgbPart => parseFloat(rgbPart)) }
        else
            { backgroundColor = [0, 0, 0, 0] }

        gl.clearColor(...backgroundColor)
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // why do we need to do this?

        //state.cameraAngle++
        let cameraMatrix  = m4.identity
        cameraMatrix      = m4.multiply(cameraMatrix, m4.yRotation(state.cameraAngle))
        cameraMatrix      = m4.multiply(cameraMatrix, m4.translation(0, 0, state.cameraRadius * 1.5))
        const viewMatrix  = m4.inverse(cameraMatrix)

        state.viewProjectionMatrix = m4.multiply(state.projectionMatrix, viewMatrix)

        const cameraWorldPosition = [cameraMatrix[12], cameraMatrix[13], cameraMatrix[14]]
        gl.uniform3fv(state.cameraWorldPositionLocation, cameraWorldPosition)

        // TODO: we need to use the traversal that takes into consideration ShadowDOM.
        const children = scene.imperativeCounterpart._children
        for (let i=0, l=children.length; i<l; i+=1) {
            this.drawNodeAndRecurse(state, children[i])
        }
    }

    drawNodeAndRecurse(state, node) {
        var gl = state.gl;

        const meshAttr = node.element.getAttribute('mesh')

        if (meshAttr) {
            const size = node._calculatedSize

            const svgElement = Array.from(node.element.children)
                .find(child => child instanceof SVGSVGElement)

            const hasTexture = !!svgElement

            if (meshAttr == 'cube') {
                if (!(node.__shape instanceof Cube))
                    { node.__shape = new Cube(0, 0, size.x) }
                // TODO else, like quad or symtrap
            }
            else if (meshAttr == 'quad') {
                if (!(node.__shape instanceof Quad))
                    { node.__shape = new Quad(size.x, size.y) }
                else {
                    node.__shape.width = size.x
                    node.__shape.height = size.y
                    node.__shape._calcVerts()
                }

                if (hasTexture) {

                    // TODO we would create one per Geometry (and eventually multiple per
                    // geometry), but for now just one texture for all quads to get it working.
                    // TODO Make the texture only once, not each tick.
                    if (!node.__texture) {

                        // XXX this will eventually be set with a texture map feature
                        // TODO: for now, we should at least set default
                        // coordinates for each geometry, even if that's not
                        // ideal; it's more ideal than nothing.
                        node.__shape.textureCoordinates = new Float32Array([
                            0, 0,
                            1, 0,
                            1, 1,
                            1, 1,
                            0, 1,
                            0, 0,
                        ])

                        node.__texture = gl.createTexture()
                    }

                    ///// SVG TEXTURE FROM TWO.JS {
                    if (!node.__two) {
                        node.__two = new Two({
                            type: Two.Types.webgl,
                            fullscreen: false,
                            autostart: false,
                        })

                        node.__two.interpret(svgElement)
                    }

                    node.__two.update()

                    const image = node.__two.renderer.domElement
                    const isPowerOf2 = value => (value & (value - 1)) == 0

                    // copy the pixi canvas image to the texture.
                    gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                    // TODO: unbind from buffers and textures when done
                    // using them, to prevent modification from outside

                    // Mip maps can only be generated on images whose width and height are a power of 2.
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D)
                        // TODO make filters configurable?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                        // Using just NEAREST or LINEAR only can increase performance, for example.
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    }
                    else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                        // TODO make filters configurable?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    }
                    ///// }

                    ///// SVG TEXTURE FROM PIXI-SVG {
                    //if (!node.__pixiRenderer) {
                        //node.__pixiRenderer = PIXI.autoDetectRenderer({

                            //width: node._calculatedSize.x * window.devicePixelRatio,
                            //height: node._calculatedSize.y * window.devicePixelRatio,
                            ////width: 300 * window.devicePixelRatio,
                            ////height: 300 * window.devicePixelRatio,

                            //resolution: window.devicePixelRatio,
                        //});

                        //node.__pixiStage = new PIXI.Container()
                        //window.stage = node.__pixiStage
                    //}

                    //node.__pixiStage.removeChild(node.__svgGraphic)

                    //node.__svgGraphic = new SVG(svgElement)

                    //node.__pixiStage.addChild(node.__svgGraphic)

                    //node.__pixiRenderer.render(node.__pixiStage);

                    //const image = node.__pixiRenderer.view
                    //const isPowerOf2 = value => (value & (value - 1)) == 0

                    //// copy the pixi canvas image to the texture.
                    //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                    //// TODO: unbind from buffers and textures when done
                    //// using them, to prevent modification from outside

                    //// Mip maps can only be generated on images whose width and height are a power of 2.
                    //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        //gl.generateMipmap(gl.TEXTURE_2D)
                        //// TODO make filters configurable?
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                        //// Using just NEAREST or LINEAR only can increase performance, for example.
                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    //}
                    //else {
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                        //// TODO make filters configurable?
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    //}

                    ///// }

                    ///// PRE-DEFINED TEXTURE FROM IMAGE {

                    //// set a temporary solid color texture for the meantime
                    //// while the following texture loads.
                    //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                    //// Fill the texture with a 1x1 blue pixel to start with.
                    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]))
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                    //const image = new Image
                    //const isPowerOf2 = value => (value & (value - 1)) == 0
                    //image.addEventListener('load', () => {
                        //// Now that the image has loaded copy it to the texture.
                        //gl.bindTexture(gl.TEXTURE_2D, node.__texture)
                        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)

                        //// TODO: unbind from buffers and textures when done
                        //// using them, to prevent modification from outside

                        //// Mip maps can only be generated on images whose width and height are a power of 2.
                        //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                            //gl.generateMipmap(gl.TEXTURE_2D)
                            //// TODO make filters configurable?
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)

                            //// Using just NEAREST or LINEAR only can increase performance, for example.
                            ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                            ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                        //}
                        //else {
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                            //// TODO make filters configurable?
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                        //}
                    //})
                    //image.src = imageUrl // imageUrl should be a data URL
                    //// }
                }
            }
            else if (meshAttr == 'isotriangle') {
                if (!(node.__shape instanceof IsoscelesTriangle))
                    { node.__shape = new IsoscelesTriangle(size.x, size.y) }
                // TODO else, like quad or symtrap
            }
            else if (meshAttr == 'pyramid4') {
                if (!(node.__shape instanceof FourSidedPyramid))
                    { node.__shape = new FourSidedPyramid(size.x, size.y) }
                // TODO else, like quad or symtrap
            }
            else if (meshAttr == 'symtrap') {
                if (!(node.__shape instanceof SymmetricTrapezoid))
                    { node.__shape = new SymmetricTrapezoid(size.x/2, size.x, size.y) }
                else {
                    node.__shape.baseWidth = size.x/2
                    node.__shape.topWidth = size.x
                    node.__shape.height = size.y
                    node.__shape._calcVerts()
                }
            }
            //else node.__shape = null
            else {
                if (!(node.__shape instanceof Quad))
                    { node.__shape = new Quad(size.x, size.y) }
                else {
                    node.__shape.width = size.x
                    node.__shape.height = size.y
                    node.__shape._calcVerts()
                }
                // TODO this will eventually be set with a texture map feature
                if (hasTexture) {
                    node.__shape.textureCoordinates = new Float32Array([
                        0, 0,
                        1, 0,
                        1, 1,
                        1, 1,
                        0, 1,
                        0, 0,
                    ])
                }
            }

            if (node.__shape) {
                // COLORS /////////////////////////////////
                node.__shape.color = node.element.getAttribute('color')

                gl.bindBuffer(gl.ARRAY_BUFFER, state.colorsBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, node.__shape._colors, gl.STATIC_DRAW)

                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
                const colorSize = 4          // components per iteration
                const colorType = gl.FLOAT
                const normalizeColorData = false // don't normalize the data
                const colorStride = 0        // 0 = move forward colorSize * sizeof(colorType) each iteration to get the next vertex
                const colorOffset = 0        // start at the beginning of the buffer
                gl.vertexAttribPointer(
                    state.colorAttributeLocation, colorSize, colorType, normalizeColorData, colorStride, colorOffset)

                // VERTICES /////////////////////////////////
                gl.bindBuffer(gl.ARRAY_BUFFER, state.vertexBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, node.__shape.verts, gl.STATIC_DRAW)

                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
                const vertexSize = 3          // components per iteration
                const type = gl.FLOAT
                const normalizeVertexData = false // don't normalize the data
                const stride = 0        // 0 = move forward vertexSize * sizeof(type) each iteration to get the next vertex
                const offset = 0        // start at the beginning of the buffer
                gl.vertexAttribPointer(
                    state.vertexAttributeLocation, vertexSize, type, normalizeVertexData, stride, offset)

                // NORMALS /////////////////////////////////
                gl.bindBuffer(gl.ARRAY_BUFFER, state.normalsBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, node.__shape.normals, gl.STATIC_DRAW)

                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
                const normalSize = 3          // components per iteration
                const normalType = gl.FLOAT
                const normalizeNormalsData = false // don't normalize the data
                const normalStride = 0        // 0 = move forward normalSize * sizeof(normalType) each iteration to get the next vertex
                const normalOffset = 0        // start at the beginning of the buffer
                gl.vertexAttribPointer(
                    state.normalAttributeLocation, normalSize, normalType, normalizeNormalsData, normalStride, normalOffset)

                // TEXTURE COORDINATES /////////////////////////////////
                if (hasTexture) {
                    gl.uniform1i(state.hasTextureLocation, +true)

                    gl.bindBuffer(gl.ARRAY_BUFFER, state.textureCoordinatesBuffer)
                    gl.bufferData(gl.ARRAY_BUFFER, node.__shape.textureCoordinates, gl.STATIC_DRAW)

                    // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)
                    const textureCoordinateSize = 2          // components per iteration
                    const textureCoordinateType = gl.FLOAT
                    const normalizeTextureCoordinateData = false // don't normalize the data
                    const textureCoordinateStride = 0        // 0 = move forward textureCoordinateSize * sizeof(textureCoordinateType) each iteration to get the next vertex
                    const textureCoordinateOffset = 0        // start at the beginning of the buffer
                    gl.enableVertexAttribArray(state.textureCoordinateLocation)
                    gl.vertexAttribPointer(
                        state.textureCoordinateLocation, textureCoordinateSize, textureCoordinateType, normalizeTextureCoordinateData, textureCoordinateStride, textureCoordinateOffset)

                    // Tell the shader to use texture unit 0 for u_texture
                    // TODO: Get index of the node's texture, but right now there's only one texture.
                    gl.uniform1i(state.textureLocation, 0)
                }
                else {
                    gl.uniform1i(state.hasTextureLocation, +false)
                    gl.disableVertexAttribArray(state.textureCoordinateLocation)
                }

                // TRANFORMS /////////////////////////////////
                gl.uniformMatrix4fv(state.worldMatrixLocation, false, node._worldMatrix.toFloat32Array())

                // for correct lighting normals
                // TODO: waiting for transpose() method on DOMMatrix
                //const worldInverseTransposeMatrix = m4.transpose(m4.inverse(node._worldMatrix))
                //gl.uniformMatrix4fv(worldInverseTransposeMatrixLocation, false, worldInverseTransposeMatrix)

                const worldViewProjectionMatrix = m4.multiply(state.viewProjectionMatrix, node._worldMatrix.toFloat32Array())
                gl.uniformMatrix4fv(state.worldViewProjectionMatrixLocation, false, worldViewProjectionMatrix)

                const count = node.__shape.verts.length / 3
                gl.drawArrays(gl.TRIANGLES, offset, count)
            }
        }

        const children = node._children
        for (let i=0, l=children.length; i<l; i+=1) {
            this.drawNodeAndRecurse(state, children[i])
        }
    }
}

let instance = null

export default
function getWebGlRenderer() {
    if (instance) { return instance }
    else { return instance = new WebGlRenderer }
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViR0xSZW5kZXJlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvV2ViR0xSZW5kZXJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGNyZWF0ZVdlYkdMQ29udGV4dCxcbiAgICAvL3JlbW92ZVdlYkdMQ29udGV4dCxcbiAgICBzZXRHbFJlc29sdXRpb24sXG4gICAgdjMsXG4gICAgbTQsXG4gICAgdmVydFNoYWRlclNvdXJjZSxcbiAgICBmcmFnU2hhZGVyU291cmNlLFxuICAgIGNyZWF0ZVNoYWRlcixcbiAgICBjcmVhdGVQcm9ncmFtLFxuICAgIEN1YmUsXG4gICAgUXVhZCxcbiAgICBGb3VyU2lkZWRQeXJhbWlkLFxuICAgIElzb3NjZWxlc1RyaWFuZ2xlLFxuICAgIFN5bW1ldHJpY1RyYXBlem9pZCxcbn0gZnJvbSAnLi93ZWJnbFV0aWxzJ1xuXG5jb25zdCB1cGRhdGVSZXNvbHV0aW9uID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSBbXG4gICAgICAgIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5nbC5jYW52YXMpLndpZHRoKSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZ2wuY2FudmFzKS5oZWlnaHQpICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIDEwMDAsXG4gICAgXVxuXG4gICAgc2V0R2xSZXNvbHV0aW9uKHN0YXRlLmdsLCAuLi5yZXNvbHV0aW9uKVxuICAgIHN0YXRlLnByb2plY3Rpb25NYXRyaXggPSBtNC5wZXJzcGVjdGl2ZSg0NSwgcmVzb2x1dGlvblswXSAvIHJlc29sdXRpb25bMV0sIDEsIDIwMDApXG59XG5cbmNsYXNzIFdlYkdsUmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFdlYkdMIHByb2dyYW0gZm9yIHRoZSBnaXZlbiBzY2VuZS5cbiAgICAgKi9cbiAgICBpbml0R2woc2NlbmUpIHtcbiAgICAgICAgY29uc3QgZ2wgPSBjcmVhdGVXZWJHTENvbnRleHQoc2NlbmUpXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc2NlbmUud2ViR2xSZW5kZXJlclN0YXRlXG4gICAgICAgIHN0YXRlLmdsID0gZ2xcblxuICAgICAgICBpZiAoIWdsKSB7IGNvbnNvbGUubG9nKCdZb3UgbmVlZCBXZWJHTC4nKSB9XG5cbiAgICAgICAgY29uc3QgdmVydFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydFNoYWRlclNvdXJjZSlcbiAgICAgICAgY29uc3QgZnJhZ1NoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnU2hhZGVyU291cmNlKVxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcilcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKVxuXG5cbiAgICAgICAgc3RhdGUuY29sb3JzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgICAgc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJylcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgICAgICBzdGF0ZS52ZXJ0ZXhBdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV92ZXJ0ZXhQb3NpdGlvblwiKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS52ZXJ0ZXhBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS5ub3JtYWxzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgICAgc3RhdGUubm9ybWFsQXR0cmlidXRlTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9ub3JtYWwnKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS5ub3JtYWxBdHRyaWJ1dGVMb2NhdGlvbilcblxuICAgICAgICBzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgICAgICBzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGV4dHVyZUNvb3JkaW5hdGUnKVxuXG4gICAgICAgIC8vIGN1bGxfZmFjZSBkb2Vzbid0IHdvcmssIGJlY2F1c2UgSSd2ZSBkcmF3biBteSB2ZXJ0aWNlcyBpbiB0aGUgd3JvbmdcbiAgICAgICAgLy8gb3JkZXIuIFRoZXkgc2hvdWxkIGJlIGNsb2Nrd2lzZSB0byBiZSBmcm9udCBmYWNpbmcgKEkgc2VlbSB0byBoYXZlIGRvbmVcbiAgICAgICAgLy8gdGhlbSBjb3VudGVyLWNsb2Nrd2lzZSkuIFNlZSBcIkNVTExfRkFDRVwiIGF0XG4gICAgICAgIC8vIGh0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtM2Qtb3J0aG9ncmFwaGljLmh0bWxcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKVxuXG4gICAgICAgIC8vIGVuYWJsZXMgZGVwdGggc29ydGluZywgc28gcGl4ZWxzIGFyZW4ndCBkcmF3biBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLCBidXQgb3JkZXIgb25seSBpZiB0aGV5IGFyZSB2aXNpYmxlIChvbiB0b3Agb2Ygb3RoZXIgcGl4ZWxzKS5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpXG5cbiAgICAgICAgLy8gZW5hYmxlIGFscGhhIGJsZW5kaW5nICh0cmFuc3BhcmVuY3kpXG4gICAgICAgIC8vIFhYWDogRm9yIGJsZW5kaW5nICh0cmFuc3BhcmVuY3kpIHRvIHdvcmssIHdlIGhhdmUgdG8gZGlzYWJsZSBkZXB0aCB0ZXN0aW5nLlxuICAgICAgICAvLyBUT0RPOiBNYXliZSB3ZSBoYXZlIHRvIHNlbGVjdGl2ZWx5IGVuYWJsZSBkZXB0aCB0ZXN0aW5nIGFuZCBkaXNhYmxlXG4gICAgICAgIC8vIGJsZW5kaW5nLCBvciB2aWNlIHZlcnNhLCBkZXBlbmRpbmcgb24gdGhlIG9iamVjdCB3ZSB3YW50IHRvIGRyYXcuLi5cbiAgICAgICAgLy8gLi4uT3IgcGVyaGFwcyB3ZSBtdXN0IGRyYXcgdGhpbmdzIGluIGEgY2VydGFpbiBvcmRlciwgZnJvbSBiYWNrIHRvIGZyb250LFxuICAgICAgICAvLyBzbyB3ZSBjYW4gaGF2ZSBkZXB0aCB0ZXN0aW5nIEFORCBibGVuZGluZyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORClcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpXG5cbiAgICAgICAgc3RhdGUucHJvamVjdGlvbk1hdHJpeCA9IG00LmlkZW50aXR5XG5cbiAgICAgICAgdXBkYXRlUmVzb2x1dGlvbihzdGF0ZSlcbiAgICAgICAgc2NlbmUub24oJ3BhcmVudHNpemVjaGFuZ2UnLCAoKSA9PiB1cGRhdGVSZXNvbHV0aW9uKHN0YXRlKSlcblxuICAgICAgICBzdGF0ZS53b3JsZFZpZXdQcm9qZWN0aW9uTWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfd29ybGRWaWV3UHJvamVjdGlvbk1hdHJpeCcpXG4gICAgICAgIC8vY29uc3Qgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4JylcbiAgICAgICAgc3RhdGUud29ybGRNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV93b3JsZE1hdHJpeCcpXG4gICAgICAgIC8vY29uc3QgcmV2ZXJzZUxpZ2h0RGlyZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3JldmVyc2VMaWdodERpcmVjdGlvbicpXG4gICAgICAgIC8vZ2wudW5pZm9ybTNmdihyZXZlcnNlTGlnaHREaXJlY3Rpb25Mb2NhdGlvbiwgdjMubm9ybWFsaXplKFswLjUsIDAuNywgMV0pKVxuICAgICAgICBzdGF0ZS5saWdodFdvcmxkUG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodFdvcmxkUG9zaXRpb24nKVxuICAgICAgICBzdGF0ZS5jYW1lcmFXb3JsZFBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfY2FtZXJhV29ybGRQb3NpdGlvbicpXG4gICAgICAgIGNvbnN0IHNoaW5pbmVzc0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NoaW5pbmVzcycpXG4gICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodENvbG9yJylcbiAgICAgICAgY29uc3Qgc3BlY3VsYXJDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NwZWN1bGFyQ29sb3InKVxuICAgICAgICBzdGF0ZS50ZXh0dXJlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4dHVyZScpXG4gICAgICAgIHN0YXRlLmhhc1RleHR1cmVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9oYXNUZXh0dXJlJylcblxuICAgICAgICBsZXQgc2hpbmluZXNzID0gMjAwXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGluaW5lc3NMb2NhdGlvbiwgc2hpbmluZXNzKVxuXG4gICAgICAgIGNvbnN0IHJlZCA9IFsxLCAwLjYsIDAuNl1cbiAgICAgICAgY29uc3Qgd2hpdGUgPSBbMSwgMSwgMV1cblxuICAgICAgICBsZXQgbGlnaHRDb2xvciA9IHdoaXRlXG4gICAgICAgIGdsLnVuaWZvcm0zZnYobGlnaHRDb2xvckxvY2F0aW9uLCB2My5ub3JtYWxpemUobGlnaHRDb2xvcikpXG5cbiAgICAgICAgbGV0IHNwZWN1bGFyQ29sb3IgPSB3aGl0ZVxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNwZWN1bGFyQ29sb3JMb2NhdGlvbiwgdjMubm9ybWFsaXplKHNwZWN1bGFyQ29sb3IpKVxuXG5cbiAgICAgICAgc3RhdGUubGlnaHRBbmltUGFyYW0gPSAwXG4gICAgICAgIHN0YXRlLmxpZ2h0V29ybGRQb3NpdGlvbiA9IFsyMCwzMCw1MF1cbiAgICAgICAgc3RhdGUuY2FtZXJhQW5nbGUgPSAwXG4gICAgICAgIHN0YXRlLmNhbWVyYVJhZGl1cyAgID0gMjAwXG4gICAgfVxuXG4gICAgZHJhd1NjZW5lKHNjZW5lKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc2NlbmUud2ViR2xSZW5kZXJlclN0YXRlXG4gICAgICAgIGNvbnN0IHtnbH0gPSBzdGF0ZVxuXG4gICAgICAgIC8vIFRPRE86IGxpZ2h0IGRvZXMgbm90IGFmZmVjdCB0aGUgYmFjayBzaWRlIG9mIHBvbHlnb25zPy4uLlxuICAgICAgICBzdGF0ZS5saWdodEFuaW1QYXJhbSArPSAwLjA1XG4gICAgICAgIHN0YXRlLmxpZ2h0V29ybGRQb3NpdGlvbiA9IFtcbiAgICAgICAgICAgIDMwMCpNYXRoLnNpbihzdGF0ZS5saWdodEFuaW1QYXJhbSksXG4gICAgICAgICAgICAzMDAqTWF0aC5zaW4oc3RhdGUubGlnaHRBbmltUGFyYW0qMiksXG5cbiAgICAgICAgICAgIE1hdGguYWJzKDMwMCpNYXRoLmNvcyhzdGF0ZS5saWdodEFuaW1QYXJhbSkpXG4gICAgICAgICAgICAvLzMwMFxuICAgICAgICBdXG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzdGF0ZS5saWdodFdvcmxkUG9zaXRpb25Mb2NhdGlvbiwgc3RhdGUubGlnaHRXb3JsZFBvc2l0aW9uKVxuXG4gICAgICAgIGxldCBiYWNrZ3JvdW5kQ29sb3IgPSBzY2VuZS5nZXRBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZENvbG9yID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yLnNwbGl0KCcgJykubWFwKHJnYlBhcnQgPT4gcGFyc2VGbG9hdChyZ2JQYXJ0KSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gWzAsIDAsIDAsIDBdXG5cbiAgICAgICAgZ2wuY2xlYXJDb2xvciguLi5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKSAvLyB3aHkgZG8gd2UgbmVlZCB0byBkbyB0aGlzP1xuXG4gICAgICAgIC8vc3RhdGUuY2FtZXJhQW5nbGUrK1xuICAgICAgICBsZXQgY2FtZXJhTWF0cml4ICA9IG00LmlkZW50aXR5XG4gICAgICAgIGNhbWVyYU1hdHJpeCAgICAgID0gbTQubXVsdGlwbHkoY2FtZXJhTWF0cml4LCBtNC55Um90YXRpb24oc3RhdGUuY2FtZXJhQW5nbGUpKVxuICAgICAgICBjYW1lcmFNYXRyaXggICAgICA9IG00Lm11bHRpcGx5KGNhbWVyYU1hdHJpeCwgbTQudHJhbnNsYXRpb24oMCwgMCwgc3RhdGUuY2FtZXJhUmFkaXVzICogMS41KSlcbiAgICAgICAgY29uc3Qgdmlld01hdHJpeCAgPSBtNC5pbnZlcnNlKGNhbWVyYU1hdHJpeClcblxuICAgICAgICBzdGF0ZS52aWV3UHJvamVjdGlvbk1hdHJpeCA9IG00Lm11bHRpcGx5KHN0YXRlLnByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpXG5cbiAgICAgICAgY29uc3QgY2FtZXJhV29ybGRQb3NpdGlvbiA9IFtjYW1lcmFNYXRyaXhbMTJdLCBjYW1lcmFNYXRyaXhbMTNdLCBjYW1lcmFNYXRyaXhbMTRdXVxuICAgICAgICBnbC51bmlmb3JtM2Z2KHN0YXRlLmNhbWVyYVdvcmxkUG9zaXRpb25Mb2NhdGlvbiwgY2FtZXJhV29ybGRQb3NpdGlvbilcblxuICAgICAgICAvLyBUT0RPOiB3ZSBuZWVkIHRvIHVzZSB0aGUgdHJhdmVyc2FsIHRoYXQgdGFrZXMgaW50byBjb25zaWRlcmF0aW9uIFNoYWRvd0RPTS5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzY2VuZS5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX2NoaWxkcmVuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZUFuZFJlY3Vyc2Uoc3RhdGUsIGNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhd05vZGVBbmRSZWN1cnNlKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHtnbH0gPSBzdGF0ZVxuXG4gICAgICAgIGNvbnN0IG1lc2hBdHRyID0gbm9kZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVzaCcpXG5cbiAgICAgICAgaWYgKG1lc2hBdHRyKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gbm9kZS5fY2FsY3VsYXRlZFNpemVcblxuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IEFycmF5LmZyb20obm9kZS5lbGVtZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIC5maW5kKGNoaWxkID0+IGNoaWxkIGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudClcblxuICAgICAgICAgICAgY29uc3QgaGFzVGV4dHVyZSA9ICEhc3ZnRWxlbWVudFxuXG4gICAgICAgICAgICBpZiAobWVzaEF0dHIgPT0gJ2N1YmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZS5fX3NoYXBlIGluc3RhbmNlb2YgQ3ViZSkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBDdWJlKDAsIDAsIHNpemUueClcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGVsc2UsIGxpa2UgcXVhZCBvciBzeW10cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNoQXR0ciA9PSAncXVhZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBRdWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlID0gbmV3IFF1YWQoc2l6ZS54LCBzaXplLnkpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS53aWR0aCA9IHNpemUueFxuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuaGVpZ2h0ID0gc2l6ZS55XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5fY2FsY1ZlcnRzKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd2Ugd291bGQgY3JlYXRlIG9uZSBwZXIgR2VvbWV0cnkgKGFuZCBldmVudHVhbGx5IG11bHRpcGxlIHBlclxuICAgICAgICAgICAgICAgICAgICAvLyBnZW9tZXRyeSksIGJ1dCBmb3Igbm93IGp1c3Qgb25lIHRleHR1cmUgZm9yIGFsbCBxdWFkcyB0byBnZXQgaXQgd29ya2luZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNYWtlIHRoZSB0ZXh0dXJlIG9ubHkgb25jZSwgbm90IGVhY2ggdGljay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLl9fdGV4dHVyZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFggdGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgc2V0IHdpdGggYSB0ZXh0dXJlIG1hcCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB3ZSBzaG91bGQgYXQgbGVhc3Qgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIGZvciBlYWNoIGdlb21ldHJ5LCBldmVuIGlmIHRoYXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkZWFsOyBpdCdzIG1vcmUgaWRlYWwgdGhhbiBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLnRleHR1cmVDb29yZGluYXRlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIFNWRyBURVhUVVJFIEZST00gVFdPLkpTIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLl9fdHdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9fdHdvID0gbmV3IFR3byh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdvLlR5cGVzLndlYmdsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9zdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9fdHdvLmludGVycHJldChzdmdFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3R3by51cGRhdGUoKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbm9kZS5fX3R3by5yZW5kZXJlci5kb21FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUG93ZXJPZjIgPSB2YWx1ZSA9PiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT0gMFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHBpeGkgY2FudmFzIGltYWdlIHRvIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdW5iaW5kIGZyb20gYnVmZmVycyBhbmQgdGV4dHVyZXMgd2hlbiBkb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZW0sIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uIGZyb20gb3V0c2lkZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pcCBtYXBzIGNhbiBvbmx5IGJlIGdlbmVyYXRlZCBvbiBpbWFnZXMgd2hvc2Ugd2lkdGggYW5kIGhlaWdodCBhcmUgYSBwb3dlciBvZiAyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb3dlck9mMihpbWFnZS53aWR0aCkgJiYgaXNQb3dlck9mMihpbWFnZS5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBtYWtlIGZpbHRlcnMgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUilcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcganVzdCBORUFSRVNUIG9yIExJTkVBUiBvbmx5IGNhbiBpbmNyZWFzZSBwZXJmb3JtYW5jZSwgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBmaWx0ZXJzIGNvbmZpZ3VyYWJsZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIH1cblxuICAgICAgICAgICAgICAgICAgICAvLy8vLyBTVkcgVEVYVFVSRSBGUk9NIFBJWEktU1ZHIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoIW5vZGUuX19waXhpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9kZS5fX3BpeGlSZW5kZXJlciA9IFBJWEkuYXV0b0RldGVjdFJlbmRlcmVyKHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2lkdGg6IG5vZGUuX2NhbGN1bGF0ZWRTaXplLnggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hlaWdodDogbm9kZS5fY2FsY3VsYXRlZFNpemUueSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy93aWR0aDogMzAwICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL2hlaWdodDogMzAwICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc29sdXRpb246IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy99KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fcGl4aVN0YWdlID0gbmV3IFBJWEkuQ29udGFpbmVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2luZG93LnN0YWdlID0gbm9kZS5fX3BpeGlTdGFnZVxuICAgICAgICAgICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuX19waXhpU3RhZ2UucmVtb3ZlQ2hpbGQobm9kZS5fX3N2Z0dyYXBoaWMpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fc3ZnR3JhcGhpYyA9IG5ldyBTVkcoc3ZnRWxlbWVudClcblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuX19waXhpU3RhZ2UuYWRkQ2hpbGQobm9kZS5fX3N2Z0dyYXBoaWMpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLl9fcGl4aVJlbmRlcmVyLnJlbmRlcihub2RlLl9fcGl4aVN0YWdlKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGltYWdlID0gbm9kZS5fX3BpeGlSZW5kZXJlci52aWV3XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgaXNQb3dlck9mMiA9IHZhbHVlID0+ICh2YWx1ZSAmICh2YWx1ZSAtIDEpKSA9PSAwXG5cbiAgICAgICAgICAgICAgICAgICAgLy8vLyBjb3B5IHRoZSBwaXhpIGNhbnZhcyBpbWFnZSB0byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSlcblxuICAgICAgICAgICAgICAgICAgICAvLy8vIFRPRE86IHVuYmluZCBmcm9tIGJ1ZmZlcnMgYW5kIHRleHR1cmVzIHdoZW4gZG9uZVxuICAgICAgICAgICAgICAgICAgICAvLy8vIHVzaW5nIHRoZW0sIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uIGZyb20gb3V0c2lkZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gTWlwIG1hcHMgY2FuIG9ubHkgYmUgZ2VuZXJhdGVkIG9uIGltYWdlcyB3aG9zZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIDIuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGlzUG93ZXJPZjIoaW1hZ2Uud2lkdGgpICYmIGlzUG93ZXJPZjIoaW1hZ2UuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUilcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBVc2luZyBqdXN0IE5FQVJFU1Qgb3IgTElORUFSIG9ubHkgY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAvL2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vIH1cblxuICAgICAgICAgICAgICAgICAgICAvLy8vLyBQUkUtREVGSU5FRCBURVhUVVJFIEZST00gSU1BR0Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gc2V0IGEgdGVtcG9yYXJ5IHNvbGlkIGNvbG9yIHRleHR1cmUgZm9yIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICAvLy8vIHdoaWxlIHRoZSBmb2xsb3dpbmcgdGV4dHVyZSBsb2Fkcy5cbiAgICAgICAgICAgICAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBub2RlLl9fdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy8vLyBGaWxsIHRoZSB0ZXh0dXJlIHdpdGggYSAxeDEgYmx1ZSBwaXhlbCB0byBzdGFydCB3aXRoLlxuICAgICAgICAgICAgICAgICAgICAvL2dsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDI1NSwgMjU1XSkpXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBpbWFnZSA9IG5ldyBJbWFnZVxuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGlzUG93ZXJPZjIgPSB2YWx1ZSA9PiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT0gMFxuICAgICAgICAgICAgICAgICAgICAvL2ltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy8vIE5vdyB0aGF0IHRoZSBpbWFnZSBoYXMgbG9hZGVkIGNvcHkgaXQgdG8gdGhlIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG5vZGUuX190ZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPOiB1bmJpbmQgZnJvbSBidWZmZXJzIGFuZCB0ZXh0dXJlcyB3aGVuIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gdXNpbmcgdGhlbSwgdG8gcHJldmVudCBtb2RpZmljYXRpb24gZnJvbSBvdXRzaWRlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gTWlwIG1hcHMgY2FuIG9ubHkgYmUgZ2VuZXJhdGVkIG9uIGltYWdlcyB3aG9zZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIDIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChpc1Bvd2VyT2YyKGltYWdlLndpZHRoKSAmJiBpc1Bvd2VyT2YyKGltYWdlLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBUT0RPIG1ha2UgZmlsdGVycyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLyBVc2luZyBqdXN0IE5FQVJFU1Qgb3IgTElORUFSIG9ubHkgY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8gVE9ETyBtYWtlIGZpbHRlcnMgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgLy99KVxuICAgICAgICAgICAgICAgICAgICAvL2ltYWdlLnNyYyA9IGltYWdlVXJsIC8vIGltYWdlVXJsIHNob3VsZCBiZSBhIGRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgIC8vLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc2hBdHRyID09ICdpc290cmlhbmdsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBJc29zY2VsZXNUcmlhbmdsZSkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBJc29zY2VsZXNUcmlhbmdsZShzaXplLngsIHNpemUueSlcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGVsc2UsIGxpa2UgcXVhZCBvciBzeW10cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNoQXR0ciA9PSAncHlyYW1pZDQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZS5fX3NoYXBlIGluc3RhbmNlb2YgRm91clNpZGVkUHlyYW1pZCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBGb3VyU2lkZWRQeXJhbWlkKHNpemUueCwgc2l6ZS55KVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZWxzZSwgbGlrZSBxdWFkIG9yIHN5bXRyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc2hBdHRyID09ICdzeW10cmFwJykge1xuICAgICAgICAgICAgICAgIGlmICghKG5vZGUuX19zaGFwZSBpbnN0YW5jZW9mIFN5bW1ldHJpY1RyYXBlem9pZCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZSA9IG5ldyBTeW1tZXRyaWNUcmFwZXpvaWQoc2l6ZS54LzIsIHNpemUueCwgc2l6ZS55KVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuYmFzZVdpZHRoID0gc2l6ZS54LzJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLnRvcFdpZHRoID0gc2l6ZS54XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5oZWlnaHQgPSBzaXplLnlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlLl9jYWxjVmVydHMoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZWxzZSBub2RlLl9fc2hhcGUgPSBudWxsXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlLl9fc2hhcGUgaW5zdGFuY2VvZiBRdWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NoYXBlID0gbmV3IFF1YWQoc2l6ZS54LCBzaXplLnkpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS53aWR0aCA9IHNpemUueFxuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUuaGVpZ2h0ID0gc2l6ZS55XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5fY2FsY1ZlcnRzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHdpbGwgZXZlbnR1YWxseSBiZSBzZXQgd2l0aCBhIHRleHR1cmUgbWFwIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2hhcGUudGV4dHVyZUNvb3JkaW5hdGVzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5fX3NoYXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ09MT1JTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIG5vZGUuX19zaGFwZS5jb2xvciA9IG5vZGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbG9yJylcblxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBzdGF0ZS5jb2xvcnNCdWZmZXIpXG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vZGUuX19zaGFwZS5fY29sb3JzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yU2l6ZSA9IDQgICAgICAgICAgLy8gY29tcG9uZW50cyBwZXIgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JUeXBlID0gZ2wuRkxPQVRcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVDb2xvckRhdGEgPSBmYWxzZSAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclN0cmlkZSA9IDAgICAgICAgIC8vIDAgPSBtb3ZlIGZvcndhcmQgY29sb3JTaXplICogc2l6ZW9mKGNvbG9yVHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yT2Zmc2V0ID0gMCAgICAgICAgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29sb3JBdHRyaWJ1dGVMb2NhdGlvbiwgY29sb3JTaXplLCBjb2xvclR5cGUsIG5vcm1hbGl6ZUNvbG9yRGF0YSwgY29sb3JTdHJpZGUsIGNvbG9yT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgLy8gVkVSVElDRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHN0YXRlLnZlcnRleEJ1ZmZlcilcbiAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbm9kZS5fX3NoYXBlLnZlcnRzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleFNpemUgPSAzICAgICAgICAgIC8vIGNvbXBvbmVudHMgcGVyIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnbC5GTE9BVFxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZVZlcnRleERhdGEgPSBmYWxzZSAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpZGUgPSAwICAgICAgICAvLyAwID0gbW92ZSBmb3J3YXJkIHZlcnRleFNpemUgKiBzaXplb2YodHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IDAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZlcnRleEF0dHJpYnV0ZUxvY2F0aW9uLCB2ZXJ0ZXhTaXplLCB0eXBlLCBub3JtYWxpemVWZXJ0ZXhEYXRhLCBzdHJpZGUsIG9mZnNldClcblxuICAgICAgICAgICAgICAgIC8vIE5PUk1BTFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHN0YXRlLm5vcm1hbHNCdWZmZXIpXG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vZGUuX19zaGFwZS5ub3JtYWxzLCBnbC5TVEFUSUNfRFJBVylcblxuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHZlcnRleEJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbFNpemUgPSAzICAgICAgICAgIC8vIGNvbXBvbmVudHMgcGVyIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbFR5cGUgPSBnbC5GTE9BVFxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZU5vcm1hbHNEYXRhID0gZmFsc2UgLy8gZG9uJ3Qgbm9ybWFsaXplIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsU3RyaWRlID0gMCAgICAgICAgLy8gMCA9IG1vdmUgZm9yd2FyZCBub3JtYWxTaXplICogc2l6ZW9mKG5vcm1hbFR5cGUpIGVhY2ggaXRlcmF0aW9uIHRvIGdldCB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxPZmZzZXQgPSAwICAgICAgICAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxBdHRyaWJ1dGVMb2NhdGlvbiwgbm9ybWFsU2l6ZSwgbm9ybWFsVHlwZSwgbm9ybWFsaXplTm9ybWFsc0RhdGEsIG5vcm1hbFN0cmlkZSwgbm9ybWFsT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgLy8gVEVYVFVSRSBDT09SRElOQVRFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoc3RhdGUuaGFzVGV4dHVyZUxvY2F0aW9uLCArdHJ1ZSlcblxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgc3RhdGUudGV4dHVyZUNvb3JkaW5hdGVzQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbm9kZS5fX3NoYXBlLnRleHR1cmVDb29yZGluYXRlcywgZ2wuU1RBVElDX0RSQVcpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCB0aGUgYXR0cmlidXRlIGhvdyB0byBnZXQgZGF0YSBvdXQgb2YgdmVydGV4QnVmZmVyIChBUlJBWV9CVUZGRVIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlU2l6ZSA9IDIgICAgICAgICAgLy8gY29tcG9uZW50cyBwZXIgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlVHlwZSA9IGdsLkZMT0FUXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZVRleHR1cmVDb29yZGluYXRlRGF0YSA9IGZhbHNlIC8vIGRvbid0IG5vcm1hbGl6ZSB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZVN0cmlkZSA9IDAgICAgICAgIC8vIDAgPSBtb3ZlIGZvcndhcmQgdGV4dHVyZUNvb3JkaW5hdGVTaXplICogc2l6ZW9mKHRleHR1cmVDb29yZGluYXRlVHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZU9mZnNldCA9IDAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdGF0ZS50ZXh0dXJlQ29vcmRpbmF0ZUxvY2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4dHVyZUNvb3JkaW5hdGVMb2NhdGlvbiwgdGV4dHVyZUNvb3JkaW5hdGVTaXplLCB0ZXh0dXJlQ29vcmRpbmF0ZVR5cGUsIG5vcm1hbGl6ZVRleHR1cmVDb29yZGluYXRlRGF0YSwgdGV4dHVyZUNvb3JkaW5hdGVTdHJpZGUsIHRleHR1cmVDb29yZGluYXRlT2Zmc2V0KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIHNoYWRlciB0byB1c2UgdGV4dHVyZSB1bml0IDAgZm9yIHVfdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBHZXQgaW5kZXggb2YgdGhlIG5vZGUncyB0ZXh0dXJlLCBidXQgcmlnaHQgbm93IHRoZXJlJ3Mgb25seSBvbmUgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHN0YXRlLnRleHR1cmVMb2NhdGlvbiwgMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzdGF0ZS5oYXNUZXh0dXJlTG9jYXRpb24sICtmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHN0YXRlLnRleHR1cmVDb29yZGluYXRlTG9jYXRpb24pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVFJBTkZPUk1TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc3RhdGUud29ybGRNYXRyaXhMb2NhdGlvbiwgZmFsc2UsIG5vZGUuX3dvcmxkTWF0cml4LnRvRmxvYXQzMkFycmF5KCkpXG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgY29ycmVjdCBsaWdodGluZyBub3JtYWxzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FpdGluZyBmb3IgdHJhbnNwb3NlKCkgbWV0aG9kIG9uIERPTU1hdHJpeFxuICAgICAgICAgICAgICAgIC8vY29uc3Qgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4ID0gbTQudHJhbnNwb3NlKG00LmludmVyc2Uobm9kZS5fd29ybGRNYXRyaXgpKVxuICAgICAgICAgICAgICAgIC8vZ2wudW5pZm9ybU1hdHJpeDRmdih3b3JsZEludmVyc2VUcmFuc3Bvc2VNYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHdvcmxkSW52ZXJzZVRyYW5zcG9zZU1hdHJpeClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmxkVmlld1Byb2plY3Rpb25NYXRyaXggPSBtNC5tdWx0aXBseShzdGF0ZS52aWV3UHJvamVjdGlvbk1hdHJpeCwgbm9kZS5fd29ybGRNYXRyaXgudG9GbG9hdDMyQXJyYXkoKSlcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHN0YXRlLndvcmxkVmlld1Byb2plY3Rpb25NYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHdvcmxkVmlld1Byb2plY3Rpb25NYXRyaXgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IG5vZGUuX19zaGFwZS52ZXJ0cy5sZW5ndGggLyAzXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIG9mZnNldCwgY291bnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuX2NoaWxkcmVuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZUFuZFJlY3Vyc2Uoc3RhdGUsIGNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5sZXQgaW5zdGFuY2UgPSBudWxsXG5cbmV4cG9ydCBkZWZhdWx0XG5mdW5jdGlvbiBnZXRXZWJHbFJlbmRlcmVyKCkge1xuICAgIGlmIChpbnN0YW5jZSkgcmV0dXJuIGluc3RhbmNlXG4gICAgZWxzZSByZXR1cm4gaW5zdGFuY2UgPSBuZXcgV2ViR2xSZW5kZXJlclxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksa0JBQWtCOztJQUVsQixlQUFlO0lBQ2YsRUFBRTtJQUNGLEVBQUU7SUFDRixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWixhQUFhO0lBQ2IsSUFBSTtJQUNKLElBQUk7SUFDSixnQkFBZ0I7SUFDaEIsaUJBQWlCO0lBQ2pCLGtCQUFrQjtPQUNmLGNBQWM7O0FBRXJCLE1BQU0sZ0JBQWdCLEdBQUcsS0FBSyxJQUFJO0lBQzlCLE1BQU0sVUFBVSxHQUFHO1FBQ2YsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLGdCQUFnQjtRQUM3RSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsZ0JBQWdCO1FBQzlFLElBQUk7S0FDUDs7SUFFRCxlQUFlLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLFVBQVUsQ0FBQztJQUN4QyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDO0NBQ3RGOztBQUVELE1BQU0sYUFBYSxDQUFDOzs7O0lBSWhCLE1BQU0sQ0FBQyxLQUFLLEVBQUU7UUFDVixNQUFNLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUM7UUFDcEMsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLGtCQUFrQjtRQUN0QyxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUU7O1FBRWIsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLE9B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