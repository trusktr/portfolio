
// although Transformable is not used in this file, importing it first prevents
// a cyclical dependeny problem when an app entrypoint imports ./Scene.js
// before ./Node.js (Sizeable imports Motor which imports Transformable which
// imports Sizeable). See:
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem
// TODO: write a test that imports public interfaces in every possible
// permutation to detect circular dependency errors.
//
// Transformable is not used in this file, but importing here solves the
// circular dependency problem.
import Transformable from './Transformable'
// Sizeable is used in this file.
import Sizeable from './Sizeable'

import ImperativeBase, {initImperativeBase} from './ImperativeBase'
import XYZValues from './XYZValues'
import HTMLScene from '../html/HTMLScene'
import documentReady from 'awaitbox/dom/documentReady'

initImperativeBase()

// Scene is Sizeable, which is currently a subset of Transformable.
const ParentClass = ImperativeBase.mixin(Sizeable)
class Scene extends ParentClass {
    constructor(options) {
        if ( options === void 0 ) options = {};

        super(options)

        // NOTE: z size is always 0, since native DOM elements are always flat.
        this._elementParentSize = {x:0, y:0, z:0}

        this._onElementParentSizeChange = (newSize) => {
            this._elementParentSize = newSize
            this._calcSize()
            this._needsToBeRendered()
        }

        this._calcSize()
        this._needsToBeRendered()
    }

    _setDefaultProperties() {
        super._setDefaultProperties()

        Object.assign(this._properties, {
            sizeMode: new XYZValues('proportional', 'proportional', 'absolute'),
        })
    }

    _startOrStopSizePolling() {
        if (
            this._mounted &&
            (this._properties.sizeMode.x == 'proportional'
            || this._properties.sizeMode.y == 'proportional'
            || this._properties.sizeMode.z == 'proportional')
        ) {
            this._startSizePolling()
        }
        else {
            this._stopSizePolling()
        }
    }

    // observe size changes on the scene element.
    _startSizePolling() {
        if (!this._elementManager) { return }
        this._elementManager.element._startSizePolling()
        this._elementManager.element.on('parentsizechange', this._onElementParentSizeChange)
    }

    // Don't observe size changes on the scene element.
    _stopSizePolling() {
        if (!this._elementManager) { return }
        this._elementManager.element.off('parentsizechange', this._onElementParentSizeChange)
        this._elementManager.element._stopSizePolling()
    }

    /** @override */
    _getParentSize() {
        return this._mounted ? this._elementParentSize : {x:0,y:0,z:0}
    }

    /**
     * @override
     */
    _makeElement() {
        return new HTMLScene
    }

    /**
     * Mount the scene into the given target.
     * Resolves the Scene's mountPromise, which can be use to do something once
     * the scene is mounted.
     *
     * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,
     * the mount point will be selected from the DOM. If an HTMLElement is
     * provided, that will be the mount point. If no mount point is provided,
     * the scene will be mounted into document.body.
     */
    mount(mountPoint) {
        const mountLogic = () => {
            // if no mountPoint was provided, just mount onto the <body> element.
            if (mountPoint === undefined) { mountPoint = document.body }

            // if the user supplied a selector, mount there.
            else if (typeof mountPoint === 'string')
                { mountPoint = document.querySelector(mountPoint) }

            // if we have an actual mount point (the user may have supplied one)
            if (!(mountPoint instanceof window.HTMLElement))
                { throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.') }

            if (this._mounted) { this.unmount() }

            if (mountPoint !== this._elementManager.element.parentNode)
                { mountPoint.appendChild(this._elementManager.element) }

            this._mounted = true

            if (this._mountPromise) { this._resolveMountPromise() }

            this._elementManager.shouldRender()
            this._startOrStopSizePolling()
        }

        // Wait for the document to be ready before mounting, otherwise the
        // target mount point might not exist yet when this function is called.
        if (document.readyState == 'loading') { return documentReady().then(mountLogic) }
        else {
            mountLogic()
            return Promise.resolve()
        }
    }
    //async mount(mountPoint) {
        //// Wait for the document to be ready before mounting, otherwise the
        //// target mount point might not exist yet when this function is called.
        //if (document.readyState == 'loading') await documentReady()

        //// if no mountPoint was provided, just mount onto the <body> element.
        //if (mountPoint === undefined) mountPoint = document.body

        //// if the user supplied a selector, mount there.
        //else if (typeof mountPoint === 'string')
            //mountPoint = document.querySelector(mountPoint)

        //// if we have an actual mount point (the user may have supplied one)
        //if (!(mountPoint instanceof window.HTMLElement))
            //throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.')

        //if (this._mounted) this.unmount()

        //if (mountPoint !== this._elementManager.element.parentNode)
            //mountPoint.appendChild(this._elementManager.element)

        //this._mounted = true

        //if (this._mountPromise) this._resolveMountPromise()

        //this._elementManager.shouldRender()
        //this._startOrStopSizePolling()
    //}

    /**
     * Unmount the scene from it's mount point. Resets the Scene's
     * mountPromise.
     */
    unmount() {
        if (!this._mounted) { return }

        this._elementManager.shouldNotRender()
        this._stopSizePolling()

        if (this._elementManager.element.parentNode)
            { this._elementManager.element.parentNode.removeChild(this._elementManager.element) }

        if (this._mountPromise) { this._rejectMountPromise('mountcancel') }
        this._resetMountPromise()
    }

}

// Here we know that `super` is Sizeable
var ref = Object.getOwnPropertyDescriptor(Sizeable.prototype, 'sizeMode');
var superSizeModeSet = ref.set;
var superSizeModeGet = ref.get;

Object.defineProperties(Scene.prototype, {

    // When we set the scene's size mode, we should start polling if it has
    // proportional sizing.
    sizeMode: {
        set: function(value) {
            superSizeModeSet.call(this, value)
            this._startOrStopSizePolling()
        },
        get: function() {
            return superSizeModeGet.call(this)
        },
        configurable: true,
        enumerable: true,
    }

})

export {Scene as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NlbmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1NjZW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLy8gYWx0aG91Z2ggVHJhbnNmb3JtYWJsZSBpcyBub3QgdXNlZCBpbiB0aGlzIGZpbGUsIGltcG9ydGluZyBpdCBmaXJzdCBwcmV2ZW50c1xuLy8gYSBjeWNsaWNhbCBkZXBlbmRlbnkgcHJvYmxlbSB3aGVuIGFuIGFwcCBlbnRyeXBvaW50IGltcG9ydHMgLi9TY2VuZS5qc1xuLy8gYmVmb3JlIC4vTm9kZS5qcyAoU2l6ZWFibGUgaW1wb3J0cyBNb3RvciB3aGljaCBpbXBvcnRzIFRyYW5zZm9ybWFibGUgd2hpY2hcbi8vIGltcG9ydHMgU2l6ZWFibGUpLiBTZWU6XG4vLyBodHRwczovL2VzZGlzY3Vzcy5vcmcvdG9waWMvaG93LXRvLXNvbHZlLXRoaXMtYmFzaWMtZXM2LW1vZHVsZS1jaXJjdWxhci1kZXBlbmRlbmN5LXByb2JsZW1cbi8vIFRPRE86IHdyaXRlIGEgdGVzdCB0aGF0IGltcG9ydHMgcHVibGljIGludGVyZmFjZXMgaW4gZXZlcnkgcG9zc2libGVcbi8vIHBlcm11dGF0aW9uIHRvIGRldGVjdCBjaXJjdWxhciBkZXBlbmRlbmN5IGVycm9ycy5cbi8vXG4vLyBUcmFuc2Zvcm1hYmxlIGlzIG5vdCB1c2VkIGluIHRoaXMgZmlsZSwgYnV0IGltcG9ydGluZyBoZXJlIHNvbHZlcyB0aGVcbi8vIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbS5cbmltcG9ydCBUcmFuc2Zvcm1hYmxlIGZyb20gJy4vVHJhbnNmb3JtYWJsZSdcbi8vIFNpemVhYmxlIGlzIHVzZWQgaW4gdGhpcyBmaWxlLlxuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4vU2l6ZWFibGUnXG5cbmltcG9ydCBJbXBlcmF0aXZlQmFzZSwge2luaXRJbXBlcmF0aXZlQmFzZX0gZnJvbSAnLi9JbXBlcmF0aXZlQmFzZSdcbmltcG9ydCBYWVpWYWx1ZXMgZnJvbSAnLi9YWVpWYWx1ZXMnXG5pbXBvcnQgSFRNTFNjZW5lIGZyb20gJy4uL2h0bWwvSFRNTFNjZW5lJ1xuaW1wb3J0IGRvY3VtZW50UmVhZHkgZnJvbSAnYXdhaXRib3gvZG9tL2RvY3VtZW50UmVhZHknXG5cbmluaXRJbXBlcmF0aXZlQmFzZSgpXG5cbi8vIFNjZW5lIGlzIFNpemVhYmxlLCB3aGljaCBpcyBjdXJyZW50bHkgYSBzdWJzZXQgb2YgVHJhbnNmb3JtYWJsZS5cbmNvbnN0IFBhcmVudENsYXNzID0gSW1wZXJhdGl2ZUJhc2UubWl4aW4oU2l6ZWFibGUpXG5jbGFzcyBTY2VuZSBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucylcblxuICAgICAgICAvLyBOT1RFOiB6IHNpemUgaXMgYWx3YXlzIDAsIHNpbmNlIG5hdGl2ZSBET00gZWxlbWVudHMgYXJlIGFsd2F5cyBmbGF0LlxuICAgICAgICB0aGlzLl9lbGVtZW50UGFyZW50U2l6ZSA9IHt4OjAsIHk6MCwgejowfVxuXG4gICAgICAgIHRoaXMuX29uRWxlbWVudFBhcmVudFNpemVDaGFuZ2UgPSAobmV3U2l6ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFBhcmVudFNpemUgPSBuZXdTaXplXG4gICAgICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1RvQmVSZW5kZXJlZCgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpXG4gICAgICAgIHRoaXMuX25lZWRzVG9CZVJlbmRlcmVkKClcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9zZXREZWZhdWx0UHJvcGVydGllcygpXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBzaXplTW9kZTogbmV3IFhZWlZhbHVlcygncHJvcG9ydGlvbmFsJywgJ3Byb3BvcnRpb25hbCcsICdhYnNvbHV0ZScpLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIF9zdGFydE9yU3RvcFNpemVQb2xsaW5nKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9tb3VudGVkICYmXG4gICAgICAgICAgICAodGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS54ID09ICdwcm9wb3J0aW9uYWwnXG4gICAgICAgICAgICB8fCB0aGlzLl9wcm9wZXJ0aWVzLnNpemVNb2RlLnkgPT0gJ3Byb3BvcnRpb25hbCdcbiAgICAgICAgICAgIHx8IHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGUueiA9PSAncHJvcG9ydGlvbmFsJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFNpemVQb2xsaW5nKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BTaXplUG9sbGluZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvYnNlcnZlIHNpemUgY2hhbmdlcyBvbiB0aGUgc2NlbmUgZWxlbWVudC5cbiAgICBfc3RhcnRTaXplUG9sbGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50TWFuYWdlcikgcmV0dXJuXG4gICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQuX3N0YXJ0U2l6ZVBvbGxpbmcoKVxuICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50Lm9uKCdwYXJlbnRzaXplY2hhbmdlJywgdGhpcy5fb25FbGVtZW50UGFyZW50U2l6ZUNoYW5nZSlcbiAgICB9XG5cbiAgICAvLyBEb24ndCBvYnNlcnZlIHNpemUgY2hhbmdlcyBvbiB0aGUgc2NlbmUgZWxlbWVudC5cbiAgICBfc3RvcFNpemVQb2xsaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRNYW5hZ2VyKSByZXR1cm5cbiAgICAgICAgdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudC5vZmYoJ3BhcmVudHNpemVjaGFuZ2UnLCB0aGlzLl9vbkVsZW1lbnRQYXJlbnRTaXplQ2hhbmdlKVxuICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50Ll9zdG9wU2l6ZVBvbGxpbmcoKVxuICAgIH1cblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBfZ2V0UGFyZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdW50ZWQgPyB0aGlzLl9lbGVtZW50UGFyZW50U2l6ZSA6IHt4OjAseTowLHo6MH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFRNTFNjZW5lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91bnQgdGhlIHNjZW5lIGludG8gdGhlIGdpdmVuIHRhcmdldC5cbiAgICAgKiBSZXNvbHZlcyB0aGUgU2NlbmUncyBtb3VudFByb21pc2UsIHdoaWNoIGNhbiBiZSB1c2UgdG8gZG8gc29tZXRoaW5nIG9uY2VcbiAgICAgKiB0aGUgc2NlbmUgaXMgbW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbbW91bnRQb2ludD1kb2N1bWVudC5ib2R5XSBJZiBhIHN0cmluZyBzZWxlY3RvciBpcyBwcm92aWRlZCxcbiAgICAgKiB0aGUgbW91bnQgcG9pbnQgd2lsbCBiZSBzZWxlY3RlZCBmcm9tIHRoZSBET00uIElmIGFuIEhUTUxFbGVtZW50IGlzXG4gICAgICogcHJvdmlkZWQsIHRoYXQgd2lsbCBiZSB0aGUgbW91bnQgcG9pbnQuIElmIG5vIG1vdW50IHBvaW50IGlzIHByb3ZpZGVkLFxuICAgICAqIHRoZSBzY2VuZSB3aWxsIGJlIG1vdW50ZWQgaW50byBkb2N1bWVudC5ib2R5LlxuICAgICAqL1xuICAgIG1vdW50KG1vdW50UG9pbnQpIHtcbiAgICAgICAgY29uc3QgbW91bnRMb2dpYyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vIG1vdW50UG9pbnQgd2FzIHByb3ZpZGVkLCBqdXN0IG1vdW50IG9udG8gdGhlIDxib2R5PiBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKG1vdW50UG9pbnQgPT09IHVuZGVmaW5lZCkgbW91bnRQb2ludCA9IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBzZWxlY3RvciwgbW91bnQgdGhlcmUuXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW91bnRQb2ludCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgbW91bnRQb2ludCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobW91bnRQb2ludClcblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBhY3R1YWwgbW91bnQgcG9pbnQgKHRoZSB1c2VyIG1heSBoYXZlIHN1cHBsaWVkIG9uZSlcbiAgICAgICAgICAgIGlmICghKG1vdW50UG9pbnQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb3VudCBwb2ludCBzcGVjaWZpZWQgaW4gU2NlbmUubW91bnQoKSBjYWxsLiBQYXNzIGEgc2VsZWN0b3IsIGFuIGFjdHVhbCBIVE1MRWxlbWVudCwgb3IgZG9uXFwndCBwYXNzIGFueXRoaW5nIHRvIG1vdW50IHRvIDxib2R5Pi4nKVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fbW91bnRlZCkgdGhpcy51bm1vdW50KClcblxuICAgICAgICAgICAgaWYgKG1vdW50UG9pbnQgIT09IHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBtb3VudFBvaW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQpXG5cbiAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3VudFByb21pc2UpIHRoaXMuX3Jlc29sdmVNb3VudFByb21pc2UoKVxuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGRSZW5kZXIoKVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRPclN0b3BTaXplUG9sbGluZygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZHkgYmVmb3JlIG1vdW50aW5nLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vIHRhcmdldCBtb3VudCBwb2ludCBtaWdodCBub3QgZXhpc3QgeWV0IHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09ICdsb2FkaW5nJykgcmV0dXJuIGRvY3VtZW50UmVhZHkoKS50aGVuKG1vdW50TG9naWMpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW91bnRMb2dpYygpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2FzeW5jIG1vdW50KG1vdW50UG9pbnQpIHtcbiAgICAgICAgLy8vLyBXYWl0IGZvciB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZHkgYmVmb3JlIG1vdW50aW5nLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vLy8gdGFyZ2V0IG1vdW50IHBvaW50IG1pZ2h0IG5vdCBleGlzdCB5ZXQgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICAgICAgLy9pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnbG9hZGluZycpIGF3YWl0IGRvY3VtZW50UmVhZHkoKVxuXG4gICAgICAgIC8vLy8gaWYgbm8gbW91bnRQb2ludCB3YXMgcHJvdmlkZWQsIGp1c3QgbW91bnQgb250byB0aGUgPGJvZHk+IGVsZW1lbnQuXG4gICAgICAgIC8vaWYgKG1vdW50UG9pbnQgPT09IHVuZGVmaW5lZCkgbW91bnRQb2ludCA9IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAvLy8vIGlmIHRoZSB1c2VyIHN1cHBsaWVkIGEgc2VsZWN0b3IsIG1vdW50IHRoZXJlLlxuICAgICAgICAvL2Vsc2UgaWYgKHR5cGVvZiBtb3VudFBvaW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC8vbW91bnRQb2ludCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobW91bnRQb2ludClcblxuICAgICAgICAvLy8vIGlmIHdlIGhhdmUgYW4gYWN0dWFsIG1vdW50IHBvaW50ICh0aGUgdXNlciBtYXkgaGF2ZSBzdXBwbGllZCBvbmUpXG4gICAgICAgIC8vaWYgKCEobW91bnRQb2ludCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBtb3VudCBwb2ludCBzcGVjaWZpZWQgaW4gU2NlbmUubW91bnQoKSBjYWxsLiBQYXNzIGEgc2VsZWN0b3IsIGFuIGFjdHVhbCBIVE1MRWxlbWVudCwgb3IgZG9uXFwndCBwYXNzIGFueXRoaW5nIHRvIG1vdW50IHRvIDxib2R5Pi4nKVxuXG4gICAgICAgIC8vaWYgKHRoaXMuX21vdW50ZWQpIHRoaXMudW5tb3VudCgpXG5cbiAgICAgICAgLy9pZiAobW91bnRQb2ludCAhPT0gdGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLy9tb3VudFBvaW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQpXG5cbiAgICAgICAgLy90aGlzLl9tb3VudGVkID0gdHJ1ZVxuXG4gICAgICAgIC8vaWYgKHRoaXMuX21vdW50UHJvbWlzZSkgdGhpcy5fcmVzb2x2ZU1vdW50UHJvbWlzZSgpXG5cbiAgICAgICAgLy90aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGRSZW5kZXIoKVxuICAgICAgICAvL3RoaXMuX3N0YXJ0T3JTdG9wU2l6ZVBvbGxpbmcoKVxuICAgIC8vfVxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudCB0aGUgc2NlbmUgZnJvbSBpdCdzIG1vdW50IHBvaW50LiBSZXNldHMgdGhlIFNjZW5lJ3NcbiAgICAgKiBtb3VudFByb21pc2UuXG4gICAgICovXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3VudGVkKSByZXR1cm5cblxuICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5zaG91bGROb3RSZW5kZXIoKVxuICAgICAgICB0aGlzLl9zdG9wU2l6ZVBvbGxpbmcoKVxuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50TWFuYWdlci5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudE1hbmFnZXIuZWxlbWVudClcblxuICAgICAgICBpZiAodGhpcy5fbW91bnRQcm9taXNlKSB0aGlzLl9yZWplY3RNb3VudFByb21pc2UoJ21vdW50Y2FuY2VsJylcbiAgICAgICAgdGhpcy5fcmVzZXRNb3VudFByb21pc2UoKVxuICAgIH1cblxufVxuXG4vLyBIZXJlIHdlIGtub3cgdGhhdCBgc3VwZXJgIGlzIFNpemVhYmxlXG5jb25zdCB7c2V0OiBzdXBlclNpemVNb2RlU2V0LCBnZXQ6IHN1cGVyU2l6ZU1vZGVHZXR9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTaXplYWJsZS5wcm90b3R5cGUsICdzaXplTW9kZScpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNjZW5lLnByb3RvdHlwZSwge1xuXG4gICAgLy8gV2hlbiB3ZSBzZXQgdGhlIHNjZW5lJ3Mgc2l6ZSBtb2RlLCB3ZSBzaG91bGQgc3RhcnQgcG9sbGluZyBpZiBpdCBoYXNcbiAgICAvLyBwcm9wb3J0aW9uYWwgc2l6aW5nLlxuICAgIHNpemVNb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHN1cGVyU2l6ZU1vZGVTZXQuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T3JTdG9wU2l6ZVBvbGxpbmcoKVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2l6ZU1vZGVHZXQuY2FsbCh0aGlzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxuXG59KVxuXG5leHBvcnQge1NjZW5lIGFzIGRlZmF1bHR9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBV0EsT0FBTyxhQUFhLE1BQU0saUJBQWlCOztBQUUzQyxPQUFPLFFBQVEsTUFBTSxZQUFZOztBQUVqQyxPQUFPLGNBQWMsR0FBRyxrQkFBa0IsT0FBTyxrQkFBa0I7QUFDbkUsT0FBTyxTQUFTLE1BQU0sYUFBYTtBQUNuQyxPQUFPLFNBQVMsTUFBTSxtQkFBbUI7QUFDekMsT0FBTyxhQUFhLE1BQU0sNEJBQTRCOztBQUV0RCxrQkFBa0IsRUFBRTs7O0FBR3BCLE1BQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0FBQ2xELE1BQU0sS0FBSyxTQUFTLFdBQVcsQ0FBQztJQUM1QixXQUFXLENBQUMsT0FBWSxFQUFFLENBQVA7eUNBQUEsR0FBRyxFQUFFO0FBQUc7UUFDdkIsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7O1FBR2QsSUFBSSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBRXpDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxDQUFDLE9BQU8sS0FBSztZQUMzQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsT0FBTztZQUNqQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtTQUM1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