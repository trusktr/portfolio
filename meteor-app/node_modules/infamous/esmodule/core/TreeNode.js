import {isInstanceof} from './Utility'

const instanceofSymbol = Symbol('instanceofSymbol')

const TreeNodeMixin = base => {
    class TreeNode extends base {

        constructor(options) {
            if ( options === void 0 ) options = {};

            super(options)
            this._parent = null // default to no parent.
            this._children = [];
        }

        /**
         * this._parent is protected (node's can access other node._parent).
         * The user should use the addChild methods, which automatically handles
         * setting a parent.
         *
         * @readonly
         */
        get parent() {
            return this._parent
        }

        /**
         * @readonly
         */
        get children() {
            // return a new array, so that the user modifying it doesn't affect
            // this node's actual children.
            return [...this._children]
        }

        /**
         * Add a child node to this TreeNode.
         *
         * @param {TreeNode} childNode The child node to add.
         */
        addChild (childNode) {
            if (! isInstanceof(childNode, TreeNode))
                { throw new TypeError('TreeNode.addChild expects the childNode argument to be a TreeNode instance.') }

            if (childNode._parent === this)
                { throw new ReferenceError('childNode is already a child of this parent.') }

            if (childNode._parent)
                { childNode._parent.removeChild(childNode) }

            childNode._parent = this;

            this._children.push(childNode);

            return this
        }

        /**
         * Add all the child nodes in the given array to this node.
         *
         * @param {Array.TreeNode} nodes The nodes to add.
         */
        addChildren(nodes) {
            nodes.forEach(node => this.addChild(node))
            return this
        }

        /**
         * Remove a child node from this node.
         *
         * @param {TreeNode} childNode The node to remove.
         */
        removeChild(childNode) {
            if (! isInstanceof(childNode, TreeNode))
                { throw new Error(`
                    TreeNode.removeChild expects the childNode argument to be an
                    instance of TreeNode. There should only be TreeNodes in the
                    tree.
                `) }

            if (childNode._parent !== this)
                { throw new ReferenceError('childNode is not a child of this parent.') }

            childNode._parent = null
            this._children.splice(this._children.indexOf(childNode), 1);

            return this
        }

        /**
         * Remove all the child nodes in the given array from this node.
         *
         * @param {Array.TreeNode} nodes The nodes to remove.
         */
        removeChildren(nodes) {
            nodes.forEach(node => this.removeChild(node))
            return this
        }

        /**
         * Shortcut to remove all children.
         */
        removeAllChildren() {
            this.removeChildren(this._children)
            return this
        }

        /**
         * @readonly
         * @return {number} How many children this TreeNode has.
         */
        get childCount() {
            return this._children.length
        }
    }

    Object.defineProperty(TreeNode, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== TreeNode) { return Object.getPrototypeOf(TreeNode)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    TreeNode[instanceofSymbol] = true

    return TreeNode
}

const TreeNode = TreeNodeMixin(class{})
TreeNode.mixin = TreeNodeMixin

export {TreeNode as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJlZU5vZGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1RyZWVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNJbnN0YW5jZW9mfSBmcm9tICcuL1V0aWxpdHknXG5cbmNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG5jb25zdCBUcmVlTm9kZU1peGluID0gYmFzZSA9PiB7XG4gICAgY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsIC8vIGRlZmF1bHQgdG8gbm8gcGFyZW50LlxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzLl9wYXJlbnQgaXMgcHJvdGVjdGVkIChub2RlJ3MgY2FuIGFjY2VzcyBvdGhlciBub2RlLl9wYXJlbnQpLlxuICAgICAgICAgKiBUaGUgdXNlciBzaG91bGQgdXNlIHRoZSBhZGRDaGlsZCBtZXRob2RzLCB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXNcbiAgICAgICAgICogc2V0dGluZyBhIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGFycmF5LCBzbyB0aGF0IHRoZSB1c2VyIG1vZGlmeWluZyBpdCBkb2Vzbid0IGFmZmVjdFxuICAgICAgICAgICAgLy8gdGhpcyBub2RlJ3MgYWN0dWFsIGNoaWxkcmVuLlxuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9jaGlsZHJlbl1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjaGlsZCBub2RlIHRvIHRoaXMgVHJlZU5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkTm9kZSBUaGUgY2hpbGQgbm9kZSB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDaGlsZCAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAoISBpc0luc3RhbmNlb2YoY2hpbGROb2RlLCBUcmVlTm9kZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJlZU5vZGUuYWRkQ2hpbGQgZXhwZWN0cyB0aGUgY2hpbGROb2RlIGFyZ3VtZW50IHRvIGJlIGEgVHJlZU5vZGUgaW5zdGFuY2UuJylcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5fcGFyZW50ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignY2hpbGROb2RlIGlzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHBhcmVudC4nKVxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKVxuXG4gICAgICAgICAgICBjaGlsZE5vZGUuX3BhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGROb2RlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYWxsIHRoZSBjaGlsZCBub2RlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdG8gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LlRyZWVOb2RlfSBub2RlcyBUaGUgbm9kZXMgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2hpbGRyZW4obm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLmFkZENoaWxkKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBjaGlsZCBub2RlIGZyb20gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZE5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAoISBpc0luc3RhbmNlb2YoY2hpbGROb2RlLCBUcmVlTm9kZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgICAgICAgICAgICAgVHJlZU5vZGUucmVtb3ZlQ2hpbGQgZXhwZWN0cyB0aGUgY2hpbGROb2RlIGFyZ3VtZW50IHRvIGJlIGFuXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlIG9mIFRyZWVOb2RlLiBUaGVyZSBzaG91bGQgb25seSBiZSBUcmVlTm9kZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIHRyZWUuXG4gICAgICAgICAgICAgICAgYClcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5fcGFyZW50ICE9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignY2hpbGROb2RlIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgcGFyZW50LicpXG5cbiAgICAgICAgICAgIGNoaWxkTm9kZS5fcGFyZW50ID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKHRoaXMuX2NoaWxkcmVuLmluZGV4T2YoY2hpbGROb2RlKSwgMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCB0aGUgY2hpbGQgbm9kZXMgaW4gdGhlIGdpdmVuIGFycmF5IGZyb20gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LlRyZWVOb2RlfSBub2RlcyBUaGUgbm9kZXMgdG8gcmVtb3ZlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4obm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byByZW1vdmUgYWxsIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBIb3cgbWFueSBjaGlsZHJlbiB0aGlzIFRyZWVOb2RlIGhhcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjaGlsZENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVOb2RlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKHRoaXMgIT09IFRyZWVOb2RlKSByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyZWVOb2RlKVtTeW1ib2wuaGFzSW5zdGFuY2VdLmNhbGwodGhpcywgb2JqKVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFByb3RvID0gb2JqXG5cbiAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRQcm90bykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRQcm90bywgXCJjb25zdHJ1Y3RvclwiKVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy52YWx1ZSAmJiBkZXNjLnZhbHVlLmhhc093blByb3BlcnR5KGluc3RhbmNlb2ZTeW1ib2wpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgY3VycmVudFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRQcm90bylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgVHJlZU5vZGVbaW5zdGFuY2VvZlN5bWJvbF0gPSB0cnVlXG5cbiAgICByZXR1cm4gVHJlZU5vZGVcbn1cblxuY29uc3QgVHJlZU5vZGUgPSBUcmVlTm9kZU1peGluKGNsYXNze30pXG5UcmVlTm9kZS5taXhpbiA9IFRyZWVOb2RlTWl4aW5cblxuZXhwb3J0IHtUcmVlTm9kZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFFBQVEsWUFBWSxPQUFPLFdBQVc7O0FBRXRDLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDOztBQUVuRCxNQUFNLGFBQWEsR0FBRyxJQUFJLElBQUk7SUFDMUIsTUFBTSxRQUFRLFNBQVMsSUFBSSxDQUFDOztRQUV4QixXQUFXLENBQUMsT0FBWSxFQUFFLENBQVA7NkNBQUEsR0FBRyxFQUFFO0FBQUc7WUFDdkIsS0FBSyxDQUFDLE9B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