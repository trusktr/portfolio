import {isInstanceof} from './Utility'

const instanceofSymbol = Symbol('instanceofSymbol')

const TreeNodeMixin = function (base) {
    var TreeNode = (function (base) {
        function TreeNode(options) {
            if ( options === void 0 ) options = {};

            base.call(this, options)
            this._parent = null // default to no parent.
            this._children = [];
        }

        if ( base ) TreeNode.__proto__ = base;
        TreeNode.prototype = Object.create( base && base.prototype );
        TreeNode.prototype.constructor = TreeNode;

        var prototypeAccessors = { parent: {},children: {},childCount: {} };

        /**
         * this._parent is protected (node's can access other node._parent).
         * The user should use the addChild methods, which automatically handles
         * setting a parent.
         *
         * @readonly
         */
        prototypeAccessors.parent.get = function () {
            return this._parent
        };

        /**
         * @readonly
         */
        prototypeAccessors.children.get = function () {
            // return a new array, so that the user modifying it doesn't affect
            // this node's actual children.
            return [].concat( this._children )
        };

        /**
         * Add a child node to this TreeNode.
         *
         * @param {TreeNode} childNode The child node to add.
         */
        TreeNode.prototype.addChild = function addChild (childNode) {

            if (! isInstanceof(childNode, TreeNode))
                { throw new TypeError('TreeNode.addChild expects the childNode argument to be a TreeNode instance.') }

            if (childNode._parent === this)
                { throw new ReferenceError('childNode is already a child of this parent.') }

            if (childNode._parent)
                { childNode._parent.removeChild(childNode) }

            childNode._parent = this;

            this._children.push(childNode);

            return this
        };

        /**
         * Add all the child nodes in the given array to this node.
         *
         * @param {Array.TreeNode} nodes The nodes to add.
         */
        TreeNode.prototype.addChildren = function addChildren (nodes) {
            var this$1 = this;

            nodes.forEach(function (node) { return this$1.addChild(node); })
            return this
        };

        /**
         * Remove a child node from this node.
         *
         * @param {TreeNode} childNode The node to remove.
         */
        TreeNode.prototype.removeChild = function removeChild (childNode) {
            if (! isInstanceof(childNode, TreeNode))
                { throw new Error("\n                    TreeNode.removeChild expects the childNode argument to be an\n                    instance of TreeNode. There should only be TreeNodes in the\n                    tree.\n                ") }

            if (childNode._parent !== this)
                { throw new ReferenceError('childNode is not a child of this parent.') }

            childNode._parent = null
            this._children.splice(this._children.indexOf(childNode), 1);

            return this
        };

        /**
         * Remove all the child nodes in the given array from this node.
         *
         * @param {Array.TreeNode} nodes The nodes to remove.
         */
        TreeNode.prototype.removeChildren = function removeChildren (nodes) {
            var this$1 = this;

            nodes.forEach(function (node) { return this$1.removeChild(node); })
            return this
        };

        /**
         * Shortcut to remove all children.
         */
        TreeNode.prototype.removeAllChildren = function removeAllChildren () {
            this.removeChildren(this._children)
            return this
        };

        /**
         * @readonly
         * @return {number} How many children this TreeNode has.
         */
        prototypeAccessors.childCount.get = function () {
            return this._children.length
        };

        Object.defineProperties( TreeNode.prototype, prototypeAccessors );

        return TreeNode;
    }(base));

    Object.defineProperty(TreeNode, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== TreeNode) { return Object.getPrototypeOf(TreeNode)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    TreeNode[instanceofSymbol] = true

    return TreeNode
}

const TreeNode = TreeNodeMixin((function () {
    function anonymous () {}

    return anonymous;
}()))
TreeNode.mixin = TreeNodeMixin

export {TreeNode as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJlZU5vZGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1RyZWVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNJbnN0YW5jZW9mfSBmcm9tICcuL1V0aWxpdHknXG5cbmNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG5jb25zdCBUcmVlTm9kZU1peGluID0gYmFzZSA9PiB7XG4gICAgY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsIC8vIGRlZmF1bHQgdG8gbm8gcGFyZW50LlxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzLl9wYXJlbnQgaXMgcHJvdGVjdGVkIChub2RlJ3MgY2FuIGFjY2VzcyBvdGhlciBub2RlLl9wYXJlbnQpLlxuICAgICAgICAgKiBUaGUgdXNlciBzaG91bGQgdXNlIHRoZSBhZGRDaGlsZCBtZXRob2RzLCB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXNcbiAgICAgICAgICogc2V0dGluZyBhIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGFycmF5LCBzbyB0aGF0IHRoZSB1c2VyIG1vZGlmeWluZyBpdCBkb2Vzbid0IGFmZmVjdFxuICAgICAgICAgICAgLy8gdGhpcyBub2RlJ3MgYWN0dWFsIGNoaWxkcmVuLlxuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9jaGlsZHJlbl1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjaGlsZCBub2RlIHRvIHRoaXMgVHJlZU5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkTm9kZSBUaGUgY2hpbGQgbm9kZSB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDaGlsZCAoY2hpbGROb2RlKSB7XG5cbiAgICAgICAgICAgIGlmICghIGlzSW5zdGFuY2VvZihjaGlsZE5vZGUsIFRyZWVOb2RlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmVlTm9kZS5hZGRDaGlsZCBleHBlY3RzIHRoZSBjaGlsZE5vZGUgYXJndW1lbnQgdG8gYmUgYSBUcmVlTm9kZSBpbnN0YW5jZS4nKVxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9wYXJlbnQgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdjaGlsZE5vZGUgaXMgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXMgcGFyZW50LicpXG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuX3BhcmVudClcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX3BhcmVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGUpXG5cbiAgICAgICAgICAgIGNoaWxkTm9kZS5fcGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZE5vZGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbGwgdGhlIGNoaWxkIG5vZGVzIGluIHRoZSBnaXZlbiBhcnJheSB0byB0aGlzIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuVHJlZU5vZGV9IG5vZGVzIFRoZSBub2RlcyB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDaGlsZHJlbihub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHRoaXMuYWRkQ2hpbGQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSB0aGlzIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkTm9kZSBUaGUgbm9kZSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDaGlsZChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghIGlzSW5zdGFuY2VvZihjaGlsZE5vZGUsIFRyZWVOb2RlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgICAgICBUcmVlTm9kZS5yZW1vdmVDaGlsZCBleHBlY3RzIHRoZSBjaGlsZE5vZGUgYXJndW1lbnQgdG8gYmUgYW5cbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Ugb2YgVHJlZU5vZGUuIFRoZXJlIHNob3VsZCBvbmx5IGJlIFRyZWVOb2RlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgdHJlZS5cbiAgICAgICAgICAgICAgICBgKVxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLl9wYXJlbnQgIT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdjaGlsZE5vZGUgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBwYXJlbnQuJylcblxuICAgICAgICAgICAgY2hpbGROb2RlLl9wYXJlbnQgPSBudWxsXG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UodGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZE5vZGUpLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYWxsIHRoZSBjaGlsZCBub2RlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgZnJvbSB0aGlzIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuVHJlZU5vZGV9IG5vZGVzIFRoZSBub2RlcyB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDaGlsZHJlbihub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHRoaXMucmVtb3ZlQ2hpbGQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIHJlbW92ZSBhbGwgY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBbGxDaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvdyBtYW55IGNoaWxkcmVuIHRoaXMgVHJlZU5vZGUgaGFzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNoaWxkQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZU5vZGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAodGhpcyAhPT0gVHJlZU5vZGUpIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJlZU5vZGUpW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbCh0aGlzLCBvYmopXG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvdG8gPSBvYmpcblxuICAgICAgICAgICAgd2hpbGUoY3VycmVudFByb3RvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFByb3RvLCBcImNvbnN0cnVjdG9yXCIpXG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLnZhbHVlICYmIGRlc2MudmFsdWUuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VvZlN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudFByb3RvKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBUcmVlTm9kZVtpbnN0YW5jZW9mU3ltYm9sXSA9IHRydWVcblxuICAgIHJldHVybiBUcmVlTm9kZVxufVxuXG5jb25zdCBUcmVlTm9kZSA9IFRyZWVOb2RlTWl4aW4oY2xhc3N7fSlcblRyZWVOb2RlLm1peGluID0gVHJlZU5vZGVNaXhpblxuXG5leHBvcnQge1RyZWVOb2RlIGFzIGRlZmF1bHR9XG4iXSwibmFtZXMiOlsic3VwZXIiLCJ0aGlzIl0sIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksT0FBTyxXQUFXOztBQUV0QyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQzs7QUFFbkQsTUFBTSxhQUFhLEdBQUcsVUFBQSxJQUFJLENBQUEsQ0FBQyxBQUFHO0lBQzFCLElBQU0sUUFBUSxHQUFhO1FBQUMsQUFFeEIsaUJBQVcsQ0FBQyxPQUFZLEVBQUUsQ0FBUDs2Q0FBQSxHQUFHLEVB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