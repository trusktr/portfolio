import XYZValues from './XYZValues'
import Sizeable from './Sizeable'
import { makeLowercaseSetterAliases } from './Utility'
import {isInstanceof} from './Utility'

const instanceofSymbol = Symbol('instanceofSymbol')

const TransformableMixin = base => {

    // Transformable extends TreeNode (indirectly through Sizeable) because it
    // needs to be aware of its _parent when calculating align adjustments.
    const ParentClass = Sizeable.mixin(base)
    class Transformable extends ParentClass {

        constructor(options) {
            if ( options === void 0 ) options = {};

            super(options)

            this._worldMatrix = null
        }

        _setDefaultProperties() {
            super._setDefaultProperties()

            Object.assign(this._properties, {
                position:   new XYZValues(0, 0, 0),
                rotation:   new XYZValues(0, 0, 0),
                scale:      new XYZValues(1, 1, 1),
                origin:     new XYZValues(0.5, 0.5, 0.5),
                align:      new XYZValues(0, 0, 0),
                mountPoint: new XYZValues(0, 0, 0),
                opacity:    1,
                transform:  new window.DOMMatrix,
            })
        }

        _setPropertyObservers() {
            super._setPropertyObservers()

            this._properties.position.on('valuechanged',
                () => this.triggerEvent('propertychange', 'position'))
            this._properties.rotation.on('valuechanged',
                () => this.triggerEvent('propertychange', 'rotation'))
            this._properties.scale.on('valuechanged',
                () => this.triggerEvent('propertychange', 'scale'))
            this._properties.origin.on('valuechanged',
                () => this.triggerEvent('propertychange', 'origin'))
            this._properties.align.on('valuechanged',
                () => this.triggerEvent('propertychange', 'align'))
            this._properties.mountPoint.on('valuechanged',
                () => this.triggerEvent('propertychange', 'mountPoint'))
        }

        /**
         * Takes all the current component values (position, rotation, etc) and
         * calculates a transformation DOMMatrix from them. See "W3C Geometry
         * Interfaces" to learn about DOMMatrix.
         *
         * @method
         * @private
         * @memberOf Node
         */
        _calculateMatrix () {
            const matrix = new window.DOMMatrix
            const properties = this._properties

            const alignAdjustment = [0,0,0]
            if (this._parent) { // The root Scene doesn't have a parent, for example.
                const parentSize = this._parent._calculatedSize
                var align = properties.align;
                alignAdjustment[0] = parentSize.x * align.x
                alignAdjustment[1] = parentSize.y * align.y
                alignAdjustment[2] = parentSize.z * align.z
            }

            const mountPointAdjustment = [0,0,0]
            const thisSize = this._calculatedSize
            var mountPoint = properties.mountPoint;
            mountPointAdjustment[0] = thisSize.x * mountPoint.x
            mountPointAdjustment[1] = thisSize.y * mountPoint.y
            mountPointAdjustment[2] = thisSize.z * mountPoint.z

            const appliedPosition = []
            var position = properties.position;
            appliedPosition[0] = position.x + alignAdjustment[0] - mountPointAdjustment[0]
            appliedPosition[1] = position.y + alignAdjustment[1] - mountPointAdjustment[1]
            appliedPosition[2] = position.z + alignAdjustment[2] - mountPointAdjustment[2]

            matrix.translateSelf(appliedPosition[0], appliedPosition[1], appliedPosition[2])

            // origin calculation will go here:
            // - move by negative origin before rotating.

            // apply each axis rotation, in the x,y,z order.
            var rotation = properties.rotation;
            matrix.rotateAxisAngleSelf(1,0,0, rotation.x)
            matrix.rotateAxisAngleSelf(0,1,0, rotation.y)
            matrix.rotateAxisAngleSelf(0,0,1, rotation.z)

            // origin calculation will go here:
            // - move by positive origin after rotating.

            return matrix
        }

        // TODO: fix _isIdentity in DOMMatrix, it is returning true even if false.
        _calculateWorldMatricesInSubtree() {
            this._calculateWorldMatrixFromParent()

            const children = this._children
            for (let i=0, l=children.length; i<l; i+=1) {
                children[i]._calculateWorldMatricesInSubtree()
            }
        }

        _calculateWorldMatrixFromParent() {
            const parent = this._parent

            if (isInstanceof(parent, Transformable))
                //this._worldMatrix = parent._worldMatrix.multiply(this._properties.transform)
                { this._worldMatrix = this._properties.transform.multiply(parent._worldMatrix) }
            else // otherwise parent is the Scene, which is Sizeable, not Transformable
                { this._worldMatrix = this._properties.transform }
        }

        _render() {
            super._render()

            // TODO: only run this when necessary (f.e. not if only opacity
            // changed)
            this._properties.transform = this._calculateMatrix()
        }
    }

    var ref = Object.getOwnPropertyDescriptor(ParentClass.prototype, 'properties');
    var superPropertiesSet = ref.set;

    // We set accessors manually because Buble doesn't make them configurable
    // as per spec. Additionally we're maing these ones enumerable.
    Object.defineProperties(Transformable.prototype, {

        /**
         * Set the position of the Transformable.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis position to apply.
         * @param {number} [newValue.y] The y-axis position to apply.
         * @param {number} [newValue.z] The z-axis position to apply.
         */
        position: {
            set(newValue) {
                this._setPropertyXYZ(Transformable, 'position', newValue)
            },
            get() {
                return this._properties.position
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis rotation to apply.
         * @param {number} [newValue.y] The y-axis rotation to apply.
         * @param {number} [newValue.z] The z-axis rotation to apply.
         */
        rotation: {
            set(newValue) {
                this._setPropertyXYZ(Transformable, 'rotation', newValue)
            },
            get() {
                return this._properties.rotation
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis scale to apply.
         * @param {number} [newValue.y] The y-axis scale to apply.
         * @param {number} [newValue.z] The z-axis scale to apply.
         */
        scale: {
            set(newValue) {
                this._setPropertyXYZ(Transformable, 'scale', newValue)
            },
            get() {
                return this._properties.scale
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set this Node's opacity.
         *
         * @param {number} opacity A floating point number between 0 and 1
         * (inclusive). 0 is fully transparent, 1 is fully opaque.
         */
        opacity: {
            set(newValue) {
                if (!isRealNumber(newValue)) { newValue = undefined }
                this._setPropertySingle(Transformable, 'opacity', newValue, 'number')
            },
            get() {
                return this._properties.opacity
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the alignment of the Node. This determines at which point in this
         * Node's parent that this Node is mounted.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis align to apply.
         * @param {number} [newValue.y] The y-axis align to apply.
         * @param {number} [newValue.z] The z-axis align to apply.
         */
        align: {
            set(newValue) {
                this._setPropertyXYZ(Transformable, 'align', newValue)
            },
            get() {
                return this._properties.align
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the mount point of the Node.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis mountPoint to apply.
         * @param {number} [newValue.y] The y-axis mountPoint to apply.
         * @param {number} [newValue.z] The z-axis mountPoint to apply.
         */
        mountPoint: {
            set(newValue) {
                this._setPropertyXYZ(Transformable, 'mountPoint', newValue)
            },
            get() {
                return this._properties.mountPoint
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set all properties of a Transformable in one method.
         *
         * @param {Object} properties Properties object - see example.
         *
         * @example
         * node.properties = {
         *   position: {x:200, y:300, z:100},
         *   rotation: {z:35},
         *   scale: {y:2},
         *   opacity: .9,
         * }
         */
        properties: {
            set(properties) {
                if ( properties === void 0 ) properties = {};

                superPropertiesSet.call(this, properties)

                if (properties.position)
                    { this.position = properties.position }

                if (properties.rotation)
                    { this.rotation = properties.rotation }

                if (properties.scale)
                    { this.scale = properties.scale }

                if (properties.origin)
                    { this.origin = properties.origin }

                if (properties.align)
                    { this.align = properties.align }

                if (properties.mountPoint)
                    { this.mountPoint = properties.mountPoint }

                if (properties.opacity)
                    { this.opacity = properties.opacity }
            },
            // no need for a properties getter.
            configurable: true,
        },
    })

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    makeLowercaseSetterAliases(Transformable.prototype)

    Object.defineProperty(Transformable, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== Transformable) { return Object.getPrototypeOf(Transformable)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    Transformable[instanceofSymbol] = true

    return Transformable
}

function isRealNumber(num) {
    if (
        typeof num != 'number'
        || Object.is(num, NaN)
        || Object.is(num, Infinity)
    ) { return false }
    return true
}

const Transformable = TransformableMixin(class{})
Transformable.mixin = TransformableMixin

export {Transformable as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtYWJsZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWFlaVmFsdWVzIGZyb20gJy4vWFlaVmFsdWVzJ1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4vU2l6ZWFibGUnXG5pbXBvcnQgeyBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyB9IGZyb20gJy4vVXRpbGl0eSdcbmltcG9ydCB7aXNJbnN0YW5jZW9mfSBmcm9tICcuL1V0aWxpdHknXG5cbmNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG5jb25zdCBUcmFuc2Zvcm1hYmxlTWl4aW4gPSBiYXNlID0+IHtcblxuICAgIC8vIFRyYW5zZm9ybWFibGUgZXh0ZW5kcyBUcmVlTm9kZSAoaW5kaXJlY3RseSB0aHJvdWdoIFNpemVhYmxlKSBiZWNhdXNlIGl0XG4gICAgLy8gbmVlZHMgdG8gYmUgYXdhcmUgb2YgaXRzIF9wYXJlbnQgd2hlbiBjYWxjdWxhdGluZyBhbGlnbiBhZGp1c3RtZW50cy5cbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IFNpemVhYmxlLm1peGluKGJhc2UpXG4gICAgY2xhc3MgVHJhbnNmb3JtYWJsZSBleHRlbmRzIFBhcmVudENsYXNzIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAgICAgICAgIHRoaXMuX3dvcmxkTWF0cml4ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgX3NldERlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgc3VwZXIuX3NldERlZmF1bHRQcm9wZXJ0aWVzKClcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICAgbmV3IFhZWlZhbHVlcygwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogICBuZXcgWFlaVmFsdWVzKDAsIDAsIDApLFxuICAgICAgICAgICAgICAgIHNjYWxlOiAgICAgIG5ldyBYWVpWYWx1ZXMoMSwgMSwgMSksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAgICAgbmV3IFhZWlZhbHVlcygwLjUsIDAuNSwgMC41KSxcbiAgICAgICAgICAgICAgICBhbGlnbjogICAgICBuZXcgWFlaVmFsdWVzKDAsIDAsIDApLFxuICAgICAgICAgICAgICAgIG1vdW50UG9pbnQ6IG5ldyBYWVpWYWx1ZXMoMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogICAgMSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICBuZXcgd2luZG93LkRPTU1hdHJpeCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UHJvcGVydHlPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICBzdXBlci5fc2V0UHJvcGVydHlPYnNlcnZlcnMoKVxuXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnBvc2l0aW9uLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdwb3NpdGlvbicpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5yb3RhdGlvbi5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAncm90YXRpb24nKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuc2NhbGUub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ3NjYWxlJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLm9yaWdpbi5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAnb3JpZ2luJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdhbGlnbicpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5tb3VudFBvaW50Lm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdtb3VudFBvaW50JykpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYWxsIHRoZSBjdXJyZW50IGNvbXBvbmVudCB2YWx1ZXMgKHBvc2l0aW9uLCByb3RhdGlvbiwgZXRjKSBhbmRcbiAgICAgICAgICogY2FsY3VsYXRlcyBhIHRyYW5zZm9ybWF0aW9uIERPTU1hdHJpeCBmcm9tIHRoZW0uIFNlZSBcIlczQyBHZW9tZXRyeVxuICAgICAgICAgKiBJbnRlcmZhY2VzXCIgdG8gbGVhcm4gYWJvdXQgRE9NTWF0cml4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXJPZiBOb2RlXG4gICAgICAgICAqL1xuICAgICAgICBfY2FsY3VsYXRlTWF0cml4ICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyB3aW5kb3cuRE9NTWF0cml4XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllc1xuXG4gICAgICAgICAgICBjb25zdCBhbGlnbkFkanVzdG1lbnQgPSBbMCwwLDBdXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7IC8vIFRoZSByb290IFNjZW5lIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2l6ZSA9IHRoaXMuX3BhcmVudC5fY2FsY3VsYXRlZFNpemVcbiAgICAgICAgICAgICAgICBjb25zdCB7YWxpZ259ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGFsaWduQWRqdXN0bWVudFswXSA9IHBhcmVudFNpemUueCAqIGFsaWduLnhcbiAgICAgICAgICAgICAgICBhbGlnbkFkanVzdG1lbnRbMV0gPSBwYXJlbnRTaXplLnkgKiBhbGlnbi55XG4gICAgICAgICAgICAgICAgYWxpZ25BZGp1c3RtZW50WzJdID0gcGFyZW50U2l6ZS56ICogYWxpZ24uelxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtb3VudFBvaW50QWRqdXN0bWVudCA9IFswLDAsMF1cbiAgICAgICAgICAgIGNvbnN0IHRoaXNTaXplID0gdGhpcy5fY2FsY3VsYXRlZFNpemVcbiAgICAgICAgICAgIGNvbnN0IHttb3VudFBvaW50fSA9IHByb3BlcnRpZXNcbiAgICAgICAgICAgIG1vdW50UG9pbnRBZGp1c3RtZW50WzBdID0gdGhpc1NpemUueCAqIG1vdW50UG9pbnQueFxuICAgICAgICAgICAgbW91bnRQb2ludEFkanVzdG1lbnRbMV0gPSB0aGlzU2l6ZS55ICogbW91bnRQb2ludC55XG4gICAgICAgICAgICBtb3VudFBvaW50QWRqdXN0bWVudFsyXSA9IHRoaXNTaXplLnogKiBtb3VudFBvaW50LnpcblxuICAgICAgICAgICAgY29uc3QgYXBwbGllZFBvc2l0aW9uID0gW11cbiAgICAgICAgICAgIGNvbnN0IHtwb3NpdGlvbn0gPSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBhcHBsaWVkUG9zaXRpb25bMF0gPSBwb3NpdGlvbi54ICsgYWxpZ25BZGp1c3RtZW50WzBdIC0gbW91bnRQb2ludEFkanVzdG1lbnRbMF1cbiAgICAgICAgICAgIGFwcGxpZWRQb3NpdGlvblsxXSA9IHBvc2l0aW9uLnkgKyBhbGlnbkFkanVzdG1lbnRbMV0gLSBtb3VudFBvaW50QWRqdXN0bWVudFsxXVxuICAgICAgICAgICAgYXBwbGllZFBvc2l0aW9uWzJdID0gcG9zaXRpb24ueiArIGFsaWduQWRqdXN0bWVudFsyXSAtIG1vdW50UG9pbnRBZGp1c3RtZW50WzJdXG5cbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGVTZWxmKGFwcGxpZWRQb3NpdGlvblswXSwgYXBwbGllZFBvc2l0aW9uWzFdLCBhcHBsaWVkUG9zaXRpb25bMl0pXG5cbiAgICAgICAgICAgIC8vIG9yaWdpbiBjYWxjdWxhdGlvbiB3aWxsIGdvIGhlcmU6XG4gICAgICAgICAgICAvLyAtIG1vdmUgYnkgbmVnYXRpdmUgb3JpZ2luIGJlZm9yZSByb3RhdGluZy5cblxuICAgICAgICAgICAgLy8gYXBwbHkgZWFjaCBheGlzIHJvdGF0aW9uLCBpbiB0aGUgeCx5LHogb3JkZXIuXG4gICAgICAgICAgICBjb25zdCB7cm90YXRpb259ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZUF4aXNBbmdsZVNlbGYoMSwwLDAsIHJvdGF0aW9uLngpXG4gICAgICAgICAgICBtYXRyaXgucm90YXRlQXhpc0FuZ2xlU2VsZigwLDEsMCwgcm90YXRpb24ueSlcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGVBeGlzQW5nbGVTZWxmKDAsMCwxLCByb3RhdGlvbi56KVxuXG4gICAgICAgICAgICAvLyBvcmlnaW4gY2FsY3VsYXRpb24gd2lsbCBnbyBoZXJlOlxuICAgICAgICAgICAgLy8gLSBtb3ZlIGJ5IHBvc2l0aXZlIG9yaWdpbiBhZnRlciByb3RhdGluZy5cblxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZml4IF9pc0lkZW50aXR5IGluIERPTU1hdHJpeCwgaXQgaXMgcmV0dXJuaW5nIHRydWUgZXZlbiBpZiBmYWxzZS5cbiAgICAgICAgX2NhbGN1bGF0ZVdvcmxkTWF0cmljZXNJblN1YnRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVXb3JsZE1hdHJpeEZyb21QYXJlbnQoKVxuXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fY2FsY3VsYXRlV29ybGRNYXRyaWNlc0luU3VidHJlZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfY2FsY3VsYXRlV29ybGRNYXRyaXhGcm9tUGFyZW50KCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50XG5cbiAgICAgICAgICAgIGlmIChpc0luc3RhbmNlb2YocGFyZW50LCBUcmFuc2Zvcm1hYmxlKSlcbiAgICAgICAgICAgICAgICAvL3RoaXMuX3dvcmxkTWF0cml4ID0gcGFyZW50Ll93b3JsZE1hdHJpeC5tdWx0aXBseSh0aGlzLl9wcm9wZXJ0aWVzLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeCA9IHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtLm11bHRpcGx5KHBhcmVudC5fd29ybGRNYXRyaXgpXG4gICAgICAgICAgICBlbHNlIC8vIG90aGVyd2lzZSBwYXJlbnQgaXMgdGhlIFNjZW5lLCB3aGljaCBpcyBTaXplYWJsZSwgbm90IFRyYW5zZm9ybWFibGVcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeCA9IHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtXG4gICAgICAgIH1cblxuICAgICAgICBfcmVuZGVyKCkge1xuICAgICAgICAgICAgc3VwZXIuX3JlbmRlcigpXG5cbiAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgcnVuIHRoaXMgd2hlbiBuZWNlc3NhcnkgKGYuZS4gbm90IGlmIG9ubHkgb3BhY2l0eVxuICAgICAgICAgICAgLy8gY2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtID0gdGhpcy5fY2FsY3VsYXRlTWF0cml4KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHtzZXQ6IHN1cGVyUHJvcGVydGllc1NldH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFBhcmVudENsYXNzLnByb3RvdHlwZSwgJ3Byb3BlcnRpZXMnKVxuXG4gICAgLy8gV2Ugc2V0IGFjY2Vzc29ycyBtYW51YWxseSBiZWNhdXNlIEJ1YmxlIGRvZXNuJ3QgbWFrZSB0aGVtIGNvbmZpZ3VyYWJsZVxuICAgIC8vIGFzIHBlciBzcGVjLiBBZGRpdGlvbmFsbHkgd2UncmUgbWFpbmcgdGhlc2Ugb25lcyBlbnVtZXJhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybWFibGUucHJvdG90eXBlLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIFRyYW5zZm9ybWFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgcG9zaXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBwb3NpdGlvbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHBvc2l0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdwb3NpdGlvbicsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5wb3NpdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgcm90YXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyByb3RhdGlvbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHJvdGF0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdyb3RhdGlvbicsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5yb3RhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgc2NhbGUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBzY2FsZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHNjYWxlIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdzY2FsZScsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5zY2FsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIE5vZGUncyBvcGFjaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBBIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgICogKGluY2x1c2l2ZSkuIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIDEgaXMgZnVsbHkgb3BhcXVlLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlYWxOdW1iZXIobmV3VmFsdWUpKSBuZXdWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5U2luZ2xlKFRyYW5zZm9ybWFibGUsICdvcGFjaXR5JywgbmV3VmFsdWUsICdudW1iZXInKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5vcGFjaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBhbGlnbm1lbnQgb2YgdGhlIE5vZGUuIFRoaXMgZGV0ZXJtaW5lcyBhdCB3aGljaCBwb2ludCBpbiB0aGlzXG4gICAgICAgICAqIE5vZGUncyBwYXJlbnQgdGhhdCB0aGlzIE5vZGUgaXMgbW91bnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBhbGlnbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS55XSBUaGUgeS1heGlzIGFsaWduIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnpdIFRoZSB6LWF4aXMgYWxpZ24gdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHlYWVooVHJhbnNmb3JtYWJsZSwgJ2FsaWduJywgbmV3VmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtb3VudCBwb2ludCBvZiB0aGUgTm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBtb3VudFBvaW50IHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgbW91bnRQb2ludCB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIG1vdW50UG9pbnQgdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudFBvaW50OiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihUcmFuc2Zvcm1hYmxlLCAnbW91bnRQb2ludCcsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5tb3VudFBvaW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGFsbCBwcm9wZXJ0aWVzIG9mIGEgVHJhbnNmb3JtYWJsZSBpbiBvbmUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG9iamVjdCAtIHNlZSBleGFtcGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAqICAgcG9zaXRpb246IHt4OjIwMCwgeTozMDAsIHo6MTAwfSxcbiAgICAgICAgICogICByb3RhdGlvbjoge3o6MzV9LFxuICAgICAgICAgKiAgIHNjYWxlOiB7eToyfSxcbiAgICAgICAgICogICBvcGFjaXR5OiAuOSxcbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgc2V0KHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyUHJvcGVydGllc1NldC5jYWxsKHRoaXMsIHByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BlcnRpZXMucG9zaXRpb25cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnJvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcHJvcGVydGllcy5yb3RhdGlvblxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuc2NhbGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBwcm9wZXJ0aWVzLnNjYWxlXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5vcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luID0gcHJvcGVydGllcy5vcmlnaW5cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmFsaWduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduID0gcHJvcGVydGllcy5hbGlnblxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubW91bnRQb2ludClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3VudFBvaW50ID0gcHJvcGVydGllcy5tb3VudFBvaW50XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5vcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBwcm9wZXJ0aWVzLm9wYWNpdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBubyBuZWVkIGZvciBhIHByb3BlcnRpZXMgZ2V0dGVyLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pXG5cbiAgICAvLyBmb3IgdXNlIGJ5IE1vdG9ySFRNTCwgY29udmVuaWVudCBzaW5jZSBIVE1MRWxlbWVudCBhdHRyaWJ1dGVzIGFyZSBhbGxcbiAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGJ5IGRlZmF1bHQsIHNvIGlmIHdlIGRvbid0IGRvIHRoaXMgdGhlbiB3ZSB3b24ndCBiZVxuICAgIC8vIGFibGUgdG8gbWFwIGF0dHJpYnV0ZXMgdG8gTm9kZSBzZXR0ZXJzIGFzIGVhc2lseS5cbiAgICBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyhUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1hYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKHRoaXMgIT09IFRyYW5zZm9ybWFibGUpIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYWJsZSlbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHRoaXMsIG9iailcblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm90byA9IG9ialxuXG4gICAgICAgICAgICB3aGlsZShjdXJyZW50UHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50UHJvdG8sIFwiY29uc3RydWN0b3JcIilcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2MudmFsdWUgJiYgZGVzYy52YWx1ZS5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZW9mU3ltYm9sKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50UHJvdG8pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIFRyYW5zZm9ybWFibGVbaW5zdGFuY2VvZlN5bWJvbF0gPSB0cnVlXG5cbiAgICByZXR1cm4gVHJhbnNmb3JtYWJsZVxufVxuXG5mdW5jdGlvbiBpc1JlYWxOdW1iZXIobnVtKSB7XG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgbnVtICE9ICdudW1iZXInXG4gICAgICAgIHx8IE9iamVjdC5pcyhudW0sIE5hTilcbiAgICAgICAgfHwgT2JqZWN0LmlzKG51bSwgSW5maW5pdHkpXG4gICAgKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBUcmFuc2Zvcm1hYmxlID0gVHJhbnNmb3JtYWJsZU1peGluKGNsYXNze30pXG5UcmFuc2Zvcm1hYmxlLm1peGluID0gVHJhbnNmb3JtYWJsZU1peGluXG5cbmV4cG9ydCB7VHJhbnNmb3JtYWJsZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxNQUFNLGFBQWE7QUFDbkMsT0FBTyxRQUFRLE1BQU0sWUFBWTtBQUNqQyxTQUFTLDBCQUEwQixRQUFRLFdBQVc7QUFDdEQsUUFBUSxZQUFZLE9BQU8sV0FBVzs7QUFFdEMsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUM7O0FBRW5ELE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxJQUFJOzs7O0lBSS9CLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0lBQ3hDLE1BQU0sYUFBYSxTQUFTLFdBQVcsQ0FBQzs7UUFFcEMsV0FBVyxDQUFDLE9BQVksRUFBRSxDQUFQOzZDQUFBLEdBQUcsRUFBRTtBQUFHO1lBQ3ZCLEtBQUssQ0FBQyxPQUFPLENBQUM7O1lBRWQsSUFBSSxDQUFDLFlB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