import XYZValues from './XYZValues'
import Sizeable from './Sizeable'
import { makeLowercaseSetterAliases } from './Utility'
import {isInstanceof} from './Utility'

const instanceofSymbol = Symbol('instanceofSymbol')

const TransformableMixin = function (base) {

    // Transformable extends TreeNode (indirectly through Sizeable) because it
    // needs to be aware of its _parent when calculating align adjustments.
    const ParentClass = Sizeable.mixin(base)
    var Transformable = (function (ParentClass) {
        function Transformable(options) {
            if ( options === void 0 ) options = {};

            ParentClass.call(this, options)

            this._worldMatrix = null
        }

        if ( ParentClass ) Transformable.__proto__ = ParentClass;
        Transformable.prototype = Object.create( ParentClass && ParentClass.prototype );
        Transformable.prototype.constructor = Transformable;

        Transformable.prototype._setDefaultProperties = function _setDefaultProperties () {
            ParentClass.prototype._setDefaultProperties.call(this)

            Object.assign(this._properties, {
                position:   new XYZValues(0, 0, 0),
                rotation:   new XYZValues(0, 0, 0),
                scale:      new XYZValues(1, 1, 1),
                origin:     new XYZValues(0.5, 0.5, 0.5),
                align:      new XYZValues(0, 0, 0),
                mountPoint: new XYZValues(0, 0, 0),
                opacity:    1,
                transform:  new window.DOMMatrix,
            })
        };

        Transformable.prototype._setPropertyObservers = function _setPropertyObservers () {
            var this$1 = this;

            ParentClass.prototype._setPropertyObservers.call(this)

            this._properties.position.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'position'); })
            this._properties.rotation.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'rotation'); })
            this._properties.scale.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'scale'); })
            this._properties.origin.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'origin'); })
            this._properties.align.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'align'); })
            this._properties.mountPoint.on('valuechanged',
                function () { return this$1.triggerEvent('propertychange', 'mountPoint'); })
        };

        /**
         * Takes all the current component values (position, rotation, etc) and
         * calculates a transformation DOMMatrix from them. See "W3C Geometry
         * Interfaces" to learn about DOMMatrix.
         *
         * @method
         * @private
         * @memberOf Node
         */
        Transformable.prototype._calculateMatrix = function _calculateMatrix () {
            const matrix = new window.DOMMatrix
            const properties = this._properties

            const alignAdjustment = [0,0,0]
            if (this._parent) { // The root Scene doesn't have a parent, for example.
                const parentSize = this._parent._calculatedSize
                var align = properties.align;
                alignAdjustment[0] = parentSize.x * align.x
                alignAdjustment[1] = parentSize.y * align.y
                alignAdjustment[2] = parentSize.z * align.z
            }

            const mountPointAdjustment = [0,0,0]
            const thisSize = this._calculatedSize
            var mountPoint = properties.mountPoint;
            mountPointAdjustment[0] = thisSize.x * mountPoint.x
            mountPointAdjustment[1] = thisSize.y * mountPoint.y
            mountPointAdjustment[2] = thisSize.z * mountPoint.z

            const appliedPosition = []
            var position = properties.position;
            appliedPosition[0] = position.x + alignAdjustment[0] - mountPointAdjustment[0]
            appliedPosition[1] = position.y + alignAdjustment[1] - mountPointAdjustment[1]
            appliedPosition[2] = position.z + alignAdjustment[2] - mountPointAdjustment[2]

            matrix.translateSelf(appliedPosition[0], appliedPosition[1], appliedPosition[2])

            // origin calculation will go here:
            // - move by negative origin before rotating.

            // apply each axis rotation, in the x,y,z order.
            var rotation = properties.rotation;
            matrix.rotateAxisAngleSelf(1,0,0, rotation.x)
            matrix.rotateAxisAngleSelf(0,1,0, rotation.y)
            matrix.rotateAxisAngleSelf(0,0,1, rotation.z)

            // origin calculation will go here:
            // - move by positive origin after rotating.

            return matrix
        };

        // TODO: fix _isIdentity in DOMMatrix, it is returning true even if false.
        Transformable.prototype._calculateWorldMatricesInSubtree = function _calculateWorldMatricesInSubtree () {
            this._calculateWorldMatrixFromParent()

            const children = this._children
            for (let i=0, l=children.length; i<l; i+=1) {
                children[i]._calculateWorldMatricesInSubtree()
            }
        };

        Transformable.prototype._calculateWorldMatrixFromParent = function _calculateWorldMatrixFromParent () {
            const parent = this._parent

            if (isInstanceof(parent, Transformable))
                //this._worldMatrix = parent._worldMatrix.multiply(this._properties.transform)
                { this._worldMatrix = this._properties.transform.multiply(parent._worldMatrix) }
            else // otherwise parent is the Scene, which is Sizeable, not Transformable
                { this._worldMatrix = this._properties.transform }
        };

        Transformable.prototype._render = function _render () {
            ParentClass.prototype._render.call(this)

            // TODO: only run this when necessary (f.e. not if only opacity
            // changed)
            this._properties.transform = this._calculateMatrix()
        };

        return Transformable;
    }(ParentClass));

    var ref = Object.getOwnPropertyDescriptor(ParentClass.prototype, 'properties');
    var superPropertiesSet = ref.set;

    // We set accessors manually because Buble doesn't make them configurable
    // as per spec. Additionally we're maing these ones enumerable.
    Object.defineProperties(Transformable.prototype, {

        /**
         * Set the position of the Transformable.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis position to apply.
         * @param {number} [newValue.y] The y-axis position to apply.
         * @param {number} [newValue.z] The z-axis position to apply.
         */
        position: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'position', newValue)
            },
            get: function get() {
                return this._properties.position
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis rotation to apply.
         * @param {number} [newValue.y] The y-axis rotation to apply.
         * @param {number} [newValue.z] The z-axis rotation to apply.
         */
        rotation: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'rotation', newValue)
            },
            get: function get() {
                return this._properties.rotation
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis scale to apply.
         * @param {number} [newValue.y] The y-axis scale to apply.
         * @param {number} [newValue.z] The z-axis scale to apply.
         */
        scale: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'scale', newValue)
            },
            get: function get() {
                return this._properties.scale
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set this Node's opacity.
         *
         * @param {number} opacity A floating point number between 0 and 1
         * (inclusive). 0 is fully transparent, 1 is fully opaque.
         */
        opacity: {
            set: function set(newValue) {
                if (!isRealNumber(newValue)) { newValue = undefined }
                this._setPropertySingle(Transformable, 'opacity', newValue, 'number')
            },
            get: function get() {
                return this._properties.opacity
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the alignment of the Node. This determines at which point in this
         * Node's parent that this Node is mounted.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis align to apply.
         * @param {number} [newValue.y] The y-axis align to apply.
         * @param {number} [newValue.z] The z-axis align to apply.
         */
        align: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'align', newValue)
            },
            get: function get() {
                return this._properties.align
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the mount point of the Node.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis mountPoint to apply.
         * @param {number} [newValue.y] The y-axis mountPoint to apply.
         * @param {number} [newValue.z] The z-axis mountPoint to apply.
         */
        mountPoint: {
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'mountPoint', newValue)
            },
            get: function get() {
                return this._properties.mountPoint
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set all properties of a Transformable in one method.
         *
         * @param {Object} properties Properties object - see example.
         *
         * @example
         * node.properties = {
         *   position: {x:200, y:300, z:100},
         *   rotation: {z:35},
         *   scale: {y:2},
         *   opacity: .9,
         * }
         */
        properties: {
            set: function set(properties) {
                if ( properties === void 0 ) properties = {};

                superPropertiesSet.call(this, properties)

                if (properties.position)
                    { this.position = properties.position }

                if (properties.rotation)
                    { this.rotation = properties.rotation }

                if (properties.scale)
                    { this.scale = properties.scale }

                if (properties.origin)
                    { this.origin = properties.origin }

                if (properties.align)
                    { this.align = properties.align }

                if (properties.mountPoint)
                    { this.mountPoint = properties.mountPoint }

                if (properties.opacity)
                    { this.opacity = properties.opacity }
            },
            // no need for a properties getter.
            configurable: true,
        },
    })

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    makeLowercaseSetterAliases(Transformable.prototype)

    Object.defineProperty(Transformable, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== Transformable) { return Object.getPrototypeOf(Transformable)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while(currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    Transformable[instanceofSymbol] = true

    return Transformable
}

function isRealNumber(num) {
    if (
        typeof num != 'number'
        || Object.is(num, NaN)
        || Object.is(num, Infinity)
    ) { return false }
    return true
}

const Transformable = TransformableMixin((function () {
    function anonymous () {}

    return anonymous;
}()))
Transformable.mixin = TransformableMixin

export {Transformable as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtYWJsZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWFlaVmFsdWVzIGZyb20gJy4vWFlaVmFsdWVzJ1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4vU2l6ZWFibGUnXG5pbXBvcnQgeyBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyB9IGZyb20gJy4vVXRpbGl0eSdcbmltcG9ydCB7aXNJbnN0YW5jZW9mfSBmcm9tICcuL1V0aWxpdHknXG5cbmNvbnN0IGluc3RhbmNlb2ZTeW1ib2wgPSBTeW1ib2woJ2luc3RhbmNlb2ZTeW1ib2wnKVxuXG5jb25zdCBUcmFuc2Zvcm1hYmxlTWl4aW4gPSBiYXNlID0+IHtcblxuICAgIC8vIFRyYW5zZm9ybWFibGUgZXh0ZW5kcyBUcmVlTm9kZSAoaW5kaXJlY3RseSB0aHJvdWdoIFNpemVhYmxlKSBiZWNhdXNlIGl0XG4gICAgLy8gbmVlZHMgdG8gYmUgYXdhcmUgb2YgaXRzIF9wYXJlbnQgd2hlbiBjYWxjdWxhdGluZyBhbGlnbiBhZGp1c3RtZW50cy5cbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IFNpemVhYmxlLm1peGluKGJhc2UpXG4gICAgY2xhc3MgVHJhbnNmb3JtYWJsZSBleHRlbmRzIFBhcmVudENsYXNzIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAgICAgICAgIHRoaXMuX3dvcmxkTWF0cml4ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgX3NldERlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgc3VwZXIuX3NldERlZmF1bHRQcm9wZXJ0aWVzKClcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICAgbmV3IFhZWlZhbHVlcygwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogICBuZXcgWFlaVmFsdWVzKDAsIDAsIDApLFxuICAgICAgICAgICAgICAgIHNjYWxlOiAgICAgIG5ldyBYWVpWYWx1ZXMoMSwgMSwgMSksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAgICAgbmV3IFhZWlZhbHVlcygwLjUsIDAuNSwgMC41KSxcbiAgICAgICAgICAgICAgICBhbGlnbjogICAgICBuZXcgWFlaVmFsdWVzKDAsIDAsIDApLFxuICAgICAgICAgICAgICAgIG1vdW50UG9pbnQ6IG5ldyBYWVpWYWx1ZXMoMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogICAgMSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICBuZXcgd2luZG93LkRPTU1hdHJpeCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UHJvcGVydHlPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICBzdXBlci5fc2V0UHJvcGVydHlPYnNlcnZlcnMoKVxuXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnBvc2l0aW9uLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdwb3NpdGlvbicpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5yb3RhdGlvbi5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAncm90YXRpb24nKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuc2NhbGUub24oJ3ZhbHVlY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgJ3NjYWxlJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLm9yaWdpbi5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAnb3JpZ2luJykpXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdhbGlnbicpKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5tb3VudFBvaW50Lm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdtb3VudFBvaW50JykpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYWxsIHRoZSBjdXJyZW50IGNvbXBvbmVudCB2YWx1ZXMgKHBvc2l0aW9uLCByb3RhdGlvbiwgZXRjKSBhbmRcbiAgICAgICAgICogY2FsY3VsYXRlcyBhIHRyYW5zZm9ybWF0aW9uIERPTU1hdHJpeCBmcm9tIHRoZW0uIFNlZSBcIlczQyBHZW9tZXRyeVxuICAgICAgICAgKiBJbnRlcmZhY2VzXCIgdG8gbGVhcm4gYWJvdXQgRE9NTWF0cml4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXJPZiBOb2RlXG4gICAgICAgICAqL1xuICAgICAgICBfY2FsY3VsYXRlTWF0cml4ICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyB3aW5kb3cuRE9NTWF0cml4XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllc1xuXG4gICAgICAgICAgICBjb25zdCBhbGlnbkFkanVzdG1lbnQgPSBbMCwwLDBdXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7IC8vIFRoZSByb290IFNjZW5lIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2l6ZSA9IHRoaXMuX3BhcmVudC5fY2FsY3VsYXRlZFNpemVcbiAgICAgICAgICAgICAgICBjb25zdCB7YWxpZ259ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGFsaWduQWRqdXN0bWVudFswXSA9IHBhcmVudFNpemUueCAqIGFsaWduLnhcbiAgICAgICAgICAgICAgICBhbGlnbkFkanVzdG1lbnRbMV0gPSBwYXJlbnRTaXplLnkgKiBhbGlnbi55XG4gICAgICAgICAgICAgICAgYWxpZ25BZGp1c3RtZW50WzJdID0gcGFyZW50U2l6ZS56ICogYWxpZ24uelxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtb3VudFBvaW50QWRqdXN0bWVudCA9IFswLDAsMF1cbiAgICAgICAgICAgIGNvbnN0IHRoaXNTaXplID0gdGhpcy5fY2FsY3VsYXRlZFNpemVcbiAgICAgICAgICAgIGNvbnN0IHttb3VudFBvaW50fSA9IHByb3BlcnRpZXNcbiAgICAgICAgICAgIG1vdW50UG9pbnRBZGp1c3RtZW50WzBdID0gdGhpc1NpemUueCAqIG1vdW50UG9pbnQueFxuICAgICAgICAgICAgbW91bnRQb2ludEFkanVzdG1lbnRbMV0gPSB0aGlzU2l6ZS55ICogbW91bnRQb2ludC55XG4gICAgICAgICAgICBtb3VudFBvaW50QWRqdXN0bWVudFsyXSA9IHRoaXNTaXplLnogKiBtb3VudFBvaW50LnpcblxuICAgICAgICAgICAgY29uc3QgYXBwbGllZFBvc2l0aW9uID0gW11cbiAgICAgICAgICAgIGNvbnN0IHtwb3NpdGlvbn0gPSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBhcHBsaWVkUG9zaXRpb25bMF0gPSBwb3NpdGlvbi54ICsgYWxpZ25BZGp1c3RtZW50WzBdIC0gbW91bnRQb2ludEFkanVzdG1lbnRbMF1cbiAgICAgICAgICAgIGFwcGxpZWRQb3NpdGlvblsxXSA9IHBvc2l0aW9uLnkgKyBhbGlnbkFkanVzdG1lbnRbMV0gLSBtb3VudFBvaW50QWRqdXN0bWVudFsxXVxuICAgICAgICAgICAgYXBwbGllZFBvc2l0aW9uWzJdID0gcG9zaXRpb24ueiArIGFsaWduQWRqdXN0bWVudFsyXSAtIG1vdW50UG9pbnRBZGp1c3RtZW50WzJdXG5cbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGVTZWxmKGFwcGxpZWRQb3NpdGlvblswXSwgYXBwbGllZFBvc2l0aW9uWzFdLCBhcHBsaWVkUG9zaXRpb25bMl0pXG5cbiAgICAgICAgICAgIC8vIG9yaWdpbiBjYWxjdWxhdGlvbiB3aWxsIGdvIGhlcmU6XG4gICAgICAgICAgICAvLyAtIG1vdmUgYnkgbmVnYXRpdmUgb3JpZ2luIGJlZm9yZSByb3RhdGluZy5cblxuICAgICAgICAgICAgLy8gYXBwbHkgZWFjaCBheGlzIHJvdGF0aW9uLCBpbiB0aGUgeCx5LHogb3JkZXIuXG4gICAgICAgICAgICBjb25zdCB7cm90YXRpb259ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZUF4aXNBbmdsZVNlbGYoMSwwLDAsIHJvdGF0aW9uLngpXG4gICAgICAgICAgICBtYXRyaXgucm90YXRlQXhpc0FuZ2xlU2VsZigwLDEsMCwgcm90YXRpb24ueSlcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGVBeGlzQW5nbGVTZWxmKDAsMCwxLCByb3RhdGlvbi56KVxuXG4gICAgICAgICAgICAvLyBvcmlnaW4gY2FsY3VsYXRpb24gd2lsbCBnbyBoZXJlOlxuICAgICAgICAgICAgLy8gLSBtb3ZlIGJ5IHBvc2l0aXZlIG9yaWdpbiBhZnRlciByb3RhdGluZy5cblxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZml4IF9pc0lkZW50aXR5IGluIERPTU1hdHJpeCwgaXQgaXMgcmV0dXJuaW5nIHRydWUgZXZlbiBpZiBmYWxzZS5cbiAgICAgICAgX2NhbGN1bGF0ZVdvcmxkTWF0cmljZXNJblN1YnRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVXb3JsZE1hdHJpeEZyb21QYXJlbnQoKVxuXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fY2FsY3VsYXRlV29ybGRNYXRyaWNlc0luU3VidHJlZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfY2FsY3VsYXRlV29ybGRNYXRyaXhGcm9tUGFyZW50KCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50XG5cbiAgICAgICAgICAgIGlmIChpc0luc3RhbmNlb2YocGFyZW50LCBUcmFuc2Zvcm1hYmxlKSlcbiAgICAgICAgICAgICAgICAvL3RoaXMuX3dvcmxkTWF0cml4ID0gcGFyZW50Ll93b3JsZE1hdHJpeC5tdWx0aXBseSh0aGlzLl9wcm9wZXJ0aWVzLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeCA9IHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtLm11bHRpcGx5KHBhcmVudC5fd29ybGRNYXRyaXgpXG4gICAgICAgICAgICBlbHNlIC8vIG90aGVyd2lzZSBwYXJlbnQgaXMgdGhlIFNjZW5lLCB3aGljaCBpcyBTaXplYWJsZSwgbm90IFRyYW5zZm9ybWFibGVcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeCA9IHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtXG4gICAgICAgIH1cblxuICAgICAgICBfcmVuZGVyKCkge1xuICAgICAgICAgICAgc3VwZXIuX3JlbmRlcigpXG5cbiAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgcnVuIHRoaXMgd2hlbiBuZWNlc3NhcnkgKGYuZS4gbm90IGlmIG9ubHkgb3BhY2l0eVxuICAgICAgICAgICAgLy8gY2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMudHJhbnNmb3JtID0gdGhpcy5fY2FsY3VsYXRlTWF0cml4KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHtzZXQ6IHN1cGVyUHJvcGVydGllc1NldH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFBhcmVudENsYXNzLnByb3RvdHlwZSwgJ3Byb3BlcnRpZXMnKVxuXG4gICAgLy8gV2Ugc2V0IGFjY2Vzc29ycyBtYW51YWxseSBiZWNhdXNlIEJ1YmxlIGRvZXNuJ3QgbWFrZSB0aGVtIGNvbmZpZ3VyYWJsZVxuICAgIC8vIGFzIHBlciBzcGVjLiBBZGRpdGlvbmFsbHkgd2UncmUgbWFpbmcgdGhlc2Ugb25lcyBlbnVtZXJhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybWFibGUucHJvdG90eXBlLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIFRyYW5zZm9ybWFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgcG9zaXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBwb3NpdGlvbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHBvc2l0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdwb3NpdGlvbicsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5wb3NpdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgcm90YXRpb24gdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyByb3RhdGlvbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHJvdGF0aW9uIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdyb3RhdGlvbicsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5yb3RhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgc2NhbGUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBzY2FsZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHNjYWxlIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFRyYW5zZm9ybWFibGUsICdzY2FsZScsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5zY2FsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIE5vZGUncyBvcGFjaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBBIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgICogKGluY2x1c2l2ZSkuIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIDEgaXMgZnVsbHkgb3BhcXVlLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlYWxOdW1iZXIobmV3VmFsdWUpKSBuZXdWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5U2luZ2xlKFRyYW5zZm9ybWFibGUsICdvcGFjaXR5JywgbmV3VmFsdWUsICdudW1iZXInKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5vcGFjaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBhbGlnbm1lbnQgb2YgdGhlIE5vZGUuIFRoaXMgZGV0ZXJtaW5lcyBhdCB3aGljaCBwb2ludCBpbiB0aGlzXG4gICAgICAgICAqIE5vZGUncyBwYXJlbnQgdGhhdCB0aGlzIE5vZGUgaXMgbW91bnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBhbGlnbiB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS55XSBUaGUgeS1heGlzIGFsaWduIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnpdIFRoZSB6LWF4aXMgYWxpZ24gdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHlYWVooVHJhbnNmb3JtYWJsZSwgJ2FsaWduJywgbmV3VmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtb3VudCBwb2ludCBvZiB0aGUgTm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBtb3VudFBvaW50IHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgbW91bnRQb2ludCB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIG1vdW50UG9pbnQgdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudFBvaW50OiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihUcmFuc2Zvcm1hYmxlLCAnbW91bnRQb2ludCcsIG5ld1ZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5tb3VudFBvaW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGFsbCBwcm9wZXJ0aWVzIG9mIGEgVHJhbnNmb3JtYWJsZSBpbiBvbmUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG9iamVjdCAtIHNlZSBleGFtcGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAqICAgcG9zaXRpb246IHt4OjIwMCwgeTozMDAsIHo6MTAwfSxcbiAgICAgICAgICogICByb3RhdGlvbjoge3o6MzV9LFxuICAgICAgICAgKiAgIHNjYWxlOiB7eToyfSxcbiAgICAgICAgICogICBvcGFjaXR5OiAuOSxcbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgc2V0KHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyUHJvcGVydGllc1NldC5jYWxsKHRoaXMsIHByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BlcnRpZXMucG9zaXRpb25cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnJvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcHJvcGVydGllcy5yb3RhdGlvblxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuc2NhbGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBwcm9wZXJ0aWVzLnNjYWxlXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5vcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luID0gcHJvcGVydGllcy5vcmlnaW5cblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmFsaWduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduID0gcHJvcGVydGllcy5hbGlnblxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubW91bnRQb2ludClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3VudFBvaW50ID0gcHJvcGVydGllcy5tb3VudFBvaW50XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5vcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBwcm9wZXJ0aWVzLm9wYWNpdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBubyBuZWVkIGZvciBhIHByb3BlcnRpZXMgZ2V0dGVyLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pXG5cbiAgICAvLyBmb3IgdXNlIGJ5IE1vdG9ySFRNTCwgY29udmVuaWVudCBzaW5jZSBIVE1MRWxlbWVudCBhdHRyaWJ1dGVzIGFyZSBhbGxcbiAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGJ5IGRlZmF1bHQsIHNvIGlmIHdlIGRvbid0IGRvIHRoaXMgdGhlbiB3ZSB3b24ndCBiZVxuICAgIC8vIGFibGUgdG8gbWFwIGF0dHJpYnV0ZXMgdG8gTm9kZSBzZXR0ZXJzIGFzIGVhc2lseS5cbiAgICBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyhUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1hYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKHRoaXMgIT09IFRyYW5zZm9ybWFibGUpIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYWJsZSlbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHRoaXMsIG9iailcblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm90byA9IG9ialxuXG4gICAgICAgICAgICB3aGlsZShjdXJyZW50UHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50UHJvdG8sIFwiY29uc3RydWN0b3JcIilcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2MudmFsdWUgJiYgZGVzYy52YWx1ZS5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZW9mU3ltYm9sKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50UHJvdG8pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIFRyYW5zZm9ybWFibGVbaW5zdGFuY2VvZlN5bWJvbF0gPSB0cnVlXG5cbiAgICByZXR1cm4gVHJhbnNmb3JtYWJsZVxufVxuXG5mdW5jdGlvbiBpc1JlYWxOdW1iZXIobnVtKSB7XG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgbnVtICE9ICdudW1iZXInXG4gICAgICAgIHx8IE9iamVjdC5pcyhudW0sIE5hTilcbiAgICAgICAgfHwgT2JqZWN0LmlzKG51bSwgSW5maW5pdHkpXG4gICAgKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBUcmFuc2Zvcm1hYmxlID0gVHJhbnNmb3JtYWJsZU1peGluKGNsYXNze30pXG5UcmFuc2Zvcm1hYmxlLm1peGluID0gVHJhbnNmb3JtYWJsZU1peGluXG5cbmV4cG9ydCB7VHJhbnNmb3JtYWJsZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbInN1cGVyIiwidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTLE1BQU0sYUFBYTtBQUNuQyxPQUFPLFFBQVEsTUFBTSxZQUFZO0FBQ2pDLFNBQVMsMEJBQTBCLFFBQVEsV0FBVztBQUN0RCxRQUFRLFlBQVksT0FBTyxXQUFXOztBQUV0QyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQzs7QUFFbkQsTUFBTSxrQkFBa0IsR0FBRyxVQUFBLElBQUksQ0FBQSxDQUFDLEFBQUc7Ozs7SUFJL0IsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7SUFDeEMsSUFBTSxhQUFhLEdBQW9CO1FBQUMsQUFFcEMsc0JBQVcsQ0FBQyxPQUFZLEVBQUUsQ0FBUDs2Q0FBQSxHQUFHLEVBQUU7QUFBRztZQUN2QkEsV0FBSyxLQUFBLENB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