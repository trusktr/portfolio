function epsilon(value) {
    return Math.abs(value) < 0.000001 ? 0 : value;
}

function applyCSSLabel(value, label) {
    if (value === 0) {
        return '0px'
    } else if (label === '%') {
        return value * 100 + '%';
    } else if (label === 'px') {
        return value + 'px'
    }
}

function animationFrame() {
    let resolve = null
    const promise = new Promise(r => resolve = r)
    window.requestAnimationFrame(resolve)
    return promise
}

// Create lowercase versions of each setter property.
// we care only about the setters, for now.
function makeLowercaseSetterAliases(object) {
    const props = Object.getOwnPropertyNames(object)
    for (let l=props.length, i=0; i<l; i+=1) {
        const prop = props[i]
        const lowercaseProp = prop.toLowerCase()
        if (lowercaseProp != prop) {
            const descriptor = Object.getOwnPropertyDescriptor(object, prop)
            if (typeof descriptor.set != 'undefined') {
                Object.defineProperty(object, lowercaseProp, descriptor)
            }
        }
    }
}

let childObservationHandlers = null
let childObserver = null
function observeChildren(ctx, onConnect, onDisconnect) {
    if (!childObservationHandlers) { childObservationHandlers = new Map }
    if (!childObserver) { childObserver = createChildObserver() }
    childObservationHandlers.set(ctx, {onConnect, onDisconnect})
    childObserver.observe(ctx, { childList: true })
    return true
}

// NOTE: If a child is disconnected then connected to the same parent in the
// same turn, then the onConnect and onDisconnect callbacks won't be called
// because the DOM tree will be back in the exact state as before (this is
// possible thanks to the logic associated with weightsPerTarget).
function createChildObserver() {
    return new MutationObserver(changes => {
        const weightsPerTarget = new Map

        // We're just counting how many times each child node was added and
        // removed from the parent we're observing.
        for (let i=0, l=changes.length; i<l; i+=1) {
            const change = changes[i]

            if (change.type != 'childList') { continue }

            if (!weightsPerTarget.has(change.target))
                { weightsPerTarget.set(change.target, new Map) }

            const weights = weightsPerTarget.get(change.target)

            var addedNodes = change.addedNodes;
            for (let l=addedNodes.length, i=0; i<l; i+=1)
                { weights.set(addedNodes[i], (weights.get(addedNodes[i]) || 0) + 1) }

            var removedNodes = change.removedNodes;
            for (let l=removedNodes.length, i=0; i<l; i+=1)
                { weights.set(removedNodes[i], (weights.get(removedNodes[i]) || 0) - 1) }
        }

        // TODO PERFORMANCE: Can these for..of loops be converted to regular for loops?
        for (var i = 0, list = weightsPerTarget; i < list.length; i += 1) {
            const ref = list[i];
            var target = ref[0];
            var weights = ref[1];

            var ref$1 = childObservationHandlers.get(target);
            var onConnect = ref$1.onConnect;
            var onDisconnect = ref$1.onDisconnect;

            for (var i$1 = 0, list$1 = weights; i$1 < list$1.length; i$1 += 1) {
                // If the number of times a child was added is greater than the
                // number of times it was removed, then the net result is that
                // it was added, so we call onConnect just once.
                const ref$2 = list$1[i$1];
                var node = ref$2[0];
                var weight = ref$2[1];

                if (weight > 0 && typeof onConnect == 'function')
                    { onConnect.call(target, node) }

                // If the number of times a child was added is less than the
                // number of times it was removed, then the net result is that
                // it was removed, so we call onConnect just once.
                else if (weight < 0 && typeof onDisconnect == 'function')
                    { onDisconnect.call(target, node) }

                // If the number of times a child was added is equal to the
                // number of times it was removed, then it was essentially left
                // in place, so we don't call anything.
            }
        }
    })
}

const hasShadowDomV0 =
    typeof Element.prototype.createShadowRoot == 'function'
    && typeof HTMLContentElement == 'function'
    ? true : false

const hasShadowDomV1 =
    typeof Element.prototype.attachShadow == 'function'
    && typeof HTMLSlotElement == 'function'
    ? true : false

function getShadowRootVersion(shadowRoot) {
    console.log('getShadowRootVersion')
    if (!shadowRoot) { return null }
    const slot = document.createElement('slot')
    shadowRoot.appendChild(slot)
    slot.appendChild(document.createElement('div'))
    const assignedNodes = slot.assignedNodes({ flatten: true })
    slot.remove()
    console.log('hmm', assignedNodes.length, assignedNodes.length > 0 ? 'v1' : 'v0')
    return assignedNodes.length > 0 ? 'v1' : 'v0'
}

function getAncestorShadowRoot(node) {
    let current = node

    while (current && !(current instanceof ShadowRoot)) {
        current = current.parentNode
    }

    return current
}

// in the future, the user will be able to toggle the HTML API.
const hasHtmlApi = true

// Traverses a tree while considering ShadowDOM disribution.
function traverse(node, isShadowChild) {
    console.log(isShadowChild ? 'distributedNode:' : 'node:', node)

    var children = node.children;
    for (let l=children.length, i=0; i<l; i+=1) {
        // skip nodes that are possiblyDistributed, i.e. they have a parent
        // that has a ShadowRoot.
        if (!hasHtmlApi || !children[i]._elementManager.element._isPossiblyDistributed)
            { traverse(children[i]) }
    }

    const shadowChildren = node._elementManager.element._shadowChildren
    if (hasHtmlApi && shadowChildren) {
        for (let l=shadowChildren.length, i=0; i<l; i+=1)
            { traverse(shadowChildren[i].imperativeCounterpart, true) }
    }
}

// helper function to use instead of instanceof for classes that implement the
// static Symbol.hasInstance method, because the behavior of instanceof isn't
// polyfillable.
function isInstanceof(lhs, rhs) {
    if (typeof rhs == 'function' && rhs[Symbol.hasInstance])
        { return rhs[Symbol.hasInstance](lhs) }
    else { return lhs instanceof rhs }
}

export {
    epsilon,
    applyCSSLabel,
    animationFrame,
    makeLowercaseSetterAliases,
    observeChildren,
    getShadowRootVersion,
    hasShadowDomV0,
    hasShadowDomV1,
    getAncestorShadowRoot,
    traverse,
    isInstanceof,
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXRpbGl0eS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvVXRpbGl0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlcHNpbG9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKSA8IDAuMDAwMDAxID8gMCA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhcHBseUNTU0xhYmVsKHZhbHVlLCBsYWJlbCkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzBweCdcbiAgICB9IGVsc2UgaWYgKGxhYmVsID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICogMTAwICsgJyUnO1xuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09ICdweCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4J1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWUoKSB7XG4gICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHIgPT4gcmVzb2x2ZSA9IHIpXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKVxuICAgIHJldHVybiBwcm9taXNlXG59XG5cbi8vIENyZWF0ZSBsb3dlcmNhc2UgdmVyc2lvbnMgb2YgZWFjaCBzZXR0ZXIgcHJvcGVydHkuXG4vLyB3ZSBjYXJlIG9ubHkgYWJvdXQgdGhlIHNldHRlcnMsIGZvciBub3cuXG5mdW5jdGlvbiBtYWtlTG93ZXJjYXNlU2V0dGVyQWxpYXNlcyhvYmplY3QpIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdClcbiAgICBmb3IgKGxldCBsPXByb3BzLmxlbmd0aCwgaT0wOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldXG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVByb3AgPSBwcm9wLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKGxvd2VyY2FzZVByb3AgIT0gcHJvcCkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGxvd2VyY2FzZVByb3AsIGRlc2NyaXB0b3IpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCBjaGlsZE9ic2VydmF0aW9uSGFuZGxlcnMgPSBudWxsXG5sZXQgY2hpbGRPYnNlcnZlciA9IG51bGxcbmZ1bmN0aW9uIG9ic2VydmVDaGlsZHJlbihjdHgsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0KSB7XG4gICAgaWYgKCFjaGlsZE9ic2VydmF0aW9uSGFuZGxlcnMpIGNoaWxkT2JzZXJ2YXRpb25IYW5kbGVycyA9IG5ldyBNYXBcbiAgICBpZiAoIWNoaWxkT2JzZXJ2ZXIpIGNoaWxkT2JzZXJ2ZXIgPSBjcmVhdGVDaGlsZE9ic2VydmVyKClcbiAgICBjaGlsZE9ic2VydmF0aW9uSGFuZGxlcnMuc2V0KGN0eCwge29uQ29ubmVjdCwgb25EaXNjb25uZWN0fSlcbiAgICBjaGlsZE9ic2VydmVyLm9ic2VydmUoY3R4LCB7IGNoaWxkTGlzdDogdHJ1ZSB9KVxuICAgIHJldHVybiB0cnVlXG59XG5cbi8vIE5PVEU6IElmIGEgY2hpbGQgaXMgZGlzY29ubmVjdGVkIHRoZW4gY29ubmVjdGVkIHRvIHRoZSBzYW1lIHBhcmVudCBpbiB0aGVcbi8vIHNhbWUgdHVybiwgdGhlbiB0aGUgb25Db25uZWN0IGFuZCBvbkRpc2Nvbm5lY3QgY2FsbGJhY2tzIHdvbid0IGJlIGNhbGxlZFxuLy8gYmVjYXVzZSB0aGUgRE9NIHRyZWUgd2lsbCBiZSBiYWNrIGluIHRoZSBleGFjdCBzdGF0ZSBhcyBiZWZvcmUgKHRoaXMgaXNcbi8vIHBvc3NpYmxlIHRoYW5rcyB0byB0aGUgbG9naWMgYXNzb2NpYXRlZCB3aXRoIHdlaWdodHNQZXJUYXJnZXQpLlxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRPYnNlcnZlcigpIHtcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgICAgIGNvbnN0IHdlaWdodHNQZXJUYXJnZXQgPSBuZXcgTWFwXG5cbiAgICAgICAgLy8gV2UncmUganVzdCBjb3VudGluZyBob3cgbWFueSB0aW1lcyBlYWNoIGNoaWxkIG5vZGUgd2FzIGFkZGVkIGFuZFxuICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB3ZSdyZSBvYnNlcnZpbmcuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1jaGFuZ2VzLmxlbmd0aDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2ldXG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPSAnY2hpbGRMaXN0JykgY29udGludWVcblxuICAgICAgICAgICAgaWYgKCF3ZWlnaHRzUGVyVGFyZ2V0LmhhcyhjaGFuZ2UudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB3ZWlnaHRzUGVyVGFyZ2V0LnNldChjaGFuZ2UudGFyZ2V0LCBuZXcgTWFwKVxuXG4gICAgICAgICAgICBjb25zdCB3ZWlnaHRzID0gd2VpZ2h0c1BlclRhcmdldC5nZXQoY2hhbmdlLnRhcmdldClcblxuICAgICAgICAgICAgY29uc3Qge2FkZGVkTm9kZXN9ID0gY2hhbmdlXG4gICAgICAgICAgICBmb3IgKGxldCBsPWFkZGVkTm9kZXMubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSlcbiAgICAgICAgICAgICAgICB3ZWlnaHRzLnNldChhZGRlZE5vZGVzW2ldLCAod2VpZ2h0cy5nZXQoYWRkZWROb2Rlc1tpXSkgfHwgMCkgKyAxKVxuXG4gICAgICAgICAgICBjb25zdCB7cmVtb3ZlZE5vZGVzfSA9IGNoYW5nZVxuICAgICAgICAgICAgZm9yIChsZXQgbD1yZW1vdmVkTm9kZXMubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSlcbiAgICAgICAgICAgICAgICB3ZWlnaHRzLnNldChyZW1vdmVkTm9kZXNbaV0sICh3ZWlnaHRzLmdldChyZW1vdmVkTm9kZXNbaV0pIHx8IDApIC0gMSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gUEVSRk9STUFOQ0U6IENhbiB0aGVzZSBmb3IuLm9mIGxvb3BzIGJlIGNvbnZlcnRlZCB0byByZWd1bGFyIGZvciBsb29wcz9cbiAgICAgICAgZm9yIChjb25zdCBbdGFyZ2V0LCB3ZWlnaHRzXSBvZiB3ZWlnaHRzUGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCB7b25Db25uZWN0LCBvbkRpc2Nvbm5lY3R9ID0gY2hpbGRPYnNlcnZhdGlvbkhhbmRsZXJzLmdldCh0YXJnZXQpXG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW25vZGUsIHdlaWdodF0gb2Ygd2VpZ2h0cykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgdGltZXMgYSBjaGlsZCB3YXMgYWRkZWQgaXMgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiB0aW1lcyBpdCB3YXMgcmVtb3ZlZCwgdGhlbiB0aGUgbmV0IHJlc3VsdCBpcyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gaXQgd2FzIGFkZGVkLCBzbyB3ZSBjYWxsIG9uQ29ubmVjdCBqdXN0IG9uY2UuXG4gICAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDAgJiYgdHlwZW9mIG9uQ29ubmVjdCA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkNvbm5lY3QuY2FsbCh0YXJnZXQsIG5vZGUpXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgY2hpbGQgd2FzIGFkZGVkIGlzIGxlc3MgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgdGltZXMgaXQgd2FzIHJlbW92ZWQsIHRoZW4gdGhlIG5ldCByZXN1bHQgaXMgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGl0IHdhcyByZW1vdmVkLCBzbyB3ZSBjYWxsIG9uQ29ubmVjdCBqdXN0IG9uY2UuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2VpZ2h0IDwgMCAmJiB0eXBlb2Ygb25EaXNjb25uZWN0ID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdC5jYWxsKHRhcmdldCwgbm9kZSlcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgdGltZXMgYSBjaGlsZCB3YXMgYWRkZWQgaXMgZXF1YWwgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHRpbWVzIGl0IHdhcyByZW1vdmVkLCB0aGVuIGl0IHdhcyBlc3NlbnRpYWxseSBsZWZ0XG4gICAgICAgICAgICAgICAgLy8gaW4gcGxhY2UsIHNvIHdlIGRvbid0IGNhbGwgYW55dGhpbmcuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5jb25zdCBoYXNTaGFkb3dEb21WMCA9XG4gICAgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBIVE1MQ29udGVudEVsZW1lbnQgPT0gJ2Z1bmN0aW9uJ1xuICAgID8gdHJ1ZSA6IGZhbHNlXG5cbmNvbnN0IGhhc1NoYWRvd0RvbVYxID1cbiAgICB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ID09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgSFRNTFNsb3RFbGVtZW50ID09ICdmdW5jdGlvbidcbiAgICA/IHRydWUgOiBmYWxzZVxuXG5mdW5jdGlvbiBnZXRTaGFkb3dSb290VmVyc2lvbihzaGFkb3dSb290KSB7XG4gICAgY29uc29sZS5sb2coJ2dldFNoYWRvd1Jvb3RWZXJzaW9uJylcbiAgICBpZiAoIXNoYWRvd1Jvb3QpIHJldHVybiBudWxsXG4gICAgY29uc3Qgc2xvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Nsb3QnKVxuICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2xvdClcbiAgICBzbG90LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgIGNvbnN0IGFzc2lnbmVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pXG4gICAgc2xvdC5yZW1vdmUoKVxuICAgIGNvbnNvbGUubG9nKCdobW0nLCBhc3NpZ25lZE5vZGVzLmxlbmd0aCwgYXNzaWduZWROb2Rlcy5sZW5ndGggPiAwID8gJ3YxJyA6ICd2MCcpXG4gICAgcmV0dXJuIGFzc2lnbmVkTm9kZXMubGVuZ3RoID4gMCA/ICd2MScgOiAndjAnXG59XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9yU2hhZG93Um9vdChub2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBub2RlXG5cbiAgICB3aGlsZSAoY3VycmVudCAmJiAhKGN1cnJlbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSkge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRcbn1cblxuLy8gaW4gdGhlIGZ1dHVyZSwgdGhlIHVzZXIgd2lsbCBiZSBhYmxlIHRvIHRvZ2dsZSB0aGUgSFRNTCBBUEkuXG5jb25zdCBoYXNIdG1sQXBpID0gdHJ1ZVxuXG4vLyBUcmF2ZXJzZXMgYSB0cmVlIHdoaWxlIGNvbnNpZGVyaW5nIFNoYWRvd0RPTSBkaXNyaWJ1dGlvbi5cbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGlzU2hhZG93Q2hpbGQpIHtcbiAgICBjb25zb2xlLmxvZyhpc1NoYWRvd0NoaWxkID8gJ2Rpc3RyaWJ1dGVkTm9kZTonIDogJ25vZGU6Jywgbm9kZSlcblxuICAgIGNvbnN0IHtjaGlsZHJlbn0gPSBub2RlXG4gICAgZm9yIChsZXQgbD1jaGlsZHJlbi5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgIC8vIHNraXAgbm9kZXMgdGhhdCBhcmUgcG9zc2libHlEaXN0cmlidXRlZCwgaS5lLiB0aGV5IGhhdmUgYSBwYXJlbnRcbiAgICAgICAgLy8gdGhhdCBoYXMgYSBTaGFkb3dSb290LlxuICAgICAgICBpZiAoIWhhc0h0bWxBcGkgfHwgIWNoaWxkcmVuW2ldLl9lbGVtZW50TWFuYWdlci5lbGVtZW50Ll9pc1Bvc3NpYmx5RGlzdHJpYnV0ZWQpXG4gICAgICAgICAgICB0cmF2ZXJzZShjaGlsZHJlbltpXSlcbiAgICB9XG5cbiAgICBjb25zdCBzaGFkb3dDaGlsZHJlbiA9IG5vZGUuX2VsZW1lbnRNYW5hZ2VyLmVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuXG4gICAgaWYgKGhhc0h0bWxBcGkgJiYgc2hhZG93Q2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgbD1zaGFkb3dDaGlsZHJlbi5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKVxuICAgICAgICAgICAgdHJhdmVyc2Uoc2hhZG93Q2hpbGRyZW5baV0uaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LCB0cnVlKVxuICAgIH1cbn1cblxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIHVzZSBpbnN0ZWFkIG9mIGluc3RhbmNlb2YgZm9yIGNsYXNzZXMgdGhhdCBpbXBsZW1lbnQgdGhlXG4vLyBzdGF0aWMgU3ltYm9sLmhhc0luc3RhbmNlIG1ldGhvZCwgYmVjYXVzZSB0aGUgYmVoYXZpb3Igb2YgaW5zdGFuY2VvZiBpc24ndFxuLy8gcG9seWZpbGxhYmxlLlxuZnVuY3Rpb24gaXNJbnN0YW5jZW9mKGxocywgcmhzKSB7XG4gICAgaWYgKHR5cGVvZiByaHMgPT0gJ2Z1bmN0aW9uJyAmJiByaHNbU3ltYm9sLmhhc0luc3RhbmNlXSlcbiAgICAgICAgcmV0dXJuIHJoc1tTeW1ib2wuaGFzSW5zdGFuY2VdKGxocylcbiAgICBlbHNlIHJldHVybiBsaHMgaW5zdGFuY2VvZiByaHNcbn1cblxuZXhwb3J0IHtcbiAgICBlcHNpbG9uLFxuICAgIGFwcGx5Q1NTTGFiZWwsXG4gICAgYW5pbWF0aW9uRnJhbWUsXG4gICAgbWFrZUxvd2VyY2FzZVNldHRlckFsaWFzZXMsXG4gICAgb2JzZXJ2ZUNoaWxkcmVuLFxuICAgIGdldFNoYWRvd1Jvb3RWZXJzaW9uLFxuICAgIGhhc1NoYWRvd0RvbVYwLFxuICAgIGhhc1NoYWRvd0RvbVYxLFxuICAgIGdldEFuY2VzdG9yU2hhZG93Um9vdCxcbiAgICB0cmF2ZXJzZSxcbiAgICBpc0luc3RhbmNlb2YsXG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFO0lBQ3BCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztDQUNqRDs7QUFFRCxTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO0lBQ2pDLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtRQUNiLE9BQU8sS0FBSztLQUNmLE1BQU0sSUFBSSxLQUFLLEtBQUssR0FBRyxFQUFFO1FBQ3RCLE9BQU8sS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7S0FDNUIsTUFBTSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7UUFDdkIsT0FBTyxLQUFLLEdBQUcsSUFBSTtLQUN0QjtDQUNKOztBQUVELFNBQVMsY0FBYyxHQUFHO0lBQ3RCLElBQUksT0FBTyxHQUFHLElBQUk7SUFDbEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDN0MsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQztJQUNyQyxPQUFPLE9BQU87Q0FDakI7Ozs7QUFJRCxTQUFTLDBCQUEwQixDQUFDLE1BQU0sRUFBRTtJQUN4QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDO0lBQ2hELEtBQUss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