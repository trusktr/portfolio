import 'geometry-interfaces'
import Transformable from './Transformable'
import ImperativeBase, {initImperativeBase} from './ImperativeBase'
import HTMLNode from '../html/HTMLNode'
import Scene from './Scene'

initImperativeBase()

class Node extends ImperativeBase.mixin(Transformable) {

    /**
     * @constructor
     *
     * @param {Object} options Initial properties that the node will
     * have. This can be used when creating a node, alternatively to using the
     * setters/getters for position, rotation, etc.
     *
     * @example
     * var node = new Node({
     *   absoluteSize: {x:100, y:100, z:100},
     *   rotation: {x:30, y:20, z:25}
     * })
     */
    constructor (options) {
        if ( options === void 0 ) options = {};

        super(options)

        // This was when using my `multiple()` implementation, we could call
        // specific constructors using specific arguments. But, we're using
        // class-factory style mixins for now, so we don't have control over the
        // specific arguments we can pass to the constructors, so we're just
        // using a single `options` parameter in all the constructors.
        //this.callSuperConstructor(Transformable, options)
        //this.callSuperConstructor(TreeNode)
        //this.callSuperConstructor(ImperativeBase)

        this._scene = null // stores a ref to this Node's root Scene.

        // This is an internal promise that resolves when this Node is added to
        // to a scene graph that has a root Scene TreeNode. The resolved value
        // is the root Scene.
        this._scenePromise = null
        this._resolveScenePromise = null

        /**
         * @private
         * This method is defined here in the consructor as an arrow function
         * because parent Nodes pass it to Observable#on and Observable#off. If
         * it were a prototype method, then it would need to be bound when
         * passed to Observable#on, which would require keeping track of the
         * bound function reference in order to be able to pass it to
         * Observable#off later. See ImperativeBase#addChild and
         * ImperativeBase#removeChild.
         */
        this._onParentSizeChange = () => {

            // We only need to recalculate sizing and matrices if this node has
            // properties that depend on parent sizing (proportional size,
            // align, and mountPoint). mountPoint isn't obvious: if this node
            // is proportionally sized, then the mountPoint will depend on the
            // size of this element which depends on the size of this element's
            // parent.
            if (
                this._properties.sizeMode.x === "proportional"
                || this._properties.sizeMode.y === "proportional"
                || this._properties.sizeMode.z === "proportional"

                || this._properties.align.x !== 0
                || this._properties.align.y !== 0
                || this._properties.align.z !== 0
            ) {
                this._calcSize()
                this._needsToBeRendered()
            }
        }

        this._calcSize()
        this._needsToBeRendered()
    }

    /**
     * @private
     */
    _waitForMountThenResolveMountPromise() {
        if (this._awaitingScenePromise) { return Promise.resolve() }

        const logic = () => {
            this._mounted = true
            this._resolveMountPromise()
            this._elementManager.shouldRender()
        }

        this._awaitingScenePromise = true

        let possibleError = undefined

        // try
        return this._getScenePromise()
        .then(() => this._scene.mountPromise)

        .then(logic)

        // catch
        .catch(() => {
            if (e == 'mountcancel') { return }
            else { possibleError = e }
        })

        // finally
        .then(() => {
            this._awaitingScenePromise = false

            if (possibleError) { throw possibleError }
        })
    }
    //async _waitForMountThenResolveMountPromise() {
        //if (this._awaitingScenePromise) return
        //try {
            //this._awaitingScenePromise = true
            //await this._getScenePromise()
            //await this._scene.mountPromise
        //} catch (e) {
            //if (e == 'mountcancel') return
            //else throw e
        //} finally {
            //this._awaitingScenePromise = false
        //}

        //this._mounted = true
        //this._resolveMountPromise()
        //this._elementManager.shouldRender()
    //}

    /**
     * @override
     */
    _makeElement() {
        return new HTMLNode
    }

    /**
     * @private
     * Get a promise for the node's eventual scene.
     */
    _getScenePromise() {
        if (!this._scenePromise) {
            this._scenePromise = new Promise((a, b) => {
                this._resolveScenePromise = a
            })
        }

        if (this._scene)
            { this._resolveScenePromise() }

        return this._scenePromise
    }

    /**
     * Get the Scene that this Node is in, null if no Scene. This is recursive
     * at first, then cached.
     *
     * This traverses up the scene graph tree starting at this Node and finds
     * the root Scene, if any. It caches the value for performance. If this
     * Node is removed from a parent node with parent.removeChild(), then the
     * cache is invalidated so the traversal can happen again when this Node is
     * eventually added to a new tree. This way, if the scene is cached on a
     * parent Node that we're adding this Node to then we can get that cached
     * value instead of traversing the tree.
     *
     * @readonly
     */
    get scene() {
        // NOTE: this._scene is initally null, created in the constructor.

        // if already cached, return it. Or if no parent, return it (it'll be null).
        if (this._scene || !this._parent) { return this._scene }

        // if the parent node already has a ref to the scene, use that.
        if (this._parent._scene) {
            this._scene = this._parent._scene
        }
        else if (this._parent instanceof Scene) {
            this._scene = this._parent
        }
        // otherwise call the scene getter on the parent, which triggers
        // traversal up the scene graph in order to find the root scene (null
        // if none).
        else {
            this._scene = this._parent.scene
        }

        return this._scene
    }

    /**
     * @private
     * This method to be called only when this Node has this.scene.
     * Resolves the _scenePromise for all children of the tree of this Node.
     */
    _giveSceneRefToChildren() {
        const children = this._children;
        for (let i=0, l=children.length; i<l; i+=1) {
            const childNode = children[i]
            childNode._scene = this._scene
            if (childNode._resolveScenePromise)
                { childNode._resolveScenePromise(childNode._scene) }
            childNode._giveSceneRefToChildren();
        }
    }

    _resetSceneRef() {
        this._scene = null
        this._scenePromise = null
        this._resolveScenePromise = null
        const children = this._children;
        for (let i=0, l=children.length; i<l; i+=1) {
            children[i]._resetSceneRef();
        }
    }
}

export {Node as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmUvTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2dlb21ldHJ5LWludGVyZmFjZXMnXG5pbXBvcnQgVHJhbnNmb3JtYWJsZSBmcm9tICcuL1RyYW5zZm9ybWFibGUnXG5pbXBvcnQgSW1wZXJhdGl2ZUJhc2UsIHtpbml0SW1wZXJhdGl2ZUJhc2V9IGZyb20gJy4vSW1wZXJhdGl2ZUJhc2UnXG5pbXBvcnQgSFRNTE5vZGUgZnJvbSAnLi4vaHRtbC9IVE1MTm9kZSdcbmltcG9ydCBTY2VuZSBmcm9tICcuL1NjZW5lJ1xuXG5pbml0SW1wZXJhdGl2ZUJhc2UoKVxuXG5jbGFzcyBOb2RlIGV4dGVuZHMgSW1wZXJhdGl2ZUJhc2UubWl4aW4oVHJhbnNmb3JtYWJsZSkge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBJbml0aWFsIHByb3BlcnRpZXMgdGhhdCB0aGUgbm9kZSB3aWxsXG4gICAgICogaGF2ZS4gVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbm9kZSwgYWx0ZXJuYXRpdmVseSB0byB1c2luZyB0aGVcbiAgICAgKiBzZXR0ZXJzL2dldHRlcnMgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgZXRjLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHtcbiAgICAgKiAgIGFic29sdXRlU2l6ZToge3g6MTAwLCB5OjEwMCwgejoxMDB9LFxuICAgICAqICAgcm90YXRpb246IHt4OjMwLCB5OjIwLCB6OjI1fVxuICAgICAqIH0pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgICAgIC8vIFRoaXMgd2FzIHdoZW4gdXNpbmcgbXkgYG11bHRpcGxlKClgIGltcGxlbWVudGF0aW9uLCB3ZSBjb3VsZCBjYWxsXG4gICAgICAgIC8vIHNwZWNpZmljIGNvbnN0cnVjdG9ycyB1c2luZyBzcGVjaWZpYyBhcmd1bWVudHMuIEJ1dCwgd2UncmUgdXNpbmdcbiAgICAgICAgLy8gY2xhc3MtZmFjdG9yeSBzdHlsZSBtaXhpbnMgZm9yIG5vdywgc28gd2UgZG9uJ3QgaGF2ZSBjb250cm9sIG92ZXIgdGhlXG4gICAgICAgIC8vIHNwZWNpZmljIGFyZ3VtZW50cyB3ZSBjYW4gcGFzcyB0byB0aGUgY29uc3RydWN0b3JzLCBzbyB3ZSdyZSBqdXN0XG4gICAgICAgIC8vIHVzaW5nIGEgc2luZ2xlIGBvcHRpb25zYCBwYXJhbWV0ZXIgaW4gYWxsIHRoZSBjb25zdHJ1Y3RvcnMuXG4gICAgICAgIC8vdGhpcy5jYWxsU3VwZXJDb25zdHJ1Y3RvcihUcmFuc2Zvcm1hYmxlLCBvcHRpb25zKVxuICAgICAgICAvL3RoaXMuY2FsbFN1cGVyQ29uc3RydWN0b3IoVHJlZU5vZGUpXG4gICAgICAgIC8vdGhpcy5jYWxsU3VwZXJDb25zdHJ1Y3RvcihJbXBlcmF0aXZlQmFzZSlcblxuICAgICAgICB0aGlzLl9zY2VuZSA9IG51bGwgLy8gc3RvcmVzIGEgcmVmIHRvIHRoaXMgTm9kZSdzIHJvb3QgU2NlbmUuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcm5hbCBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGlzIE5vZGUgaXMgYWRkZWQgdG9cbiAgICAgICAgLy8gdG8gYSBzY2VuZSBncmFwaCB0aGF0IGhhcyBhIHJvb3QgU2NlbmUgVHJlZU5vZGUuIFRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAgICAvLyBpcyB0aGUgcm9vdCBTY2VuZS5cbiAgICAgICAgdGhpcy5fc2NlbmVQcm9taXNlID0gbnVsbFxuICAgICAgICB0aGlzLl9yZXNvbHZlU2NlbmVQcm9taXNlID0gbnVsbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBkZWZpbmVkIGhlcmUgaW4gdGhlIGNvbnNydWN0b3IgYXMgYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgICAgICogYmVjYXVzZSBwYXJlbnQgTm9kZXMgcGFzcyBpdCB0byBPYnNlcnZhYmxlI29uIGFuZCBPYnNlcnZhYmxlI29mZi4gSWZcbiAgICAgICAgICogaXQgd2VyZSBhIHByb3RvdHlwZSBtZXRob2QsIHRoZW4gaXQgd291bGQgbmVlZCB0byBiZSBib3VuZCB3aGVuXG4gICAgICAgICAqIHBhc3NlZCB0byBPYnNlcnZhYmxlI29uLCB3aGljaCB3b3VsZCByZXF1aXJlIGtlZXBpbmcgdHJhY2sgb2YgdGhlXG4gICAgICAgICAqIGJvdW5kIGZ1bmN0aW9uIHJlZmVyZW5jZSBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHBhc3MgaXQgdG9cbiAgICAgICAgICogT2JzZXJ2YWJsZSNvZmYgbGF0ZXIuIFNlZSBJbXBlcmF0aXZlQmFzZSNhZGRDaGlsZCBhbmRcbiAgICAgICAgICogSW1wZXJhdGl2ZUJhc2UjcmVtb3ZlQ2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblBhcmVudFNpemVDaGFuZ2UgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZWNhbGN1bGF0ZSBzaXppbmcgYW5kIG1hdHJpY2VzIGlmIHRoaXMgbm9kZSBoYXNcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgdGhhdCBkZXBlbmQgb24gcGFyZW50IHNpemluZyAocHJvcG9ydGlvbmFsIHNpemUsXG4gICAgICAgICAgICAvLyBhbGlnbiwgYW5kIG1vdW50UG9pbnQpLiBtb3VudFBvaW50IGlzbid0IG9idmlvdXM6IGlmIHRoaXMgbm9kZVxuICAgICAgICAgICAgLy8gaXMgcHJvcG9ydGlvbmFsbHkgc2l6ZWQsIHRoZW4gdGhlIG1vdW50UG9pbnQgd2lsbCBkZXBlbmQgb24gdGhlXG4gICAgICAgICAgICAvLyBzaXplIG9mIHRoaXMgZWxlbWVudCB3aGljaCBkZXBlbmRzIG9uIHRoZSBzaXplIG9mIHRoaXMgZWxlbWVudCdzXG4gICAgICAgICAgICAvLyBwYXJlbnQuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS54ID09PSBcInByb3BvcnRpb25hbFwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS55ID09PSBcInByb3BvcnRpb25hbFwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS56ID09PSBcInByb3BvcnRpb25hbFwiXG5cbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduLnggIT09IDBcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduLnkgIT09IDBcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9wcm9wZXJ0aWVzLmFsaWduLnogIT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGNTaXplKClcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1RvQmVSZW5kZXJlZCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpXG4gICAgICAgIHRoaXMuX25lZWRzVG9CZVJlbmRlcmVkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93YWl0Rm9yTW91bnRUaGVuUmVzb2x2ZU1vdW50UHJvbWlzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F3YWl0aW5nU2NlbmVQcm9taXNlKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblxuICAgICAgICBjb25zdCBsb2dpYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlTW91bnRQcm9taXNlKClcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRNYW5hZ2VyLnNob3VsZFJlbmRlcigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hd2FpdGluZ1NjZW5lUHJvbWlzZSA9IHRydWVcblxuICAgICAgICBsZXQgcG9zc2libGVFcnJvciA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIHRyeVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2NlbmVQcm9taXNlKClcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fc2NlbmUubW91bnRQcm9taXNlKVxuXG4gICAgICAgIC50aGVuKGxvZ2ljKVxuXG4gICAgICAgIC8vIGNhdGNoXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PSAnbW91bnRjYW5jZWwnKSByZXR1cm5cbiAgICAgICAgICAgIGVsc2UgcG9zc2libGVFcnJvciA9IGVcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBmaW5hbGx5XG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0aW5nU2NlbmVQcm9taXNlID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRXJyb3IpIHRocm93IHBvc3NpYmxlRXJyb3JcbiAgICAgICAgfSlcbiAgICB9XG4gICAgLy9hc3luYyBfd2FpdEZvck1vdW50VGhlblJlc29sdmVNb3VudFByb21pc2UoKSB7XG4gICAgICAgIC8vaWYgKHRoaXMuX2F3YWl0aW5nU2NlbmVQcm9taXNlKSByZXR1cm5cbiAgICAgICAgLy90cnkge1xuICAgICAgICAgICAgLy90aGlzLl9hd2FpdGluZ1NjZW5lUHJvbWlzZSA9IHRydWVcbiAgICAgICAgICAgIC8vYXdhaXQgdGhpcy5fZ2V0U2NlbmVQcm9taXNlKClcbiAgICAgICAgICAgIC8vYXdhaXQgdGhpcy5fc2NlbmUubW91bnRQcm9taXNlXG4gICAgICAgIC8vfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pZiAoZSA9PSAnbW91bnRjYW5jZWwnKSByZXR1cm5cbiAgICAgICAgICAgIC8vZWxzZSB0aHJvdyBlXG4gICAgICAgIC8vfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vdGhpcy5fYXdhaXRpbmdTY2VuZVByb21pc2UgPSBmYWxzZVxuICAgICAgICAvL31cblxuICAgICAgICAvL3RoaXMuX21vdW50ZWQgPSB0cnVlXG4gICAgICAgIC8vdGhpcy5fcmVzb2x2ZU1vdW50UHJvbWlzZSgpXG4gICAgICAgIC8vdGhpcy5fZWxlbWVudE1hbmFnZXIuc2hvdWxkUmVuZGVyKClcbiAgICAvL31cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIVE1MTm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogR2V0IGEgcHJvbWlzZSBmb3IgdGhlIG5vZGUncyBldmVudHVhbCBzY2VuZS5cbiAgICAgKi9cbiAgICBfZ2V0U2NlbmVQcm9taXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NjZW5lUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NlbmVQcm9taXNlID0gbmV3IFByb21pc2UoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlU2NlbmVQcm9taXNlID0gYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSlcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVTY2VuZVByb21pc2UoKVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2VuZVByb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFNjZW5lIHRoYXQgdGhpcyBOb2RlIGlzIGluLCBudWxsIGlmIG5vIFNjZW5lLiBUaGlzIGlzIHJlY3Vyc2l2ZVxuICAgICAqIGF0IGZpcnN0LCB0aGVuIGNhY2hlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgdHJhdmVyc2VzIHVwIHRoZSBzY2VuZSBncmFwaCB0cmVlIHN0YXJ0aW5nIGF0IHRoaXMgTm9kZSBhbmQgZmluZHNcbiAgICAgKiB0aGUgcm9vdCBTY2VuZSwgaWYgYW55LiBJdCBjYWNoZXMgdGhlIHZhbHVlIGZvciBwZXJmb3JtYW5jZS4gSWYgdGhpc1xuICAgICAqIE5vZGUgaXMgcmVtb3ZlZCBmcm9tIGEgcGFyZW50IG5vZGUgd2l0aCBwYXJlbnQucmVtb3ZlQ2hpbGQoKSwgdGhlbiB0aGVcbiAgICAgKiBjYWNoZSBpcyBpbnZhbGlkYXRlZCBzbyB0aGUgdHJhdmVyc2FsIGNhbiBoYXBwZW4gYWdhaW4gd2hlbiB0aGlzIE5vZGUgaXNcbiAgICAgKiBldmVudHVhbGx5IGFkZGVkIHRvIGEgbmV3IHRyZWUuIFRoaXMgd2F5LCBpZiB0aGUgc2NlbmUgaXMgY2FjaGVkIG9uIGFcbiAgICAgKiBwYXJlbnQgTm9kZSB0aGF0IHdlJ3JlIGFkZGluZyB0aGlzIE5vZGUgdG8gdGhlbiB3ZSBjYW4gZ2V0IHRoYXQgY2FjaGVkXG4gICAgICogdmFsdWUgaW5zdGVhZCBvZiB0cmF2ZXJzaW5nIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHNjZW5lKCkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzLl9zY2VuZSBpcyBpbml0YWxseSBudWxsLCBjcmVhdGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICAvLyBpZiBhbHJlYWR5IGNhY2hlZCwgcmV0dXJuIGl0LiBPciBpZiBubyBwYXJlbnQsIHJldHVybiBpdCAoaXQnbGwgYmUgbnVsbCkuXG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSB8fCAhdGhpcy5fcGFyZW50KSByZXR1cm4gdGhpcy5fc2NlbmVcblxuICAgICAgICAvLyBpZiB0aGUgcGFyZW50IG5vZGUgYWxyZWFkeSBoYXMgYSByZWYgdG8gdGhlIHNjZW5lLCB1c2UgdGhhdC5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5fc2NlbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lID0gdGhpcy5fcGFyZW50Ll9zY2VuZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIFNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZSA9IHRoaXMuX3BhcmVudFxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxsIHRoZSBzY2VuZSBnZXR0ZXIgb24gdGhlIHBhcmVudCwgd2hpY2ggdHJpZ2dlcnNcbiAgICAgICAgLy8gdHJhdmVyc2FsIHVwIHRoZSBzY2VuZSBncmFwaCBpbiBvcmRlciB0byBmaW5kIHRoZSByb290IHNjZW5lIChudWxsXG4gICAgICAgIC8vIGlmIG5vbmUpLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lID0gdGhpcy5fcGFyZW50LnNjZW5lXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRoaXMgbWV0aG9kIHRvIGJlIGNhbGxlZCBvbmx5IHdoZW4gdGhpcyBOb2RlIGhhcyB0aGlzLnNjZW5lLlxuICAgICAqIFJlc29sdmVzIHRoZSBfc2NlbmVQcm9taXNlIGZvciBhbGwgY2hpbGRyZW4gb2YgdGhlIHRyZWUgb2YgdGhpcyBOb2RlLlxuICAgICAqL1xuICAgIF9naXZlU2NlbmVSZWZUb0NoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICBjaGlsZE5vZGUuX3NjZW5lID0gdGhpcy5fc2NlbmVcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuX3Jlc29sdmVTY2VuZVByb21pc2UpXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9yZXNvbHZlU2NlbmVQcm9taXNlKGNoaWxkTm9kZS5fc2NlbmUpXG4gICAgICAgICAgICBjaGlsZE5vZGUuX2dpdmVTY2VuZVJlZlRvQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNldFNjZW5lUmVmKCkge1xuICAgICAgICB0aGlzLl9zY2VuZSA9IG51bGxcbiAgICAgICAgdGhpcy5fc2NlbmVQcm9taXNlID0gbnVsbFxuICAgICAgICB0aGlzLl9yZXNvbHZlU2NlbmVQcm9taXNlID0gbnVsbFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpPTAsIGw9Y2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9yZXNldFNjZW5lUmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7Tm9kZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8scUJBQXFCO0FBQzVCLE9BQU8sYUFBYSxNQUFNLGlCQUFpQjtBQUMzQyxPQUFPLGNBQWMsR0FBRyxrQkFBa0IsT0FBTyxrQkFBa0I7QUFDbkUsT0FBTyxRQUFRLE1BQU0sa0JBQWtCO0FBQ3ZDLE9BQU8sS0FBSyxNQUFNLFNBQVM7O0FBRTNCLGtCQUFrQixFQUFFOztBQUVwQixNQUFNLElBQUksU0FBUyxjQUFjLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFlbkQsV0FBVyxDQUFDLENBQUMsT0FBWSxFQUFFLENBQVA7eUNBQUEsR0FBRyxFQUFFO0FBQUc7UUFDeEIsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7UUFXZCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUk7Ozs7O1FBS2xCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSTtRQUN6QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSTs7Ozs7Ozs7Ozs7O1FBWWhDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxNQUFNOzs7Ozs7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