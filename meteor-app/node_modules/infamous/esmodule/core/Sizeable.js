import { makeLowercaseSetterAliases } from './Utility'
import TreeNode from './TreeNode'
import XYZValues from './XYZValues'
import Observable from './Observable'
import Motor from './Motor'

// fallback to experimental CSS transform if browser doesn't have it (fix for Safari 9)
if (typeof document.createElement('div').style.transform == 'undefined') {
    Object.defineProperty(CSSStyleDeclaration.prototype, 'transform', {
        set(value) {
            this.webkitTransform = value
        },
        get() {
            return this.webkitTransform
        },
        enumerable: true,
    })
}

class XYZNonNegativeValues extends XYZValues {

    constructor(x, y, z) {
        if ( x === void 0 ) x = 0;
        if ( y === void 0 ) y = 0;
        if ( z === void 0 ) z = 0;

        super(x, y, z)
    }

    _checkForNegative(axisName, value) {
        if(value < 0) {
            throw new Error(axisName + " value was " + value + ". Size values cannot be negative.")
        }
    }

}

var ref = Object.getOwnPropertyDescriptor(XYZValues.prototype, 'x');
var superXSet = ref.set;
var ref$1 = Object.getOwnPropertyDescriptor(XYZValues.prototype, 'y');
var superYSet = ref$1.set;
var ref$2 = Object.getOwnPropertyDescriptor(XYZValues.prototype, 'z');
var superZSet = ref$2.set;


Object.defineProperties(XYZNonNegativeValues.prototype, {
    x: {
        set(value) {
            this._checkForNegative("X", value)
            superXSet.call(this, value)
        }
    },

    y: {
        set(value) {
            this._checkForNegative("Y", value)
            superYSet.call(this, value)
      }
    },

    z: {
        set(value) {
            this._checkForNegative("Z", value)
            superZSet.call(this, value)
      }
    },
})



const instanceofSymbol = Symbol('instanceofSymbol')

const SizeableMixin = base => {

    // Sizeable extends TreeNode because Sizeable knows about its _parent when
    // calculating proportionalSize. Also Transformable knows about it's parent
    // in order to calculate it's world matrix based on it's parent's.
    class Sizeable extends TreeNode.mixin(Observable.mixin(base)) {

        constructor(options) {
            if ( options === void 0 ) options = {};

            super(options)

            this._propertyFunctions = null
            this._calculatedSize = { x:0, y:0, z:0 }
            this._properties = {}
            this._setDefaultProperties()
            this._setPropertyObservers()
            this.properties = options
        }

        _setDefaultProperties() {
            Object.assign(this._properties, {
                sizeMode:         new XYZValues('absolute', 'absolute', 'absolute'),
                absoluteSize:     new XYZNonNegativeValues(0, 0, 0),
                proportionalSize: new XYZNonNegativeValues(1, 1, 1),
            })
        }

        _setPropertyObservers() {
            this._properties.sizeMode.on('valuechanged',
                () => this.triggerEvent('propertychange', 'sizeMode'))
            this._properties.absoluteSize.on('valuechanged',
                () => this.triggerEvent('propertychange', 'absoluteSize'))
            this._properties.proportionalSize.on('valuechanged',
                () => this.triggerEvent('propertychange', 'proportionalSize'))
        }

        _calcSize() {
            const calculatedSize = this._calculatedSize
            const previousSize = Object.assign({}, calculatedSize)
            const props = this._properties
            const parentSize = this._getParentSize()

            if (props.sizeMode._x == 'absolute') {
                calculatedSize.x = props.absoluteSize._x
            }
            else { // proportional
                calculatedSize.x = parentSize.x * props.proportionalSize._x
            }

            if (props.sizeMode._y == 'absolute') {
                calculatedSize.y = props.absoluteSize._y
            }
            else { // proportional
                calculatedSize.y = parentSize.y * props.proportionalSize._y
            }

            if (props.sizeMode._z == 'absolute') {
                calculatedSize.z = props.absoluteSize._z
            }
            else { // proportional
                calculatedSize.z = parentSize.z * props.proportionalSize._z
            }

            if (
                previousSize.x !== calculatedSize.x
                || previousSize.y !== calculatedSize.y
                || previousSize.z !== calculatedSize.z
            ) {
                this.triggerEvent('sizechange', Object.assign({}, calculatedSize))
            }
        }

        _getParentSize() {
            return this._parent ? this._parent._calculatedSize : {x:0,y:0,z:0}
        }

        _setPropertyXYZ(Class, name, newValue) {
            if (newValue instanceof Function) {
                // remove previous task if any.
                if (!this._propertyFunctions) { this._propertyFunctions = new Map }

                if (this._propertyFunctions.has(name))
                    { Motor.removeRenderTask(this._propertyFunctions.get(name)) }

                this._propertyFunctions.set(name,
                    Motor.addRenderTask(time => {
                        const result = newValue(
                            this._properties[name].x,
                            this._properties[name].y,
                            this._properties[name].z,
                            time
                        )

                        if (result === false) {
                            this._propertyFunctions.delete(name)
                            return false
                        }

                        this[name] = result
                    })
                )
            }
            else if (newValue instanceof Array) {
                if (typeof newValue[0] != 'undefined') { this._properties[name].x = newValue[0] }
                if (typeof newValue[1] != 'undefined') { this._properties[name].y = newValue[1] }
                if (typeof newValue[2] != 'undefined') { this._properties[name].z = newValue[2] }
            }
            else if (newValue instanceof Object) {
                if (typeof newValue.x != 'undefined') { this._properties[name].x = newValue.x }
                if (typeof newValue.y != 'undefined') { this._properties[name].y = newValue.y }
                if (typeof newValue.z != 'undefined') { this._properties[name].z = newValue.z }
            }
            else {
                throw new TypeError(`Invalid value for ${Class.name}#${name}.`)
            }
        }

        _setPropertySingle(Class, name, newValue, type) {
            if (!(typeof newValue == type || newValue instanceof Function))
                { throw new TypeError(`Invalid value for ${Class.name}#${name}.`) }

            if (newValue instanceof Function) {
                // remove previous task if any.
                Motor.addRenderTask(time => {
                    const result = newValue(
                        this._properties[name],
                        time
                    )

                    if (result === false) { return false }

                    this[name] = result
                })
            }
            else {
                this._properties[name] = newValue
                this.triggerEvent('propertychange', name)
            }
        }

        _render() {
            // nothing yet, but needed because ImperativeBase calls
            // `super._render()`, which will call either Transformable's
            // _render or Sizeable's _render for Node and Scene classes,
            // respectively.
        }
    }

    // We set accessors manually because Buble doesn't make them configurable
    // as per spec. Additionally we're maing these ones enumerable.
    Object.defineProperties(Sizeable.prototype, {

        /**
         * Set the size mode for each axis. Possible size modes are "absolute" and "proportional".
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis sizeMode to apply.
         * @param {number} [newValue.y] The y-axis sizeMode to apply.
         * @param {number} [newValue.z] The z-axis sizeMode to apply.
         */
        sizeMode: {
            set(newValue) {
                this._setPropertyXYZ(Sizeable, 'sizeMode', newValue)
            },
            get() {
                return this._properties.sizeMode
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis absoluteSize to apply.
         * @param {number} [newValue.y] The y-axis absoluteSize to apply.
         * @param {number} [newValue.z] The z-axis absoluteSize to apply.
         */
        absoluteSize: {
            set(newValue) {
                this._setPropertyXYZ(Sizeable, 'absoluteSize', newValue)
            },
            get() {
                return this._properties.absoluteSize
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Get the actual size of the Node. This can be useful when size is
         * proportional, as the actual size of the Node depends on the size of
         * it's parent.
         *
         * @readonly
         *
         * @return {Array.number} An Oject with x, y, and z properties, each
         * property representing the computed size of the x, y, and z axes
         * respectively.
         */
        actualSize: {
            get() {
                var ref = this._calculatedSize;
                var x = ref.x;
                var y = ref.y;
                var z = ref.z;
                return {x,y,z}
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set the size of a Node proportional to the size of it's parent Node. The
         * values are a real number between 0 and 1 inclusive where 0 means 0% of
         * the parent size and 1 means 100% of the parent size.
         *
         * @param {Object} newValue
         * @param {number} [newValue.x] The x-axis proportionalSize to apply.
         * @param {number} [newValue.y] The y-axis proportionalSize to apply.
         * @param {number} [newValue.z] The z-axis proportionalSize to apply.
         */
        proportionalSize: {
            set(newValue) {
                this._setPropertyXYZ(Sizeable, 'proportionalSize', newValue)
            },
            get() {
                return this._properties.proportionalSize
            },
            configurable: true,
            enumerable: true,
        },

        /**
         * Set all properties of a Sizeable in one method.
         *
         * @param {Object} properties Properties object - see example
         *
         * @example
         * node.properties = {
         *   sizeMode: {x:'absolute', y:'proportional', z:'absolute'},
         *   absoluteSize: {x:300, y:100, z:200},
         *   proportionalSize: {x:1, z:0.5}
         * }
         */
        properties: {
            set(properties) {
                if ( properties === void 0 ) properties = {};

                if (properties.sizeMode)
                    { this.sizeMode = properties.sizeMode }

                if (properties.absoluteSize)
                    { this.absoluteSize = properties.absoluteSize }

                if (properties.proportionalSize)
                    { this.proportionalSize = properties.proportionalSize }
            },
            // no need for a properties getter.
            configurable: true,
        },
    })

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    makeLowercaseSetterAliases(Sizeable.prototype)

    Object.defineProperty(Sizeable, Symbol.hasInstance, {
        value: function(obj) {
            if (this !== Sizeable) { return Object.getPrototypeOf(Sizeable)[Symbol.hasInstance].call(this, obj) }

            let currentProto = obj

            while (currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor")

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))
                    { return true }

                currentProto = Object.getPrototypeOf(currentProto)
            }

            return false
        }
    })

    Sizeable[instanceofSymbol] = true

    return Sizeable
}

const Sizeable = SizeableMixin(class{})
Sizeable.mixin = SizeableMixin

export {Sizeable as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2l6ZWFibGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL1NpemVhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VMb3dlcmNhc2VTZXR0ZXJBbGlhc2VzIH0gZnJvbSAnLi9VdGlsaXR5J1xuaW1wb3J0IFRyZWVOb2RlIGZyb20gJy4vVHJlZU5vZGUnXG5pbXBvcnQgWFlaVmFsdWVzIGZyb20gJy4vWFlaVmFsdWVzJ1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi9PYnNlcnZhYmxlJ1xuaW1wb3J0IE1vdG9yIGZyb20gJy4vTW90b3InXG5cbi8vIGZhbGxiYWNrIHRvIGV4cGVyaW1lbnRhbCBDU1MgdHJhbnNmb3JtIGlmIGJyb3dzZXIgZG9lc24ndCBoYXZlIGl0IChmaXggZm9yIFNhZmFyaSA5KVxuaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZS50cmFuc2Zvcm0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsICd0cmFuc2Zvcm0nLCB7XG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53ZWJraXRUcmFuc2Zvcm0gPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJraXRUcmFuc2Zvcm1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9KVxufVxuXG5jbGFzcyBYWVpOb25OZWdhdGl2ZVZhbHVlcyBleHRlbmRzIFhZWlZhbHVlcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHopXG4gICAgfVxuXG4gICAgX2NoZWNrRm9yTmVnYXRpdmUoYXhpc05hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGF4aXNOYW1lICsgXCIgdmFsdWUgd2FzIFwiICsgdmFsdWUgKyBcIi4gU2l6ZSB2YWx1ZXMgY2Fubm90IGJlIG5lZ2F0aXZlLlwiKVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmNvbnN0IHtzZXQ6IHN1cGVyWFNldH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFhZWlZhbHVlcy5wcm90b3R5cGUsICd4JylcbmNvbnN0IHtzZXQ6IHN1cGVyWVNldH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFhZWlZhbHVlcy5wcm90b3R5cGUsICd5JylcbmNvbnN0IHtzZXQ6IHN1cGVyWlNldH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFhZWlZhbHVlcy5wcm90b3R5cGUsICd6JylcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhYWVpOb25OZWdhdGl2ZVZhbHVlcy5wcm90b3R5cGUsIHtcbiAgICB4OiB7XG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JOZWdhdGl2ZShcIlhcIiwgdmFsdWUpXG4gICAgICAgICAgICBzdXBlclhTZXQuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB5OiB7XG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JOZWdhdGl2ZShcIllcIiwgdmFsdWUpXG4gICAgICAgICAgICBzdXBlcllTZXQuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgejoge1xuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yTmVnYXRpdmUoXCJaXCIsIHZhbHVlKVxuICAgICAgICAgICAgc3VwZXJaU2V0LmNhbGwodGhpcywgdmFsdWUpXG4gICAgICB9XG4gICAgfSxcbn0pXG5cblxuXG5jb25zdCBpbnN0YW5jZW9mU3ltYm9sID0gU3ltYm9sKCdpbnN0YW5jZW9mU3ltYm9sJylcblxuY29uc3QgU2l6ZWFibGVNaXhpbiA9IGJhc2UgPT4ge1xuXG4gICAgLy8gU2l6ZWFibGUgZXh0ZW5kcyBUcmVlTm9kZSBiZWNhdXNlIFNpemVhYmxlIGtub3dzIGFib3V0IGl0cyBfcGFyZW50IHdoZW5cbiAgICAvLyBjYWxjdWxhdGluZyBwcm9wb3J0aW9uYWxTaXplLiBBbHNvIFRyYW5zZm9ybWFibGUga25vd3MgYWJvdXQgaXQncyBwYXJlbnRcbiAgICAvLyBpbiBvcmRlciB0byBjYWxjdWxhdGUgaXQncyB3b3JsZCBtYXRyaXggYmFzZWQgb24gaXQncyBwYXJlbnQncy5cbiAgICBjbGFzcyBTaXplYWJsZSBleHRlbmRzIFRyZWVOb2RlLm1peGluKE9ic2VydmFibGUubWl4aW4oYmFzZSkpIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5RnVuY3Rpb25zID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZFNpemUgPSB7IHg6MCwgeTowLCB6OjAgfVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHt9XG4gICAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllcygpXG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eU9ic2VydmVycygpXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICBfc2V0RGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICBzaXplTW9kZTogICAgICAgICBuZXcgWFlaVmFsdWVzKCdhYnNvbHV0ZScsICdhYnNvbHV0ZScsICdhYnNvbHV0ZScpLFxuICAgICAgICAgICAgICAgIGFic29sdXRlU2l6ZTogICAgIG5ldyBYWVpOb25OZWdhdGl2ZVZhbHVlcygwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICBwcm9wb3J0aW9uYWxTaXplOiBuZXcgWFlaTm9uTmVnYXRpdmVWYWx1ZXMoMSwgMSwgMSksXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgX3NldFByb3BlcnR5T2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5zaXplTW9kZS5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAnc2l6ZU1vZGUnKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuYWJzb2x1dGVTaXplLm9uKCd2YWx1ZWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMudHJpZ2dlckV2ZW50KCdwcm9wZXJ0eWNoYW5nZScsICdhYnNvbHV0ZVNpemUnKSlcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMucHJvcG9ydGlvbmFsU2l6ZS5vbigndmFsdWVjaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnRyaWdnZXJFdmVudCgncHJvcGVydHljaGFuZ2UnLCAncHJvcG9ydGlvbmFsU2l6ZScpKVxuICAgICAgICB9XG5cbiAgICAgICAgX2NhbGNTaXplKCkge1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZFNpemUgPSB0aGlzLl9jYWxjdWxhdGVkU2l6ZVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gey4uLmNhbGN1bGF0ZWRTaXplfVxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRTaXplID0gdGhpcy5fZ2V0UGFyZW50U2l6ZSgpXG5cbiAgICAgICAgICAgIGlmIChwcm9wcy5zaXplTW9kZS5feCA9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueCA9IHByb3BzLmFic29sdXRlU2l6ZS5feFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHByb3BvcnRpb25hbFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTaXplLnggPSBwYXJlbnRTaXplLnggKiBwcm9wcy5wcm9wb3J0aW9uYWxTaXplLl94XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wcy5zaXplTW9kZS5feSA9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueSA9IHByb3BzLmFic29sdXRlU2l6ZS5feVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHByb3BvcnRpb25hbFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTaXplLnkgPSBwYXJlbnRTaXplLnkgKiBwcm9wcy5wcm9wb3J0aW9uYWxTaXplLl95XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wcy5zaXplTW9kZS5feiA9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNpemUueiA9IHByb3BzLmFic29sdXRlU2l6ZS5felxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHByb3BvcnRpb25hbFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTaXplLnogPSBwYXJlbnRTaXplLnogKiBwcm9wcy5wcm9wb3J0aW9uYWxTaXplLl96XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NpemUueCAhPT0gY2FsY3VsYXRlZFNpemUueFxuICAgICAgICAgICAgICAgIHx8IHByZXZpb3VzU2l6ZS55ICE9PSBjYWxjdWxhdGVkU2l6ZS55XG4gICAgICAgICAgICAgICAgfHwgcHJldmlvdXNTaXplLnogIT09IGNhbGN1bGF0ZWRTaXplLnpcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdzaXplY2hhbmdlJywgey4uLmNhbGN1bGF0ZWRTaXplfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRQYXJlbnRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5fY2FsY3VsYXRlZFNpemUgOiB7eDowLHk6MCx6OjB9XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UHJvcGVydHlYWVooQ2xhc3MsIG5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwcmV2aW91cyB0YXNrIGlmIGFueS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnR5RnVuY3Rpb25zKSB0aGlzLl9wcm9wZXJ0eUZ1bmN0aW9ucyA9IG5ldyBNYXBcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm9wZXJ0eUZ1bmN0aW9ucy5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIE1vdG9yLnJlbW92ZVJlbmRlclRhc2sodGhpcy5fcHJvcGVydHlGdW5jdGlvbnMuZ2V0KG5hbWUpKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlGdW5jdGlvbnMuc2V0KG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIE1vdG9yLmFkZFJlbmRlclRhc2sodGltZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1tuYW1lXS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0ueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlGdW5jdGlvbnMuZGVsZXRlKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZVswXSAhPSAndW5kZWZpbmVkJykgdGhpcy5fcHJvcGVydGllc1tuYW1lXS54ID0gbmV3VmFsdWVbMF1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlWzFdICE9ICd1bmRlZmluZWQnKSB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLnkgPSBuZXdWYWx1ZVsxXVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWVbMl0gIT0gJ3VuZGVmaW5lZCcpIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0ueiA9IG5ld1ZhbHVlWzJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUueCAhPSAndW5kZWZpbmVkJykgdGhpcy5fcHJvcGVydGllc1tuYW1lXS54ID0gbmV3VmFsdWUueFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUueSAhPSAndW5kZWZpbmVkJykgdGhpcy5fcHJvcGVydGllc1tuYW1lXS55ID0gbmV3VmFsdWUueVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUueiAhPSAndW5kZWZpbmVkJykgdGhpcy5fcHJvcGVydGllc1tuYW1lXS56ID0gbmV3VmFsdWUuelxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJHtDbGFzcy5uYW1lfSMke25hbWV9LmApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UHJvcGVydHlTaW5nbGUoQ2xhc3MsIG5hbWUsIG5ld1ZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgbmV3VmFsdWUgPT0gdHlwZSB8fCBuZXdWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAke0NsYXNzLm5hbWV9IyR7bmFtZX0uYClcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgcHJldmlvdXMgdGFzayBpZiBhbnkuXG4gICAgICAgICAgICAgICAgTW90b3IuYWRkUmVuZGVyVGFzayh0aW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3VmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZXN1bHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1tuYW1lXSA9IG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgbmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW5kZXIoKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHlldCwgYnV0IG5lZWRlZCBiZWNhdXNlIEltcGVyYXRpdmVCYXNlIGNhbGxzXG4gICAgICAgICAgICAvLyBgc3VwZXIuX3JlbmRlcigpYCwgd2hpY2ggd2lsbCBjYWxsIGVpdGhlciBUcmFuc2Zvcm1hYmxlJ3NcbiAgICAgICAgICAgIC8vIF9yZW5kZXIgb3IgU2l6ZWFibGUncyBfcmVuZGVyIGZvciBOb2RlIGFuZCBTY2VuZSBjbGFzc2VzLFxuICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2Ugc2V0IGFjY2Vzc29ycyBtYW51YWxseSBiZWNhdXNlIEJ1YmxlIGRvZXNuJ3QgbWFrZSB0aGVtIGNvbmZpZ3VyYWJsZVxuICAgIC8vIGFzIHBlciBzcGVjLiBBZGRpdGlvbmFsbHkgd2UncmUgbWFpbmcgdGhlc2Ugb25lcyBlbnVtZXJhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNpemVhYmxlLnByb3RvdHlwZSwge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHNpemUgbW9kZSBmb3IgZWFjaCBheGlzLiBQb3NzaWJsZSBzaXplIG1vZGVzIGFyZSBcImFic29sdXRlXCIgYW5kIFwicHJvcG9ydGlvbmFsXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnhdIFRoZSB4LWF4aXMgc2l6ZU1vZGUgdG8gYXBwbHkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueV0gVGhlIHktYXhpcyBzaXplTW9kZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHNpemVNb2RlIHRvIGFwcGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZU1vZGU6IHtcbiAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5WFlaKFNpemVhYmxlLCAnc2l6ZU1vZGUnLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMuc2l6ZU1vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS54XSBUaGUgeC1heGlzIGFic29sdXRlU2l6ZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS55XSBUaGUgeS1heGlzIGFic29sdXRlU2l6ZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIGFic29sdXRlU2l6ZSB0byBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIGFic29sdXRlU2l6ZToge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHlYWVooU2l6ZWFibGUsICdhYnNvbHV0ZVNpemUnLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMuYWJzb2x1dGVTaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgTm9kZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc2l6ZSBpc1xuICAgICAgICAgKiBwcm9wb3J0aW9uYWwsIGFzIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgTm9kZSBkZXBlbmRzIG9uIHRoZSBzaXplIG9mXG4gICAgICAgICAqIGl0J3MgcGFyZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkubnVtYmVyfSBBbiBPamVjdCB3aXRoIHgsIHksIGFuZCB6IHByb3BlcnRpZXMsIGVhY2hcbiAgICAgICAgICogcHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBjb21wdXRlZCBzaXplIG9mIHRoZSB4LCB5LCBhbmQgeiBheGVzXG4gICAgICAgICAqIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICovXG4gICAgICAgIGFjdHVhbFNpemU6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7eCx5LHp9ID0gdGhpcy5fY2FsY3VsYXRlZFNpemVcbiAgICAgICAgICAgICAgICByZXR1cm4ge3gseSx6fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc2l6ZSBvZiBhIE5vZGUgcHJvcG9ydGlvbmFsIHRvIHRoZSBzaXplIG9mIGl0J3MgcGFyZW50IE5vZGUuIFRoZVxuICAgICAgICAgKiB2YWx1ZXMgYXJlIGEgcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZSB3aGVyZSAwIG1lYW5zIDAlIG9mXG4gICAgICAgICAqIHRoZSBwYXJlbnQgc2l6ZSBhbmQgMSBtZWFucyAxMDAlIG9mIHRoZSBwYXJlbnQgc2l6ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3VmFsdWUueF0gVGhlIHgtYXhpcyBwcm9wb3J0aW9uYWxTaXplIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld1ZhbHVlLnldIFRoZSB5LWF4aXMgcHJvcG9ydGlvbmFsU2l6ZSB0byBhcHBseS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZS56XSBUaGUgei1heGlzIHByb3BvcnRpb25hbFNpemUgdG8gYXBwbHkuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9wb3J0aW9uYWxTaXplOiB7XG4gICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eVhZWihTaXplYWJsZSwgJ3Byb3BvcnRpb25hbFNpemUnLCBuZXdWYWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMucHJvcG9ydGlvbmFsU2l6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBhbGwgcHJvcGVydGllcyBvZiBhIFNpemVhYmxlIGluIG9uZSBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgb2JqZWN0IC0gc2VlIGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgKiAgIHNpemVNb2RlOiB7eDonYWJzb2x1dGUnLCB5Oidwcm9wb3J0aW9uYWwnLCB6OidhYnNvbHV0ZSd9LFxuICAgICAgICAgKiAgIGFic29sdXRlU2l6ZToge3g6MzAwLCB5OjEwMCwgejoyMDB9LFxuICAgICAgICAgKiAgIHByb3BvcnRpb25hbFNpemU6IHt4OjEsIHo6MC41fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBzZXQocHJvcGVydGllcyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuc2l6ZU1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZU1vZGUgPSBwcm9wZXJ0aWVzLnNpemVNb2RlXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5hYnNvbHV0ZVNpemUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVTaXplID0gcHJvcGVydGllcy5hYnNvbHV0ZVNpemVcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnByb3BvcnRpb25hbFNpemUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcG9ydGlvbmFsU2l6ZSA9IHByb3BlcnRpZXMucHJvcG9ydGlvbmFsU2l6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgZm9yIGEgcHJvcGVydGllcyBnZXR0ZXIuXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSlcblxuICAgIC8vIGZvciB1c2UgYnkgTW90b3JIVE1MLCBjb252ZW5pZW50IHNpbmNlIEhUTUxFbGVtZW50IGF0dHJpYnV0ZXMgYXJlIGFsbFxuICAgIC8vIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYnkgZGVmYXVsdCwgc28gaWYgd2UgZG9uJ3QgZG8gdGhpcyB0aGVuIHdlIHdvbid0IGJlXG4gICAgLy8gYWJsZSB0byBtYXAgYXR0cmlidXRlcyB0byBOb2RlIHNldHRlcnMgYXMgZWFzaWx5LlxuICAgIG1ha2VMb3dlcmNhc2VTZXR0ZXJBbGlhc2VzKFNpemVhYmxlLnByb3RvdHlwZSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaXplYWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBTaXplYWJsZSkgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihTaXplYWJsZSlbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHRoaXMsIG9iailcblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm90byA9IG9ialxuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudFByb3RvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFByb3RvLCBcImNvbnN0cnVjdG9yXCIpXG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLnZhbHVlICYmIGRlc2MudmFsdWUuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VvZlN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudFByb3RvKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBTaXplYWJsZVtpbnN0YW5jZW9mU3ltYm9sXSA9IHRydWVcblxuICAgIHJldHVybiBTaXplYWJsZVxufVxuXG5jb25zdCBTaXplYWJsZSA9IFNpemVhYmxlTWl4aW4oY2xhc3N7fSlcblNpemVhYmxlLm1peGluID0gU2l6ZWFibGVNaXhpblxuXG5leHBvcnQge1NpemVhYmxlIGFzIGRlZmF1bHR9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUywwQkFBMEIsUUFBUSxXQUFXO0FBQ3RELE9BQU8sUUFBUSxNQUFNLFlBQVk7QUFDakMsT0FBTyxTQUFTLE1BQU0sYUFBYTtBQUNuQyxPQUFPLFVBQVUsTUFBTSxjQUFjO0FBQ3JDLE9BQU8sS0FBSyxNQUFNLFNBQVM7OztBQUczQixJQUFJLE9BQU8sUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLFdBQVcsRUFBRTtJQUNyRSxNQUFNLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUU7UUFDOUQsR0FBRyxDQUFDLEtBQUssRUFBRTtZQUNQLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSztTQUMvQjtRQUNELEdBQUcsR0FBRztZQUNGLE9BQU8sSUFBSSxDQUFDLGVBQWU7U0FDOUI7UUFDRCxVQUFVLEVBQUUsSUFBSTtLQUNuQixDQUFDO0NBQ0w7O0FBRUQsTUFBTSxvQkFBb0IsU0FBUyxTQUFTLENBQUM7O0lBRXpDLFdBQVcsQ0FBQyxDQUFLLEVBQUUsQ0FBSyxFQUFFLENBQUssRUFBRSxDQUFwQjs2QkFBQSxHQUFHLENBQUMsQ0FBRzs2QkFBQSxHQUFHLENBQUMsQ0FBRzs2QkFBQSxHQUFHLENBQUM7QUFBRztRQUM5QixLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDakI7O0lBRUQsaUJBQWlCLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRTtRQUMvQixHQUFHLEtBQUssR0FBRyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsR0FBRyxhQUFhLEdBQUcsS0FBSyxHQUFHLG1DQUFtQyxDQUFDO1NBQzFGO0tBQ0o7O0NBRUo7O0FBRUQsQUFBc0IsT0FBQSxHQUFHLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQztBQUF0RSxJQUFBLFNBQVMsV0FBZixBQUFlLEFBQTZEO0FBQ2xGLEFBQXNCLFNBQUEsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUM7QUFBdEUsSUFBQSxTQUFTLGFBQWYsQUFBZSxBQUE2RDtBQUNsRixBQUFzQixTQUFBLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDO0FBQXRFLElBQUEsU0FBUyxhQUFmLEFBQWUsQUFBNkQ7OztBQUdsRixNQUFNLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsU0FBUyxFQUFFO0lBQ3BELENBQUMsRUFBRTtRQUNDLEdBQUcsQ0FBQyxLQUFLLEVBQUU7WUFDUCxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQztZQUNsQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUM7U0FDOUI7S0FDSjs7SUFFRCxDQUFDLEVBQUU7UUFDQyxHQUFHLENBQUMsS0FBSyxFQUFFO1lBQ1AsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUM7WUFDbEMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO09BQ2hDO0tBQ0Y7O0lBRUQsQ0FBQyxFQUFFO1FBQ0MsR0FBRyxDQUFDLEtBQUssRUFBRTtZQUNQLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1lBQ2xDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQztPQUNoQztLQUNGO0NBQ0osQ0FBQzs7OztBQUlGLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDOztBQUVuRCxNQUFNLGFBQWEsR0FBRyxJQUFJLElBQUk7Ozs7O0lBSzFCLE1BQU0sUUFBUSxTQUFTLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOztRQUUxRCxXQUFXLENBQUMsT0FBWSxFQUFFLENBQVA7NkNBQUEsR0FBRyxFQUFFO0FBQUc7WUFDdkIsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7WUFFZCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSTtZQUM5QixJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDeEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUM1QixJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPO1NBQzVCOztRQUVELHFCQUFxQixHQUFHO1lBQ3BCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDNUIsUUFBUSxVQUFVLElBQUksU0FBUyxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDO2dCQUNuRSxZQUFZLE1BQU0sSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDbkQsZ0JBQWdCLEVBQUUsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN0RCxDQUFDO1NBQ0w7O1FBRUQscUJBQXFCLEdBQUc7WUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLGNBQWM7Z0JBQ3ZDLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUMxRCxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsY0FBYztnQkFDM0MsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQzlELElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLGNBQWM7Z0JBQy9DLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JFOztRQUVELFNBQVMsR0FBRztZQUNSLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxlQUFlO1lBQzNDLE1BQU0sWUFBWSxHQUFHLGtCQUFDLEFBQUcsY0FBYyxDQUFDO1lBQ3hDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXO1lBQzlCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUU7O1lBRXhDLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksVUFBVSxFQUFFO2dCQUNqQyxjQUFjLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRTthQUMzQztpQkFDSTtnQkFDRCxjQUFjLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7YUFDOUQ7O1lBRUQsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxVQUFVLEVBQUU7Z0JBQ2pDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxFQUFFO2FBQzNDO2lCQUNJO2dCQUNELGNBQWMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRTthQUM5RDs7WUFFRCxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLFVBQVUsRUFBRTtnQkFDakMsY0FBYyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUU7YUFDM0M7aUJBQ0k7Z0JBQ0QsY0FBYyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO2FBQzlEOztZQUVEO2dCQUNJLFlBQVksQ0FBQyxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUM7bUJBQ2hDLFlBQVksQ0FBQyxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUM7bUJBQ25DLFlBQVksQ0FBQyxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUM7Y0FDeEM7Z0JBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLEVBQUUsa0JBQUMsQUFBRyxjQUFjLENBQUMsQ0FBQzthQUN2RDtTQUNKOztRQUVELGNBQWMsR0FBRztZQUNiLE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JFOztRQUVELGVBQWUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtZQUNuQyxJQUFJLFFBQVEsWUFBWSxRQUFRLEVBQUU7O2dCQUU5QixJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUEsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFBOztnQkFFL0QsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztvQkFDakMsRUFBQSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFBOztnQkFFN0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJO29CQUM1QixLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSTt3QkFDeEIsTUFBTSxNQUFNLEdBQUcsUUFBUTs0QkFDbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzRCQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7NEJBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs0QkFDeEIsSUFBSTt5QkFDUDs7d0JBRUQsSUFBSSxNQUFNLEtBQUssS0FBSyxFQUFFOzRCQUNsQixJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQzs0QkFDcEMsT0FBTyxLQUFLO3lCQUNmOzt3QkFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTTtxQkFDdEIsQ0FBQztpQkFDTDthQUNKO2lCQUNJLElBQUksUUFBUSxZQUFZLEtBQUssRUFBRTtnQkFDaEMsSUFBSSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLEVBQUUsRUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUE7Z0JBQzdFLElBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxFQUFFLEVBQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFBO2dCQUM3RSxJQUFJLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsRUFBRSxFQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBQTthQUNoRjtpQkFDSSxJQUFJLFFBQVEsWUFBWSxNQUFNLEVBQUU7Z0JBQ2pDLElBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxJQUFJLFdBQVcsRUFBRSxFQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUE7Z0JBQzNFLElBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxJQUFJLFdBQVcsRUFBRSxFQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUE7Z0JBQzNFLElBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxJQUFJLFdBQVcsRUFBRSxFQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUE7YUFDOUU7aUJBQ0k7Z0JBQ0QsTUFBTSxJQUFJLFNBQVMsQ0FBQyxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNsRTtTQUNKOztRQUVELGtCQUFrQixDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtZQUM1QyxJQUFJLENBQUMsQ0FBQyxPQUFPLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxZQUFZLFFBQVEsQ0FBQztnQkFDMUQsRUFBQSxNQUFNLElBQUksU0FBUyxDQUFDLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUE7O1lBRW5FLElBQUksUUFBUSxZQUFZLFFBQVEsRUFBRTs7Z0JBRTlCLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJO29CQUN4QixNQUFNLE1BQU0sR0FBRyxRQUFRO3dCQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQzt3QkFDdEIsSUFBSTtxQkFDUDs7b0JBRUQsSUFBSSxNQUFNLEtBQUssS0FBSyxFQUFFLEVBQUEsT0FBTyxLQUFLLEVBQUE7O29CQUVsQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTTtpQkFDdEIsQ0FBQzthQUNMO2lCQUNJO2dCQUNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUTtnQkFDakMsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUM7YUFDNUM7U0FDSjs7UUFFRCxPQUFPLEdBQUc7Ozs7O1NBS1Q7S0FDSjs7OztJQUlELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFOzs7Ozs7Ozs7O1FBVXhDLFFBQVEsRUFBRTtZQUNOLEdBQUcsQ0FBQyxRQUFRLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQzthQUN2RDtZQUNELEdBQUcsR0FBRztnQkFDRixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUTthQUNuQztZQUNELFlBQVksRUFBRSxJQUFJO1lBQ2xCLFVBQVUsRUFBRSxJQUFJO1NBQ25COzs7Ozs7OztRQVFELFlBQVksRUFBRTtZQUNWLEdBQUcsQ0FBQyxRQUFRLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsY0FBYyxFQUFFLFFBQVEsQ0FBQzthQUMzRDtZQUNELEdBQUcsR0FBRztnQkFDRixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWTthQUN2QztZQUNELFlBQVksRUFBRSxJQUFJO1lBQ2xCLFVBQVUsRUFBRSxJQUFJO1NBQ25COzs7Ozs7Ozs7Ozs7O1FBYUQsVUFBVSxFQUFFO1lBQ1IsR0FBRyxHQUFHO2dCQUNGLEFBQWEsT0FBQSxHQUFHLElBQUksQ0FBQyxlQUFlO2dCQUE3QixJQUFBLENBQUM7Z0JBQUMsSUFBQSxDQUFDO2dCQUFDLElBQUEsQ0FBQyxTQUFOLEFBQUUsQUFBRSxBQUFFLEFBQXdCO2dCQUNwQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDakI7WUFDRCxZQUFZLEVBQUUsSUFBSTtZQUNsQixVQUFVLEVBQUUsSUFBSTtTQUNuQjs7Ozs7Ozs7Ozs7O1FBWUQsZ0JBQWdCLEVBQUU7WUFDZCxHQUFHLENBQUMsUUFBUSxFQUFFO2dCQUNWLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLGtCQUFrQixFQUFFLFFBQVEsQ0FBQzthQUMvRDtZQUNELEdBQUcsR0FBRztnQkFDRixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCO2FBQzNDO1lBQ0QsWUFBWSxFQUFFLElBQUk7WUFDbEIsVUFBVSxFQUFFLElBQUk7U0FDbkI7Ozs7Ozs7Ozs7Ozs7O1FBY0QsVUFBVSxFQUFFO1lBQ1IsR0FBRyxDQUFDLFVBQWUsRUFBRSxDQUFQO3VEQUFBLEdBQUcsRUFBRTtBQUFHO2dCQUNsQixJQUFJLFVBQVUsQ0FBQyxRQUFRO29CQUNuQixFQUFBLElBQUksQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLFFBQVEsRUFBQTs7Z0JBRXZDLElBQUksVUFBVSxDQUFDLFlBQVk7b0JBQ3ZCLEVBQUEsSUFBSSxDQUFDLFlBQVksR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFBOztnQkFFL0MsSUFBSSxVQUFVLENBQUMsZ0JBQWdCO29CQUMzQixFQUFBLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsZ0JBQWdCLEVBQUE7YUFDMUQ7O1lBRUQsWUFBWSxFQUFFLElBQUk7U0FDckI7S0FDSixDQUFDOzs7OztJQUtGLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7O0lBRTlDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUU7UUFDaEQsS0FBSyxFQUFFLFNBQVMsR0FBRyxFQUFFO1lBQ2pCLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRSxFQUFBLE9BQU8sTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBQTs7WUFFakcsSUFBSSxZQUFZLEdBQUcsR0FBRzs7WUFFdEIsT0FBTyxZQUFZLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDOztnQkFFekUsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDakUsRUFBQSxPQUFPLElBQUksRUFBQTs7Z0JBRWYsWUFBWSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDO2FBQ3JEOztZQUVELE9BQU8sS0FBSztTQUNmO0tBQ0osQ0FBQzs7SUFFRixRQUFRLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxJQUFJOztJQUVqQyxPQUFPLFFBQVE7Q0FDbEI7O0FBRUQsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3ZDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsYUFBYTs7QUFFOUIsUUFBUSxRQUFRLElBQUksT0FBTyxDQUFDOyJ9