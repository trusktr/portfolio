import documentReady from 'awaitbox/dom/documentReady'
import Transformable from './Transformable'
import getWebGlRenderer from './WebGLRenderer'
import {isInstanceof} from './Utility'

import {
    //animationFrame,
} from './Utility'

let documentIsReady = false
let webGLRenderer = null

class Motor {
    constructor() {
        this._inFrame = false // true when inside a requested animation frame.
        this._rAF = null // the current animation frame, or null.
        this._animationLoopStarted = false
        this._allRenderTasks = []
        this._taskIterationIndex = 0
        this._numberOfTasks = 0
        this._nodesToBeRendered = []
        this._modifiedScenes = []

        // A set of nodes that are the root nodes of subtrees where all nodes
        // in each subtree need to have their world matrices updated.
        this._worldMatrixRootNodes = []
    }

    /**
     * Starts an rAF loop and runs the render tasks in the _renderTasks stack.
     * As long as there are tasks in the stack, the loop continues. When the
     * stack becomes empty due to removal of tasks, the rAF stops and the app
     * sits there doing nothing -- silence, crickets.
     */
    _startAnimationLoop() {
        if (this._animationLoopStarted) { return Promise.resolve() }

        this._animationLoopStarted = true

        const logic = () => {
            // DIRECT ANIMATION LOOP ///////////////////////////////////
            // So now we can render after the scene is mounted.
            const motorLoop = timestamp => {
                this._inFrame = true

                this._runRenderTasks(timestamp)
                this._renderNodes(timestamp)

                // If any tasks are left to run, continue the animation loop.
                if (this._allRenderTasks.length)
                    { this._rAF = requestAnimationFrame(motorLoop) }
                else {
                    this._rAF = null
                    this._animationLoopStarted = false
                }

                this._inFrame = false
            }

            this._rAF = requestAnimationFrame(motorLoop)
        }

        if (!documentIsReady) {
            return documentReady().then(() => {
                documentIsReady = true
                logic()
            })
        }

        logic()
        return Promise.resolve()
    }
    //async _startAnimationLoop() {
        //if (this._animationLoopStarted) return

        //this._animationLoopStarted = true

        //if (!documentIsReady) {
            //await documentReady()
            //documentIsReady = true
        //}

        //// DIRECT ANIMATION LOOP ///////////////////////////////////
        //// So now we can render after the scene is mounted.
        //const motorLoop = timestamp => {
            //this._inFrame = true

            //this._runRenderTasks(timestamp)
            //this._renderNodes(timestamp)

            //// If any tasks are left to run, continue the animation loop.
            //if (this._allRenderTasks.length)
                //this._rAF = requestAnimationFrame(motorLoop)
            //else {
                //this._rAF = null
                //this._animationLoopStarted = false
            //}

            //this._inFrame = false
        //}

        //this._rAF = requestAnimationFrame(motorLoop)

        //// ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////
        ////this._rAF = true
        ////let timestamp = null
        ////while (this._rAF) {
            ////timestamp = await animationFrame()
            ////this._inFrame = true

            ////this._runRenderTasks(timestamp)
            ////this._renderNodes(timestamp)

            ////// If any tasks are left to run, continue the animation loop.
            ////if (!this._allRenderTasks.length) {
                ////this._rAF = null
                ////this._animationLoopStarted = false
            ////}

            ////this._inFrame = false
        ////}
    //}

    /**
     * When a render tasks is added a new rAF loop will be started if there
     * isn't one currently.
     *
     * A render task is simply a function that will be called over and over
     * again, in the Motor's animation loop. That's all, nothing special.
     * However, if a Node setter is used inside of a render task, then the Node
     * will tell Motor that it needs to be re-rendered, which will happen at
     * the end of the current frame. If a Node setter is used outside of a
     * render task (i.e. outside of the Motor's animation loop), then the Node
     * tells Motor to re-render the Node on the next animation loop tick.
     * Basically, regardless of where the Node's setters are used (inside or
     * outside of the Motor's animation loop), rendering always happens inside
     * the loop.
     *
     * @param {Function} fn The render task to add.
     * @return {Function} A reference to the render task. Useful for saving to
     * a variable so that it can later be passed to Motor.removeRenderTask().
     */
    addRenderTask(fn) {
        if (typeof fn != 'function')
            { throw new Error('Render task must be a function.') }

        if (this._allRenderTasks.includes(fn)) { return }

        this._allRenderTasks.push(fn)
        this._numberOfTasks += 1

        // If the render loop isn't started, start it.
        if (!this._animationLoopStarted)
            { this._startAnimationLoop() }

        return fn
    }

    removeRenderTask(fn) {
        const taskIndex = this._allRenderTasks.indexOf(fn)

        if (taskIndex == -1) { return }

        this._allRenderTasks.splice(taskIndex, 1)
        this._numberOfTasks -= 1
        this._taskIterationIndex -= 1
    }

    _runRenderTasks(timestamp) {
        for (this._taskIterationIndex = 0; this._taskIterationIndex < this._numberOfTasks; this._taskIterationIndex += 1) {
            const task = this._allRenderTasks[this._taskIterationIndex]

            if (task(timestamp) === false)
                { this.removeRenderTask(task) }
        }
    }

    _setNodeToBeRendered(node) {
        if (this._nodesToBeRendered.includes(node)) { return }
        this._nodesToBeRendered.push(node)
        if (!this._inFrame) { this._startAnimationLoop() }
    }

    _renderNodes(timestamp) {
        if (!this._nodesToBeRendered.length) { return }

        for (let i=0, l=this._nodesToBeRendered.length; i<l; i+=1) {
            const node = this._nodesToBeRendered[i]

            node._render(timestamp)

            // If the node is root of a subtree containing updated nodes and
            // has no ancestors that were modified, then add it to the
            // _worldMatrixRootNodes set so we can update the world matrices of
            // all the nodes in the root node's subtree.
            if (
                // a node could be a Scene, which is not Transformable
                isInstanceof(node, Transformable) &&

                // and if ancestor is not instanceof Transformable, f.e.
                // `false` if there is no ancestor to be rendered, or Sizeable
                // if the Scene is returned.
                !isInstanceof(node._getAncestorToBeRendered(), Transformable) &&

                // and the node isn't already added.
                !this._worldMatrixRootNodes.includes(node)
            ) {
                this._worldMatrixRootNodes.push(node)
            }

            // keep track of which scenes are modified so we can render webgl
            // only for those scenes.
            // TODO FIXME: at this point, a node should always have a scene,
            // otherwise it should not ever be rendered here, but turns out
            // some nodes are getting into this queue without a scene. We
            // shouldn't need the conditional check for node._scene, and it
            // will save CPU by not allowing the code to get here in that case.
            if (node._scene && !this._modifiedScenes.includes(node._scene))
                { this._modifiedScenes.push(node._scene) }
        }

        // Update world matrices of the subtrees.
        const worldMatrixRootNodes = this._worldMatrixRootNodes
        for (let i=0, l=worldMatrixRootNodes.length; i<l; i+=1) {
            const subtreeRoot = worldMatrixRootNodes[i]
            subtreeRoot._calculateWorldMatricesInSubtree()
        }
        worldMatrixRootNodes.length = 0

        // render webgl of modified scenes.
        const modifiedScenes = this._modifiedScenes
        // TODO PERFORMANCE: store a list of webgl-enabled modified scenes, and
        // iterate only through those so we don't iterate over non-webgl
        // scenes.
        for (let i=0, l=modifiedScenes.length; i<l; i+=1) {
            const sceneElement = modifiedScenes[i].element
            // TODO we're temporarily storing stuff on the .element, but we
            // don't want that, we will move it to WebGLRenderer.
            if (
                sceneElement.webglEnabled &&
                ( webGLRenderer || (webGLRenderer = getWebGlRenderer()) ) // only ever call getWebGlRenderer once
            )
                { webGLRenderer.drawScene(sceneElement) }
        }
        modifiedScenes.length = 0

        const nodesToBeRendered = this._nodesToBeRendered
        for (let i=0, l=nodesToBeRendered.length; i<l; i+=1) {
            nodesToBeRendered[i]._willBeRendered = false
        }
        nodesToBeRendered.length = 0
    }
}

// export a singleton instance rather than the class directly.
export default new Motor

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW90b3IuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL01vdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkb2N1bWVudFJlYWR5IGZyb20gJ2F3YWl0Ym94L2RvbS9kb2N1bWVudFJlYWR5J1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnLi9UcmFuc2Zvcm1hYmxlJ1xuaW1wb3J0IGdldFdlYkdsUmVuZGVyZXIgZnJvbSAnLi9XZWJHTFJlbmRlcmVyJ1xuaW1wb3J0IHtpc0luc3RhbmNlb2Z9IGZyb20gJy4vVXRpbGl0eSdcblxuaW1wb3J0IHtcbiAgICAvL2FuaW1hdGlvbkZyYW1lLFxufSBmcm9tICcuL1V0aWxpdHknXG5cbmxldCBkb2N1bWVudElzUmVhZHkgPSBmYWxzZVxubGV0IHdlYkdMUmVuZGVyZXIgPSBudWxsXG5cbmNsYXNzIE1vdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW5GcmFtZSA9IGZhbHNlIC8vIHRydWUgd2hlbiBpbnNpZGUgYSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICB0aGlzLl9yQUYgPSBudWxsIC8vIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZSwgb3IgbnVsbC5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9hbGxSZW5kZXJUYXNrcyA9IFtdXG4gICAgICAgIHRoaXMuX3Rhc2tJdGVyYXRpb25JbmRleCA9IDBcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUYXNrcyA9IDBcbiAgICAgICAgdGhpcy5fbm9kZXNUb0JlUmVuZGVyZWQgPSBbXVxuICAgICAgICB0aGlzLl9tb2RpZmllZFNjZW5lcyA9IFtdXG5cbiAgICAgICAgLy8gQSBzZXQgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZXMgb2Ygc3VidHJlZXMgd2hlcmUgYWxsIG5vZGVzXG4gICAgICAgIC8vIGluIGVhY2ggc3VidHJlZSBuZWVkIHRvIGhhdmUgdGhlaXIgd29ybGQgbWF0cmljZXMgdXBkYXRlZC5cbiAgICAgICAgdGhpcy5fd29ybGRNYXRyaXhSb290Tm9kZXMgPSBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhbiByQUYgbG9vcCBhbmQgcnVucyB0aGUgcmVuZGVyIHRhc2tzIGluIHRoZSBfcmVuZGVyVGFza3Mgc3RhY2suXG4gICAgICogQXMgbG9uZyBhcyB0aGVyZSBhcmUgdGFza3MgaW4gdGhlIHN0YWNrLCB0aGUgbG9vcCBjb250aW51ZXMuIFdoZW4gdGhlXG4gICAgICogc3RhY2sgYmVjb21lcyBlbXB0eSBkdWUgdG8gcmVtb3ZhbCBvZiB0YXNrcywgdGhlIHJBRiBzdG9wcyBhbmQgdGhlIGFwcFxuICAgICAqIHNpdHMgdGhlcmUgZG9pbmcgbm90aGluZyAtLSBzaWxlbmNlLCBjcmlja2V0cy5cbiAgICAgKi9cbiAgICBfc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkxvb3BTdGFydGVkID0gdHJ1ZVxuXG4gICAgICAgIGNvbnN0IGxvZ2ljID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gRElSRUNUIEFOSU1BVElPTiBMT09QIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBTbyBub3cgd2UgY2FuIHJlbmRlciBhZnRlciB0aGUgc2NlbmUgaXMgbW91bnRlZC5cbiAgICAgICAgICAgIGNvbnN0IG1vdG9yTG9vcCA9IHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5GcmFtZSA9IHRydWVcblxuICAgICAgICAgICAgICAgIHRoaXMuX3J1blJlbmRlclRhc2tzKHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJOb2Rlcyh0aW1lc3RhbXApXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgdGFza3MgYXJlIGxlZnQgdG8gcnVuLCBjb250aW51ZSB0aGUgYW5pbWF0aW9uIGxvb3AuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbFJlbmRlclRhc2tzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdG9yTG9vcClcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fckFGID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5GcmFtZSA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShtb3Rvckxvb3ApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRvY3VtZW50SXNSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50UmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudElzUmVhZHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgbG9naWMoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2ljKClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuICAgIC8vYXN5bmMgX3N0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICAgICAgLy9pZiAodGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQpIHJldHVyblxuXG4gICAgICAgIC8vdGhpcy5fYW5pbWF0aW9uTG9vcFN0YXJ0ZWQgPSB0cnVlXG5cbiAgICAgICAgLy9pZiAoIWRvY3VtZW50SXNSZWFkeSkge1xuICAgICAgICAgICAgLy9hd2FpdCBkb2N1bWVudFJlYWR5KClcbiAgICAgICAgICAgIC8vZG9jdW1lbnRJc1JlYWR5ID0gdHJ1ZVxuICAgICAgICAvL31cblxuICAgICAgICAvLy8vIERJUkVDVCBBTklNQVRJT04gTE9PUCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLy8vIFNvIG5vdyB3ZSBjYW4gcmVuZGVyIGFmdGVyIHRoZSBzY2VuZSBpcyBtb3VudGVkLlxuICAgICAgICAvL2NvbnN0IG1vdG9yTG9vcCA9IHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgICAvL3RoaXMuX2luRnJhbWUgPSB0cnVlXG5cbiAgICAgICAgICAgIC8vdGhpcy5fcnVuUmVuZGVyVGFza3ModGltZXN0YW1wKVxuICAgICAgICAgICAgLy90aGlzLl9yZW5kZXJOb2Rlcyh0aW1lc3RhbXApXG5cbiAgICAgICAgICAgIC8vLy8gSWYgYW55IHRhc2tzIGFyZSBsZWZ0IHRvIHJ1biwgY29udGludWUgdGhlIGFuaW1hdGlvbiBsb29wLlxuICAgICAgICAgICAgLy9pZiAodGhpcy5fYWxsUmVuZGVyVGFza3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC8vdGhpcy5fckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdG9yTG9vcClcbiAgICAgICAgICAgIC8vZWxzZSB7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9yQUYgPSBudWxsXG4gICAgICAgICAgICAgICAgLy90aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgLy90aGlzLl9pbkZyYW1lID0gZmFsc2VcbiAgICAgICAgLy99XG5cbiAgICAgICAgLy90aGlzLl9yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW90b3JMb29wKVxuXG4gICAgICAgIC8vLy8gQU5JTUFUSU9OIExPT1AgVVNJTkcgV0hJTEUgQU5EIEFXQUlUIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vLy90aGlzLl9yQUYgPSB0cnVlXG4gICAgICAgIC8vLy9sZXQgdGltZXN0YW1wID0gbnVsbFxuICAgICAgICAvLy8vd2hpbGUgKHRoaXMuX3JBRikge1xuICAgICAgICAgICAgLy8vL3RpbWVzdGFtcCA9IGF3YWl0IGFuaW1hdGlvbkZyYW1lKClcbiAgICAgICAgICAgIC8vLy90aGlzLl9pbkZyYW1lID0gdHJ1ZVxuXG4gICAgICAgICAgICAvLy8vdGhpcy5fcnVuUmVuZGVyVGFza3ModGltZXN0YW1wKVxuICAgICAgICAgICAgLy8vL3RoaXMuX3JlbmRlck5vZGVzKHRpbWVzdGFtcClcblxuICAgICAgICAgICAgLy8vLy8vIElmIGFueSB0YXNrcyBhcmUgbGVmdCB0byBydW4sIGNvbnRpbnVlIHRoZSBhbmltYXRpb24gbG9vcC5cbiAgICAgICAgICAgIC8vLy9pZiAoIXRoaXMuX2FsbFJlbmRlclRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vLy90aGlzLl9yQUYgPSBudWxsXG4gICAgICAgICAgICAgICAgLy8vL3RoaXMuX2FuaW1hdGlvbkxvb3BTdGFydGVkID0gZmFsc2VcbiAgICAgICAgICAgIC8vLy99XG5cbiAgICAgICAgICAgIC8vLy90aGlzLl9pbkZyYW1lID0gZmFsc2VcbiAgICAgICAgLy8vL31cbiAgICAvL31cblxuICAgIC8qKlxuICAgICAqIFdoZW4gYSByZW5kZXIgdGFza3MgaXMgYWRkZWQgYSBuZXcgckFGIGxvb3Agd2lsbCBiZSBzdGFydGVkIGlmIHRoZXJlXG4gICAgICogaXNuJ3Qgb25lIGN1cnJlbnRseS5cbiAgICAgKlxuICAgICAqIEEgcmVuZGVyIHRhc2sgaXMgc2ltcGx5IGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvdmVyIGFuZCBvdmVyXG4gICAgICogYWdhaW4sIGluIHRoZSBNb3RvcidzIGFuaW1hdGlvbiBsb29wLiBUaGF0J3MgYWxsLCBub3RoaW5nIHNwZWNpYWwuXG4gICAgICogSG93ZXZlciwgaWYgYSBOb2RlIHNldHRlciBpcyB1c2VkIGluc2lkZSBvZiBhIHJlbmRlciB0YXNrLCB0aGVuIHRoZSBOb2RlXG4gICAgICogd2lsbCB0ZWxsIE1vdG9yIHRoYXQgaXQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQsIHdoaWNoIHdpbGwgaGFwcGVuIGF0XG4gICAgICogdGhlIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZS4gSWYgYSBOb2RlIHNldHRlciBpcyB1c2VkIG91dHNpZGUgb2YgYVxuICAgICAqIHJlbmRlciB0YXNrIChpLmUuIG91dHNpZGUgb2YgdGhlIE1vdG9yJ3MgYW5pbWF0aW9uIGxvb3ApLCB0aGVuIHRoZSBOb2RlXG4gICAgICogdGVsbHMgTW90b3IgdG8gcmUtcmVuZGVyIHRoZSBOb2RlIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBsb29wIHRpY2suXG4gICAgICogQmFzaWNhbGx5LCByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBOb2RlJ3Mgc2V0dGVycyBhcmUgdXNlZCAoaW5zaWRlIG9yXG4gICAgICogb3V0c2lkZSBvZiB0aGUgTW90b3IncyBhbmltYXRpb24gbG9vcCksIHJlbmRlcmluZyBhbHdheXMgaGFwcGVucyBpbnNpZGVcbiAgICAgKiB0aGUgbG9vcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSByZW5kZXIgdGFzayB0byBhZGQuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXIgdGFzay4gVXNlZnVsIGZvciBzYXZpbmcgdG9cbiAgICAgKiBhIHZhcmlhYmxlIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHBhc3NlZCB0byBNb3Rvci5yZW1vdmVSZW5kZXJUYXNrKCkuXG4gICAgICovXG4gICAgYWRkUmVuZGVyVGFzayhmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlciB0YXNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuXG4gICAgICAgIGlmICh0aGlzLl9hbGxSZW5kZXJUYXNrcy5pbmNsdWRlcyhmbikpIHJldHVyblxuXG4gICAgICAgIHRoaXMuX2FsbFJlbmRlclRhc2tzLnB1c2goZm4pXG4gICAgICAgIHRoaXMuX251bWJlck9mVGFza3MgKz0gMVxuXG4gICAgICAgIC8vIElmIHRoZSByZW5kZXIgbG9vcCBpc24ndCBzdGFydGVkLCBzdGFydCBpdC5cbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpb25Mb29wU3RhcnRlZClcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uTG9vcCgpXG5cbiAgICAgICAgcmV0dXJuIGZuXG4gICAgfVxuXG4gICAgcmVtb3ZlUmVuZGVyVGFzayhmbikge1xuICAgICAgICBjb25zdCB0YXNrSW5kZXggPSB0aGlzLl9hbGxSZW5kZXJUYXNrcy5pbmRleE9mKGZuKVxuXG4gICAgICAgIGlmICh0YXNrSW5kZXggPT0gLTEpIHJldHVyblxuXG4gICAgICAgIHRoaXMuX2FsbFJlbmRlclRhc2tzLnNwbGljZSh0YXNrSW5kZXgsIDEpXG4gICAgICAgIHRoaXMuX251bWJlck9mVGFza3MgLT0gMVxuICAgICAgICB0aGlzLl90YXNrSXRlcmF0aW9uSW5kZXggLT0gMVxuICAgIH1cblxuICAgIF9ydW5SZW5kZXJUYXNrcyh0aW1lc3RhbXApIHtcbiAgICAgICAgZm9yICh0aGlzLl90YXNrSXRlcmF0aW9uSW5kZXggPSAwOyB0aGlzLl90YXNrSXRlcmF0aW9uSW5kZXggPCB0aGlzLl9udW1iZXJPZlRhc2tzOyB0aGlzLl90YXNrSXRlcmF0aW9uSW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHRoaXMuX2FsbFJlbmRlclRhc2tzW3RoaXMuX3Rhc2tJdGVyYXRpb25JbmRleF1cblxuICAgICAgICAgICAgaWYgKHRhc2sodGltZXN0YW1wKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSZW5kZXJUYXNrKHRhc2spXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0Tm9kZVRvQmVSZW5kZXJlZChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub2Rlc1RvQmVSZW5kZXJlZC5pbmNsdWRlcyhub2RlKSkgcmV0dXJuXG4gICAgICAgIHRoaXMuX25vZGVzVG9CZVJlbmRlcmVkLnB1c2gobm9kZSlcbiAgICAgICAgaWYgKCF0aGlzLl9pbkZyYW1lKSB0aGlzLl9zdGFydEFuaW1hdGlvbkxvb3AoKVxuICAgIH1cblxuICAgIF9yZW5kZXJOb2Rlcyh0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ub2Rlc1RvQmVSZW5kZXJlZC5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD10aGlzLl9ub2Rlc1RvQmVSZW5kZXJlZC5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzVG9CZVJlbmRlcmVkW2ldXG5cbiAgICAgICAgICAgIG5vZGUuX3JlbmRlcih0aW1lc3RhbXApXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIHJvb3Qgb2YgYSBzdWJ0cmVlIGNvbnRhaW5pbmcgdXBkYXRlZCBub2RlcyBhbmRcbiAgICAgICAgICAgIC8vIGhhcyBubyBhbmNlc3RvcnMgdGhhdCB3ZXJlIG1vZGlmaWVkLCB0aGVuIGFkZCBpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIF93b3JsZE1hdHJpeFJvb3ROb2RlcyBzZXQgc28gd2UgY2FuIHVwZGF0ZSB0aGUgd29ybGQgbWF0cmljZXMgb2ZcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHJvb3Qgbm9kZSdzIHN1YnRyZWUuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYSBub2RlIGNvdWxkIGJlIGEgU2NlbmUsIHdoaWNoIGlzIG5vdCBUcmFuc2Zvcm1hYmxlXG4gICAgICAgICAgICAgICAgaXNJbnN0YW5jZW9mKG5vZGUsIFRyYW5zZm9ybWFibGUpICYmXG5cbiAgICAgICAgICAgICAgICAvLyBhbmQgaWYgYW5jZXN0b3IgaXMgbm90IGluc3RhbmNlb2YgVHJhbnNmb3JtYWJsZSwgZi5lLlxuICAgICAgICAgICAgICAgIC8vIGBmYWxzZWAgaWYgdGhlcmUgaXMgbm8gYW5jZXN0b3IgdG8gYmUgcmVuZGVyZWQsIG9yIFNpemVhYmxlXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIFNjZW5lIGlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgICFpc0luc3RhbmNlb2Yobm9kZS5fZ2V0QW5jZXN0b3JUb0JlUmVuZGVyZWQoKSwgVHJhbnNmb3JtYWJsZSkgJiZcblxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgICAgICF0aGlzLl93b3JsZE1hdHJpeFJvb3ROb2Rlcy5pbmNsdWRlcyhub2RlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRNYXRyaXhSb290Tm9kZXMucHVzaChub2RlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHdoaWNoIHNjZW5lcyBhcmUgbW9kaWZpZWQgc28gd2UgY2FuIHJlbmRlciB3ZWJnbFxuICAgICAgICAgICAgLy8gb25seSBmb3IgdGhvc2Ugc2NlbmVzLlxuICAgICAgICAgICAgLy8gVE9ETyBGSVhNRTogYXQgdGhpcyBwb2ludCwgYSBub2RlIHNob3VsZCBhbHdheXMgaGF2ZSBhIHNjZW5lLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSByZW5kZXJlZCBoZXJlLCBidXQgdHVybnMgb3V0XG4gICAgICAgICAgICAvLyBzb21lIG5vZGVzIGFyZSBnZXR0aW5nIGludG8gdGhpcyBxdWV1ZSB3aXRob3V0IGEgc2NlbmUuIFdlXG4gICAgICAgICAgICAvLyBzaG91bGRuJ3QgbmVlZCB0aGUgY29uZGl0aW9uYWwgY2hlY2sgZm9yIG5vZGUuX3NjZW5lLCBhbmQgaXRcbiAgICAgICAgICAgIC8vIHdpbGwgc2F2ZSBDUFUgYnkgbm90IGFsbG93aW5nIHRoZSBjb2RlIHRvIGdldCBoZXJlIGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgIGlmIChub2RlLl9zY2VuZSAmJiAhdGhpcy5fbW9kaWZpZWRTY2VuZXMuaW5jbHVkZXMobm9kZS5fc2NlbmUpKVxuICAgICAgICAgICAgICAgIHRoaXMuX21vZGlmaWVkU2NlbmVzLnB1c2gobm9kZS5fc2NlbmUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgd29ybGQgbWF0cmljZXMgb2YgdGhlIHN1YnRyZWVzLlxuICAgICAgICBjb25zdCB3b3JsZE1hdHJpeFJvb3ROb2RlcyA9IHRoaXMuX3dvcmxkTWF0cml4Um9vdE5vZGVzXG4gICAgICAgIGZvciAobGV0IGk9MCwgbD13b3JsZE1hdHJpeFJvb3ROb2Rlcy5sZW5ndGg7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHJlZVJvb3QgPSB3b3JsZE1hdHJpeFJvb3ROb2Rlc1tpXVxuICAgICAgICAgICAgc3VidHJlZVJvb3QuX2NhbGN1bGF0ZVdvcmxkTWF0cmljZXNJblN1YnRyZWUoKVxuICAgICAgICB9XG4gICAgICAgIHdvcmxkTWF0cml4Um9vdE5vZGVzLmxlbmd0aCA9IDBcblxuICAgICAgICAvLyByZW5kZXIgd2ViZ2wgb2YgbW9kaWZpZWQgc2NlbmVzLlxuICAgICAgICBjb25zdCBtb2RpZmllZFNjZW5lcyA9IHRoaXMuX21vZGlmaWVkU2NlbmVzXG4gICAgICAgIC8vIFRPRE8gUEVSRk9STUFOQ0U6IHN0b3JlIGEgbGlzdCBvZiB3ZWJnbC1lbmFibGVkIG1vZGlmaWVkIHNjZW5lcywgYW5kXG4gICAgICAgIC8vIGl0ZXJhdGUgb25seSB0aHJvdWdoIHRob3NlIHNvIHdlIGRvbid0IGl0ZXJhdGUgb3ZlciBub24td2ViZ2xcbiAgICAgICAgLy8gc2NlbmVzLlxuICAgICAgICBmb3IgKGxldCBpPTAsIGw9bW9kaWZpZWRTY2VuZXMubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lRWxlbWVudCA9IG1vZGlmaWVkU2NlbmVzW2ldLmVsZW1lbnRcbiAgICAgICAgICAgIC8vIFRPRE8gd2UncmUgdGVtcG9yYXJpbHkgc3RvcmluZyBzdHVmZiBvbiB0aGUgLmVsZW1lbnQsIGJ1dCB3ZVxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0aGF0LCB3ZSB3aWxsIG1vdmUgaXQgdG8gV2ViR0xSZW5kZXJlci5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzY2VuZUVsZW1lbnQud2ViZ2xFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgKCB3ZWJHTFJlbmRlcmVyIHx8ICh3ZWJHTFJlbmRlcmVyID0gZ2V0V2ViR2xSZW5kZXJlcigpKSApIC8vIG9ubHkgZXZlciBjYWxsIGdldFdlYkdsUmVuZGVyZXIgb25jZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHdlYkdMUmVuZGVyZXIuZHJhd1NjZW5lKHNjZW5lRWxlbWVudClcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFNjZW5lcy5sZW5ndGggPSAwXG5cbiAgICAgICAgY29uc3Qgbm9kZXNUb0JlUmVuZGVyZWQgPSB0aGlzLl9ub2Rlc1RvQmVSZW5kZXJlZFxuICAgICAgICBmb3IgKGxldCBpPTAsIGw9bm9kZXNUb0JlUmVuZGVyZWQubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgIG5vZGVzVG9CZVJlbmRlcmVkW2ldLl93aWxsQmVSZW5kZXJlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbm9kZXNUb0JlUmVuZGVyZWQubGVuZ3RoID0gMFxuICAgIH1cbn1cblxuLy8gZXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlIHJhdGhlciB0aGFuIHRoZSBjbGFzcyBkaXJlY3RseS5cbmV4cG9ydCBkZWZhdWx0IG5ldyBNb3RvclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sYUFBYSxNQUFNLDRCQUE0QjtBQUN0RCxPQUFP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