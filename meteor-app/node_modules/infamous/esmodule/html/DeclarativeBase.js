/* global HTMLSlotElement */

import WebComponent from './WebComponent'
import HTMLNode from './HTMLNode'
import { observeChildren, /*getShadowRootVersion,*/ hasShadowDomV0,
    hasShadowDomV1, getAncestorShadowRoot } from '../core/Utility'

var DeclarativeBase

// We use this to Override HTMLElement.prototype.attachShadow in v1, and
// HTMLElement.prototype.createShadowRoot in v0, so that we can make the
// connection between parent and child on the iperative side when the HTML side
// is using shadow roots.
const observers = new WeakMap
function hijack(original) {
    return function(...args) {
        // In v0, shadow roots can be replaced, but in v1 calling attachShadow
        // on an element that already has a root throws. So, we can set this to
        // true, and if the try-catch passes then we know we have a v0 root and
        // that the root was just replaced.
        const oldRoot = this.shadowRoot
        let root = null
        try {
            root = original.call(this, ...args)
        }
        catch (e) { throw e }
        if (this instanceof DeclarativeBase) {
            this._hasShadowRoot = true
            if (oldRoot) {
                onV0ShadowRootReplaced.call(this, oldRoot)
            }
            const observer = observeChildren(root, shadowRootChildAdded.bind(this), shadowRootChildRemoved.bind(this))
            observers.set(root, observer)

            var ref = this;
            var children = ref.children;
            for (let l=children.length, i=0; i<l; i+=1) {
                if (!(children[i] instanceof DeclarativeBase)) { continue }
                children[i]._isPossiblyDistributed = true
            }
        }
        return root
    }
}

function shadowRootChildAdded(child) {

    // NOTE Logic here is similar to childConnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.addChild(child.imperativeCounterpart)
    }
    else if (
        hasShadowDomV0
        && child instanceof HTMLContentElement
    ) {
        // observe <content> elements.
    }
    else if (
        hasShadowDomV1
        && child instanceof HTMLSlotElement
    ) {
        child.addEventListener('slotchange', this)
        this._handleDistributedChildren(child)
    }
}

function shadowRootChildRemoved(child) {

    // NOTE Logic here is similar to childDisconnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.removeChild(child.imperativeCounterpart)
    }
    else if (
        hasShadowDomV0
        && child instanceof HTMLContentElement
    ) {
        // unobserve <content> element
    }
    else if (
        hasShadowDomV1
        && child instanceof HTMLSlotElement
    ) {
        child.removeEventListener('slotchange', this)
        this._handleDistributedChildren(child)
        this._slotElementsAssignedNodes.delete(child)
    }
}

function onV0ShadowRootReplaced(oldRoot) {
    observers.get(oldRoot).disconnect()
    observers.delete(oldRoot)
    var childNodes = oldRoot.childNodes;
    for (let l=childNodes.length, i=0; i<l; i+=1) {
        const child = childNodes[i]

        if (!(child instanceof DeclarativeBase)) { continue }

        // We should disconnect the imperative connection (f.e. so it is not
        // rendered in WebGL)
        this.imperativeCounterpart.removeChild(child.imperativeCounterpart, true)
    }
}

if (HTMLElement.prototype.createShadowRoot instanceof Function)
    { HTMLElement.prototype.createShadowRoot = hijack(HTMLElement.prototype.createShadowRoot) }
if (HTMLElement.prototype.attachShadow instanceof Function)
    { HTMLElement.prototype.attachShadow = hijack(HTMLElement.prototype.attachShadow) }

initDeclarativeBase()
export function initDeclarativeBase() {
    if (DeclarativeBase) { return }

    /**
     * @implements {EventListener}
     */
    DeclarativeBase = class DeclarativeBase extends WebComponent(window.HTMLElement) {
        constructor() {
            super()

            this.imperativeCounterpart = null // to hold the imperative API Node instance.

            // true if this node has a shadow root (even if it is "closed", see
            // hijack function above). Once true always true because shadow
            // roots cannot be removed.
            this._hasShadowRoot = false

            // True when this node has a parent that has a shadow root. When
            // using the HTML API, Imperative API can look at this to determine
            // whether to render this node or not, in the case of WebGL.
            this._isPossiblyDistributed = false

            // A map of the slot elements that are children of this node and
            // their last-known assigned nodes. When a slotchange happens while
            // this node is in a shadow root and has a slot child, we can
            // detect what the difference is between the last known and the new
            // assignments, and notate the new distribution of child nodes. See
            // issue #40 for background on why we do this.
            this._slotElementsAssignedNodes = new WeakMap

            // If this node is distributed into a shadow tree, this will
            // reference the parent of the <slot> or <content> element.
            // Basically, this node will render as a child of that parent node
            // in the flat tree.
            this._shadowParent = null

            // If this element has a child <slot> or <content> element while in
            // a shadow root, then this will be a Set of the nodes distributed
            // into the <slot> or <content>, and those nodes render relatively
            // to this node in the flat tree. We instantiate this later, only
            // when/if needed.
            this._shadowChildren = null

            // We use Promise.resolve here to defer to the next microtask.
            // While we support Custom Elements v0, this is necessary because
            // the imperative Node counterpart will have already called the
            // `_associateImperativeNode` method on this element, causing the
            // next microtask's call to be a no-op. When this MotorHTML element
            // API is used instead of the Imperative counterpart, then the next
            // microtask's `_associateImperativeNode` call will not be a no-op.
            // When we drop support for v0 Custom Elements at some point, we
            // can rely on passing a constructor argument similarly to how we
            // do with motor/Node in order to detect that the constructor is
            // being called from the reciprocal API. See the constructor in
            // motor/Node.js to get see the idea.
            // TODO: renewable promise after unmount.
            this._imperativeCounterpartPromise = Promise.resolve()
                .then(() => this._associateImperativeNode())
            this.mountPromise = this._imperativeCounterpartPromise
                .then(() => this.imperativeCounterpart.mountPromise)
        }

        /**
         * This method creates the association between this HTMLNode instance
         * and the imperative Node instance.
         *
         * This method may get called by this.init, but can also be called by
         * the Node class if Node is used imperatively. See Node#constructor.
         *
         * @private
         *
         * @param {Object} imperativeCounterpart The imperative counterpart to
         * associate with this MotorHTML element. This parameter is only used in the
         * imperative API constructors, and this happens when using the imperative
         * form of infamous instead of the HTML interface to infamous. When the HTML
         * interface is used, this gets called first without an
         * imperativeCounterpart argument and the call to this in an imperative
         * constructor will be a noop. Basically, either this gets called first by a
         * MotorHTML element, or first by an imperative instance, depending on which
         * API is used first.
         */
        _associateImperativeNode(imperativeCounterpart) {
            // if the association is made already, noop
            if (this.imperativeCounterpart) { return }

            // if called from an imperative-side class' constructor, associate
            // the passed instance.
            if (imperativeCounterpart) { this.imperativeCounterpart = imperativeCounterpart }

            // otherwise if called from a MotorHTML class without an argument
            else { this.imperativeCounterpart = this._makeImperativeCounterpart() }
        }

        /**
         * This method should be overriden by child classes. It should return the
         * imperative-side instance that the HTML-side class (this) corresponds to.
         * @abstract
         */
        _makeImperativeCounterpart() {
            throw new TypeError('This method should be implemented by classes extending DeclarativeBase.')
        }

        childConnectedCallback(child) {

            // mirror the DOM connections in the imperative API's virtual scene graph.
            if (child instanceof HTMLNode) {
                if (this._hasShadowRoot) { child._isPossiblyDistributed = true }

                // If ImperativeBase#addChild was called first, child's
                // _parent will already be set, so prevent recursion.
                if (child.imperativeCounterpart._parent) { return }

                this.imperativeCounterpart.addChild(child.imperativeCounterpart)
            }
            else if (
                hasShadowDomV0
                && child instanceof HTMLContentElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v0'
            ) {
                // observe <content> elements.
            }
            else if (
                hasShadowDomV1
                && child instanceof HTMLSlotElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v1'
            ) {
                child.addEventListener('slotchange', this)
                this._handleDistributedChildren(child)
            }
        }

        // This method is part of the EventListener interface.
        handleEvent(event) {
            if (event.type == 'slotchange') {
                const slot = event.target
                this._handleDistributedChildren(slot)
            }
        }

        _handleDistributedChildren(slot) {
            const diff = this._getDistributedChildDifference(slot)

            var added = diff.added;
            for (let l=added.length, i=0; i<l; i+=1) {
                const addedNode = added[i]

                if (!(addedNode instanceof DeclarativeBase)) { continue }

                // We do this because if the given slot is assigned to another
                // slot, then this logic will run again for the next slot on
                // that next slot's slotchange, so we remove the distributed
                // node from the previous shadowParent and add it to the next
                // one. If we don't do this, then the distributed node will
                // exist in multiple shadowChildren lists when there is a
                // chain of assigned slots. For more info, see
                // https://github.com/w3c/webcomponents/issues/611
                const shadowParent = addedNode._shadowParent
                if (shadowParent && shadowParent._shadowChildren) {
                    const shadowChildren = shadowParent._shadowChildren
                    shadowChildren.splice(shadowChildren.indexOf(addedNode), 1)
                    if (!shadowChildren.length)
                        { shadowParent._shadowChildren = null }
                }

                addedNode._shadowParent = this
                if (!this._shadowChildren) { this._shadowChildren = [] }
                this._shadowChildren.add(addedNode)
            }

            var removed = diff.removed;
            for (let l=removed.length, i=0; i<l; i+=1) {
                const removedNode = removed[i]

                if (!(removedNode instanceof DeclarativeBase)) { continue }

                removedNode._shadowParent = null
                this._shadowChildren.delete(removedNode)
                if (!this._shadowChildren.size) { this._shadowChildren = null }
            }
        }

        _getDistributedChildDifference(slot) {
            let previousNodes

            if (this._slotElementsAssignedNodes.has(slot))
                { previousNodes = this._slotElementsAssignedNodes.get(slot) }
            else
                { previousNodes = [] }

            const newNodes = slot.assignedNodes({flatten: true})

            // save the newNodes to be used as the previousNodes for next time.
            this._slotElementsAssignedNodes.set(slot, newNodes)

            const diff = {
                removed: [],
            }

            for (let i=0, l=previousNodes.length; i<l; i+=1) {
                const oldNode = previousNodes[i]
                const newIndex = newNodes.indexOf(oldNode)

                // if it exists in the previousNodes but not the newNodes, then
                // the node was removed.
                if (!(newIndex >= 0)) {
                    diff.removed.push(oldNode)
                }

                // otherwise the node wasn't added or removed.
                else {
                    newNodes.splice(i, 1)
                }
            }

            // Remaining nodes in newNodes must have been added.
            diff.added = newNodes

            return diff
        }

        childDisconnectedCallback(child) {
            // mirror the connection in the imperative API's virtual scene graph.
            if (child instanceof HTMLNode) {
                child._isPossiblyDistributed = false

                // If ImperativeBase#removeChild was called first, child's
                // _parent will already be null, so prevent recursion.
                if (!child.imperativeCounterpart._parent) { return }

                this.imperativeCounterpart.removeChild(child.imperativeCounterpart)
            }
            else if (
                hasShadowDomV0
                && child instanceof HTMLContentElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v0'
            ) {
                // unobserve <content> element
            }
            else if (
                hasShadowDomV1
                && child instanceof HTMLSlotElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v1'
            ) {
                child.removeEventListener('slotchange', this)
                this._handleDistributedChildren(child)
                this._slotElementsAssignedNodes.delete(child)
            }
        }

        setAttribute(attr, value) {
            //if (this.tagName.toLowerCase() == 'motor-scene')
                //console.log('setting attribute', arguments[1])
            super.setAttribute(attr, value)
        }
    }
}

// Creates setters/getters on the TargetClass which proxy to the
// setters/getters on SourceClass.
export function proxyGettersSetters(SourceClass, TargetClass) {

    // Node methods not to proxy (private underscored methods are also detected and
    // ignored).
    const methodProxyBlacklist = [
        'constructor',
        'parent',
        'children', // proxying this one would really break stuff (f.e. React)
        'element',
        'scene',
        'addChild',
        'addChildren',
        'removeChild',
        'removeChildren',
    ]

    const props = Object.getOwnPropertyNames(SourceClass.prototype)

    for (let l=props.length, i=0; i<l; i+=1) {
        const prop = props[i]
        if (
            // skip the blacklisted properties
            methodProxyBlacklist.indexOf(prop) >= 0

            // skip the private underscored properties
            || prop.indexOf('_') == 0

            // skip properties that are already defined.
            || TargetClass.prototype.hasOwnProperty(prop)
        ) { continue }

        const targetDescriptor = {}
        const sourceDescriptor = Object.getOwnPropertyDescriptor(SourceClass.prototype, prop)

        // if the property has a setter
        if (sourceDescriptor.set) {
            Object.assign(targetDescriptor, {
                set(value) {
                    this.imperativeCounterpart[prop] = value
                }
            })
        }

        // if the property has a getter
        if (sourceDescriptor.get) {
            Object.assign(targetDescriptor, {
                get() {
                    return this.imperativeCounterpart[prop]
                }
            })
        }

        Object.defineProperty(TargetClass.prototype, prop, targetDescriptor)
    }
}

export {DeclarativeBase as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVjbGFyYXRpdmVCYXNlLmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaHRtbC9EZWNsYXJhdGl2ZUJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEhUTUxTbG90RWxlbWVudCAqL1xuXG5pbXBvcnQgV2ViQ29tcG9uZW50IGZyb20gJy4vV2ViQ29tcG9uZW50J1xuaW1wb3J0IEhUTUxOb2RlIGZyb20gJy4vSFRNTE5vZGUnXG5pbXBvcnQgeyBvYnNlcnZlQ2hpbGRyZW4sIC8qZ2V0U2hhZG93Um9vdFZlcnNpb24sKi8gaGFzU2hhZG93RG9tVjAsXG4gICAgaGFzU2hhZG93RG9tVjEsIGdldEFuY2VzdG9yU2hhZG93Um9vdCB9IGZyb20gJy4uL2NvcmUvVXRpbGl0eSdcblxudmFyIERlY2xhcmF0aXZlQmFzZVxuXG4vLyBXZSB1c2UgdGhpcyB0byBPdmVycmlkZSBIVE1MRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93IGluIHYxLCBhbmRcbi8vIEhUTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290IGluIHYwLCBzbyB0aGF0IHdlIGNhbiBtYWtlIHRoZVxuLy8gY29ubmVjdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQgb24gdGhlIGlwZXJhdGl2ZSBzaWRlIHdoZW4gdGhlIEhUTUwgc2lkZVxuLy8gaXMgdXNpbmcgc2hhZG93IHJvb3RzLlxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXBcbmZ1bmN0aW9uIGhpamFjayhvcmlnaW5hbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIC8vIEluIHYwLCBzaGFkb3cgcm9vdHMgY2FuIGJlIHJlcGxhY2VkLCBidXQgaW4gdjEgY2FsbGluZyBhdHRhY2hTaGFkb3dcbiAgICAgICAgLy8gb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgcm9vdCB0aHJvd3MuIFNvLCB3ZSBjYW4gc2V0IHRoaXMgdG9cbiAgICAgICAgLy8gdHJ1ZSwgYW5kIGlmIHRoZSB0cnktY2F0Y2ggcGFzc2VzIHRoZW4gd2Uga25vdyB3ZSBoYXZlIGEgdjAgcm9vdCBhbmRcbiAgICAgICAgLy8gdGhhdCB0aGUgcm9vdCB3YXMganVzdCByZXBsYWNlZC5cbiAgICAgICAgY29uc3Qgb2xkUm9vdCA9IHRoaXMuc2hhZG93Um9vdFxuICAgICAgICBsZXQgcm9vdCA9IG51bGxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJvb3QgPSBvcmlnaW5hbC5jYWxsKHRoaXMsIC4uLmFyZ3MpXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgdGhyb3cgZSB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGVjbGFyYXRpdmVCYXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNTaGFkb3dSb290ID0gdHJ1ZVxuICAgICAgICAgICAgaWYgKG9sZFJvb3QpIHtcbiAgICAgICAgICAgICAgICBvblYwU2hhZG93Um9vdFJlcGxhY2VkLmNhbGwodGhpcywgb2xkUm9vdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2ZUNoaWxkcmVuKHJvb3QsIHNoYWRvd1Jvb3RDaGlsZEFkZGVkLmJpbmQodGhpcyksIHNoYWRvd1Jvb3RDaGlsZFJlbW92ZWQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIG9ic2VydmVycy5zZXQocm9vdCwgb2JzZXJ2ZXIpXG5cbiAgICAgICAgICAgIGNvbnN0IHtjaGlsZHJlbn0gPSB0aGlzXG4gICAgICAgICAgICBmb3IgKGxldCBsPWNoaWxkcmVuLmxlbmd0aCwgaT0wOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZHJlbltpXSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX2lzUG9zc2libHlEaXN0cmlidXRlZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hhZG93Um9vdENoaWxkQWRkZWQoY2hpbGQpIHtcblxuICAgIC8vIE5PVEUgTG9naWMgaGVyZSBpcyBzaW1pbGFyIHRvIGNoaWxkQ29ubmVjdGVkQ2FsbGJhY2tcblxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkge1xuICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5hZGRDaGlsZChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQpXG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgICAgICBoYXNTaGFkb3dEb21WMFxuICAgICAgICAmJiBjaGlsZCBpbnN0YW5jZW9mIEhUTUxDb250ZW50RWxlbWVudFxuICAgICkge1xuICAgICAgICAvLyBvYnNlcnZlIDxjb250ZW50PiBlbGVtZW50cy5cbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgICAgIGhhc1NoYWRvd0RvbVYxXG4gICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIGNoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzKVxuICAgICAgICB0aGlzLl9oYW5kbGVEaXN0cmlidXRlZENoaWxkcmVuKGNoaWxkKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hhZG93Um9vdENoaWxkUmVtb3ZlZChjaGlsZCkge1xuXG4gICAgLy8gTk9URSBMb2dpYyBoZXJlIGlzIHNpbWlsYXIgdG8gY2hpbGREaXNjb25uZWN0ZWRDYWxsYmFja1xuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRGVjbGFyYXRpdmVCYXNlKSB7XG4gICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LnJlbW92ZUNoaWxkKGNoaWxkLmltcGVyYXRpdmVDb3VudGVycGFydClcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgICAgIGhhc1NoYWRvd0RvbVYwXG4gICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTENvbnRlbnRFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIC8vIHVub2JzZXJ2ZSA8Y29udGVudD4gZWxlbWVudFxuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAgICAgaGFzU2hhZG93RG9tVjFcbiAgICAgICAgJiYgY2hpbGQgaW5zdGFuY2VvZiBIVE1MU2xvdEVsZW1lbnRcbiAgICApIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMpXG4gICAgICAgIHRoaXMuX2hhbmRsZURpc3RyaWJ1dGVkQ2hpbGRyZW4oY2hpbGQpXG4gICAgICAgIHRoaXMuX3Nsb3RFbGVtZW50c0Fzc2lnbmVkTm9kZXMuZGVsZXRlKGNoaWxkKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb25WMFNoYWRvd1Jvb3RSZXBsYWNlZChvbGRSb290KSB7XG4gICAgb2JzZXJ2ZXJzLmdldChvbGRSb290KS5kaXNjb25uZWN0KClcbiAgICBvYnNlcnZlcnMuZGVsZXRlKG9sZFJvb3QpXG4gICAgY29uc3Qge2NoaWxkTm9kZXN9ID0gb2xkUm9vdFxuICAgIGZvciAobGV0IGw9Y2hpbGROb2Rlcy5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGROb2Rlc1tpXVxuXG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgRGVjbGFyYXRpdmVCYXNlKSkgY29udGludWVcblxuICAgICAgICAvLyBXZSBzaG91bGQgZGlzY29ubmVjdCB0aGUgaW1wZXJhdGl2ZSBjb25uZWN0aW9uIChmLmUuIHNvIGl0IGlzIG5vdFxuICAgICAgICAvLyByZW5kZXJlZCBpbiBXZWJHTClcbiAgICAgICAgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQucmVtb3ZlQ2hpbGQoY2hpbGQuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LCB0cnVlKVxuICAgIH1cbn1cblxuaWYgKEhUTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBoaWphY2soSFRNTEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QpXG5pZiAoSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdyBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cgPSBoaWphY2soSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdylcblxuaW5pdERlY2xhcmF0aXZlQmFzZSgpXG5leHBvcnQgZnVuY3Rpb24gaW5pdERlY2xhcmF0aXZlQmFzZSgpIHtcbiAgICBpZiAoRGVjbGFyYXRpdmVCYXNlKSByZXR1cm5cblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtFdmVudExpc3RlbmVyfVxuICAgICAqL1xuICAgIERlY2xhcmF0aXZlQmFzZSA9IGNsYXNzIERlY2xhcmF0aXZlQmFzZSBleHRlbmRzIFdlYkNvbXBvbmVudCh3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0ID0gbnVsbCAvLyB0byBob2xkIHRoZSBpbXBlcmF0aXZlIEFQSSBOb2RlIGluc3RhbmNlLlxuXG4gICAgICAgICAgICAvLyB0cnVlIGlmIHRoaXMgbm9kZSBoYXMgYSBzaGFkb3cgcm9vdCAoZXZlbiBpZiBpdCBpcyBcImNsb3NlZFwiLCBzZWVcbiAgICAgICAgICAgIC8vIGhpamFjayBmdW5jdGlvbiBhYm92ZSkuIE9uY2UgdHJ1ZSBhbHdheXMgdHJ1ZSBiZWNhdXNlIHNoYWRvd1xuICAgICAgICAgICAgLy8gcm9vdHMgY2Fubm90IGJlIHJlbW92ZWQuXG4gICAgICAgICAgICB0aGlzLl9oYXNTaGFkb3dSb290ID0gZmFsc2VcblxuICAgICAgICAgICAgLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBoYXMgYSBwYXJlbnQgdGhhdCBoYXMgYSBzaGFkb3cgcm9vdC4gV2hlblxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIEhUTUwgQVBJLCBJbXBlcmF0aXZlIEFQSSBjYW4gbG9vayBhdCB0aGlzIHRvIGRldGVybWluZVxuICAgICAgICAgICAgLy8gd2hldGhlciB0byByZW5kZXIgdGhpcyBub2RlIG9yIG5vdCwgaW4gdGhlIGNhc2Ugb2YgV2ViR0wuXG4gICAgICAgICAgICB0aGlzLl9pc1Bvc3NpYmx5RGlzdHJpYnV0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBBIG1hcCBvZiB0aGUgc2xvdCBlbGVtZW50cyB0aGF0IGFyZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgYW5kXG4gICAgICAgICAgICAvLyB0aGVpciBsYXN0LWtub3duIGFzc2lnbmVkIG5vZGVzLiBXaGVuIGEgc2xvdGNoYW5nZSBoYXBwZW5zIHdoaWxlXG4gICAgICAgICAgICAvLyB0aGlzIG5vZGUgaXMgaW4gYSBzaGFkb3cgcm9vdCBhbmQgaGFzIGEgc2xvdCBjaGlsZCwgd2UgY2FuXG4gICAgICAgICAgICAvLyBkZXRlY3Qgd2hhdCB0aGUgZGlmZmVyZW5jZSBpcyBiZXR3ZWVuIHRoZSBsYXN0IGtub3duIGFuZCB0aGUgbmV3XG4gICAgICAgICAgICAvLyBhc3NpZ25tZW50cywgYW5kIG5vdGF0ZSB0aGUgbmV3IGRpc3RyaWJ1dGlvbiBvZiBjaGlsZCBub2Rlcy4gU2VlXG4gICAgICAgICAgICAvLyBpc3N1ZSAjNDAgZm9yIGJhY2tncm91bmQgb24gd2h5IHdlIGRvIHRoaXMuXG4gICAgICAgICAgICB0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzID0gbmV3IFdlYWtNYXBcblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIGRpc3RyaWJ1dGVkIGludG8gYSBzaGFkb3cgdHJlZSwgdGhpcyB3aWxsXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgdGhlIHBhcmVudCBvZiB0aGUgPHNsb3Q+IG9yIDxjb250ZW50PiBlbGVtZW50LlxuICAgICAgICAgICAgLy8gQmFzaWNhbGx5LCB0aGlzIG5vZGUgd2lsbCByZW5kZXIgYXMgYSBjaGlsZCBvZiB0aGF0IHBhcmVudCBub2RlXG4gICAgICAgICAgICAvLyBpbiB0aGUgZmxhdCB0cmVlLlxuICAgICAgICAgICAgdGhpcy5fc2hhZG93UGFyZW50ID0gbnVsbFxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGEgY2hpbGQgPHNsb3Q+IG9yIDxjb250ZW50PiBlbGVtZW50IHdoaWxlIGluXG4gICAgICAgICAgICAvLyBhIHNoYWRvdyByb290LCB0aGVuIHRoaXMgd2lsbCBiZSBhIFNldCBvZiB0aGUgbm9kZXMgZGlzdHJpYnV0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIDxzbG90PiBvciA8Y29udGVudD4sIGFuZCB0aG9zZSBub2RlcyByZW5kZXIgcmVsYXRpdmVseVxuICAgICAgICAgICAgLy8gdG8gdGhpcyBub2RlIGluIHRoZSBmbGF0IHRyZWUuIFdlIGluc3RhbnRpYXRlIHRoaXMgbGF0ZXIsIG9ubHlcbiAgICAgICAgICAgIC8vIHdoZW4vaWYgbmVlZGVkLlxuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q2hpbGRyZW4gPSBudWxsXG5cbiAgICAgICAgICAgIC8vIFdlIHVzZSBQcm9taXNlLnJlc29sdmUgaGVyZSB0byBkZWZlciB0byB0aGUgbmV4dCBtaWNyb3Rhc2suXG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSBzdXBwb3J0IEN1c3RvbSBFbGVtZW50cyB2MCwgdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhlIGltcGVyYXRpdmUgTm9kZSBjb3VudGVycGFydCB3aWxsIGhhdmUgYWxyZWFkeSBjYWxsZWQgdGhlXG4gICAgICAgICAgICAvLyBgX2Fzc29jaWF0ZUltcGVyYXRpdmVOb2RlYCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LCBjYXVzaW5nIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtaWNyb3Rhc2sncyBjYWxsIHRvIGJlIGEgbm8tb3AuIFdoZW4gdGhpcyBNb3RvckhUTUwgZWxlbWVudFxuICAgICAgICAgICAgLy8gQVBJIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgSW1wZXJhdGl2ZSBjb3VudGVycGFydCwgdGhlbiB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbWljcm90YXNrJ3MgYF9hc3NvY2lhdGVJbXBlcmF0aXZlTm9kZWAgY2FsbCB3aWxsIG5vdCBiZSBhIG5vLW9wLlxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBkcm9wIHN1cHBvcnQgZm9yIHYwIEN1c3RvbSBFbGVtZW50cyBhdCBzb21lIHBvaW50LCB3ZVxuICAgICAgICAgICAgLy8gY2FuIHJlbHkgb24gcGFzc2luZyBhIGNvbnN0cnVjdG9yIGFyZ3VtZW50IHNpbWlsYXJseSB0byBob3cgd2VcbiAgICAgICAgICAgIC8vIGRvIHdpdGggbW90b3IvTm9kZSBpbiBvcmRlciB0byBkZXRlY3QgdGhhdCB0aGUgY29uc3RydWN0b3IgaXNcbiAgICAgICAgICAgIC8vIGJlaW5nIGNhbGxlZCBmcm9tIHRoZSByZWNpcHJvY2FsIEFQSS4gU2VlIHRoZSBjb25zdHJ1Y3RvciBpblxuICAgICAgICAgICAgLy8gbW90b3IvTm9kZS5qcyB0byBnZXQgc2VlIHRoZSBpZGVhLlxuICAgICAgICAgICAgLy8gVE9ETzogcmVuZXdhYmxlIHByb21pc2UgYWZ0ZXIgdW5tb3VudC5cbiAgICAgICAgICAgIHRoaXMuX2ltcGVyYXRpdmVDb3VudGVycGFydFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuX2Fzc29jaWF0ZUltcGVyYXRpdmVOb2RlKCkpXG4gICAgICAgICAgICB0aGlzLm1vdW50UHJvbWlzZSA9IHRoaXMuX2ltcGVyYXRpdmVDb3VudGVycGFydFByb21pc2VcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5tb3VudFByb21pc2UpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgYXNzb2NpYXRpb24gYmV0d2VlbiB0aGlzIEhUTUxOb2RlIGluc3RhbmNlXG4gICAgICAgICAqIGFuZCB0aGUgaW1wZXJhdGl2ZSBOb2RlIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgZ2V0IGNhbGxlZCBieSB0aGlzLmluaXQsIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgYnlcbiAgICAgICAgICogdGhlIE5vZGUgY2xhc3MgaWYgTm9kZSBpcyB1c2VkIGltcGVyYXRpdmVseS4gU2VlIE5vZGUjY29uc3RydWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbXBlcmF0aXZlQ291bnRlcnBhcnQgVGhlIGltcGVyYXRpdmUgY291bnRlcnBhcnQgdG9cbiAgICAgICAgICogYXNzb2NpYXRlIHdpdGggdGhpcyBNb3RvckhUTUwgZWxlbWVudC4gVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGluIHRoZVxuICAgICAgICAgKiBpbXBlcmF0aXZlIEFQSSBjb25zdHJ1Y3RvcnMsIGFuZCB0aGlzIGhhcHBlbnMgd2hlbiB1c2luZyB0aGUgaW1wZXJhdGl2ZVxuICAgICAgICAgKiBmb3JtIG9mIGluZmFtb3VzIGluc3RlYWQgb2YgdGhlIEhUTUwgaW50ZXJmYWNlIHRvIGluZmFtb3VzLiBXaGVuIHRoZSBIVE1MXG4gICAgICAgICAqIGludGVyZmFjZSBpcyB1c2VkLCB0aGlzIGdldHMgY2FsbGVkIGZpcnN0IHdpdGhvdXQgYW5cbiAgICAgICAgICogaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0IGFyZ3VtZW50IGFuZCB0aGUgY2FsbCB0byB0aGlzIGluIGFuIGltcGVyYXRpdmVcbiAgICAgICAgICogY29uc3RydWN0b3Igd2lsbCBiZSBhIG5vb3AuIEJhc2ljYWxseSwgZWl0aGVyIHRoaXMgZ2V0cyBjYWxsZWQgZmlyc3QgYnkgYVxuICAgICAgICAgKiBNb3RvckhUTUwgZWxlbWVudCwgb3IgZmlyc3QgYnkgYW4gaW1wZXJhdGl2ZSBpbnN0YW5jZSwgZGVwZW5kaW5nIG9uIHdoaWNoXG4gICAgICAgICAqIEFQSSBpcyB1c2VkIGZpcnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgX2Fzc29jaWF0ZUltcGVyYXRpdmVOb2RlKGltcGVyYXRpdmVDb3VudGVycGFydCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFzc29jaWF0aW9uIGlzIG1hZGUgYWxyZWFkeSwgbm9vcFxuICAgICAgICAgICAgaWYgKHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0KSByZXR1cm5cblxuICAgICAgICAgICAgLy8gaWYgY2FsbGVkIGZyb20gYW4gaW1wZXJhdGl2ZS1zaWRlIGNsYXNzJyBjb25zdHJ1Y3RvciwgYXNzb2NpYXRlXG4gICAgICAgICAgICAvLyB0aGUgcGFzc2VkIGluc3RhbmNlLlxuICAgICAgICAgICAgaWYgKGltcGVyYXRpdmVDb3VudGVycGFydCkgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQgPSBpbXBlcmF0aXZlQ291bnRlcnBhcnRcblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGNhbGxlZCBmcm9tIGEgTW90b3JIVE1MIGNsYXNzIHdpdGhvdXQgYW4gYXJndW1lbnRcbiAgICAgICAgICAgIGVsc2UgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQgPSB0aGlzLl9tYWtlSW1wZXJhdGl2ZUNvdW50ZXJwYXJ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IGNoaWxkIGNsYXNzZXMuIEl0IHNob3VsZCByZXR1cm4gdGhlXG4gICAgICAgICAqIGltcGVyYXRpdmUtc2lkZSBpbnN0YW5jZSB0aGF0IHRoZSBIVE1MLXNpZGUgY2xhc3MgKHRoaXMpIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIF9tYWtlSW1wZXJhdGl2ZUNvdW50ZXJwYXJ0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIERlY2xhcmF0aXZlQmFzZS4nKVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRDb25uZWN0ZWRDYWxsYmFjayhjaGlsZCkge1xuXG4gICAgICAgICAgICAvLyBtaXJyb3IgdGhlIERPTSBjb25uZWN0aW9ucyBpbiB0aGUgaW1wZXJhdGl2ZSBBUEkncyB2aXJ0dWFsIHNjZW5lIGdyYXBoLlxuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzU2hhZG93Um9vdCkgY2hpbGQuX2lzUG9zc2libHlEaXN0cmlidXRlZCA9IHRydWVcblxuICAgICAgICAgICAgICAgIC8vIElmIEltcGVyYXRpdmVCYXNlI2FkZENoaWxkIHdhcyBjYWxsZWQgZmlyc3QsIGNoaWxkJ3NcbiAgICAgICAgICAgICAgICAvLyBfcGFyZW50IHdpbGwgYWxyZWFkeSBiZSBzZXQsIHNvIHByZXZlbnQgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX3BhcmVudCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5hZGRDaGlsZChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMFxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTENvbnRlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YwJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZSA8Y29udGVudD4gZWxlbWVudHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMVxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YxJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRGlzdHJpYnV0ZWRDaGlsZHJlbihjaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIEV2ZW50TGlzdGVuZXIgaW50ZXJmYWNlLlxuICAgICAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ3Nsb3RjaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZURpc3RyaWJ1dGVkQ2hpbGRyZW4oc2xvdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oYW5kbGVEaXN0cmlidXRlZENoaWxkcmVuKHNsb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLl9nZXREaXN0cmlidXRlZENoaWxkRGlmZmVyZW5jZShzbG90KVxuXG4gICAgICAgICAgICBjb25zdCB7YWRkZWR9ID0gZGlmZlxuICAgICAgICAgICAgZm9yIChsZXQgbD1hZGRlZC5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWROb2RlID0gYWRkZWRbaV1cblxuICAgICAgICAgICAgICAgIGlmICghKGFkZGVkTm9kZSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgaWYgdGhlIGdpdmVuIHNsb3QgaXMgYXNzaWduZWQgdG8gYW5vdGhlclxuICAgICAgICAgICAgICAgIC8vIHNsb3QsIHRoZW4gdGhpcyBsb2dpYyB3aWxsIHJ1biBhZ2FpbiBmb3IgdGhlIG5leHQgc2xvdCBvblxuICAgICAgICAgICAgICAgIC8vIHRoYXQgbmV4dCBzbG90J3Mgc2xvdGNoYW5nZSwgc28gd2UgcmVtb3ZlIHRoZSBkaXN0cmlidXRlZFxuICAgICAgICAgICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgcHJldmlvdXMgc2hhZG93UGFyZW50IGFuZCBhZGQgaXQgdG8gdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBvbmUuIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gdGhlIGRpc3RyaWJ1dGVkIG5vZGUgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IGluIG11bHRpcGxlIHNoYWRvd0NoaWxkcmVuIGxpc3RzIHdoZW4gdGhlcmUgaXMgYVxuICAgICAgICAgICAgICAgIC8vIGNoYWluIG9mIGFzc2lnbmVkIHNsb3RzLiBGb3IgbW9yZSBpbmZvLCBzZWVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmNvbXBvbmVudHMvaXNzdWVzLzYxMVxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd1BhcmVudCA9IGFkZGVkTm9kZS5fc2hhZG93UGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvd1BhcmVudCAmJiBzaGFkb3dQYXJlbnQuX3NoYWRvd0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0NoaWxkcmVuID0gc2hhZG93UGFyZW50Ll9zaGFkb3dDaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDaGlsZHJlbi5zcGxpY2Uoc2hhZG93Q2hpbGRyZW4uaW5kZXhPZihhZGRlZE5vZGUpLCAxKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYWRvd0NoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1BhcmVudC5fc2hhZG93Q2hpbGRyZW4gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkZWROb2RlLl9zaGFkb3dQYXJlbnQgPSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFkb3dDaGlsZHJlbikgdGhpcy5fc2hhZG93Q2hpbGRyZW4gPSBbXVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NoaWxkcmVuLmFkZChhZGRlZE5vZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHtyZW1vdmVkfSA9IGRpZmZcbiAgICAgICAgICAgIGZvciAobGV0IGw9cmVtb3ZlZC5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZE5vZGUgPSByZW1vdmVkW2ldXG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZW1vdmVkTm9kZSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZS5fc2hhZG93UGFyZW50ID0gbnVsbFxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NoaWxkcmVuLmRlbGV0ZShyZW1vdmVkTm9kZSlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWRvd0NoaWxkcmVuLnNpemUpIHRoaXMuX3NoYWRvd0NoaWxkcmVuID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldERpc3RyaWJ1dGVkQ2hpbGREaWZmZXJlbmNlKHNsb3QpIHtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c05vZGVzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLmhhcyhzbG90KSlcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGVzID0gdGhpcy5fc2xvdEVsZW1lbnRzQXNzaWduZWROb2Rlcy5nZXQoc2xvdClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGVzID0gW11cblxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KVxuXG4gICAgICAgICAgICAvLyBzYXZlIHRoZSBuZXdOb2RlcyB0byBiZSB1c2VkIGFzIHRoZSBwcmV2aW91c05vZGVzIGZvciBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLnNldChzbG90LCBuZXdOb2RlcylcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHtcbiAgICAgICAgICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaT0wLCBsPXByZXZpb3VzTm9kZXMubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGROb2RlID0gcHJldmlvdXNOb2Rlc1tpXVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gbmV3Tm9kZXMuaW5kZXhPZihvbGROb2RlKVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZXhpc3RzIGluIHRoZSBwcmV2aW91c05vZGVzIGJ1dCBub3QgdGhlIG5ld05vZGVzLCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgd2FzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgaWYgKCEobmV3SW5kZXggPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5yZW1vdmVkLnB1c2gob2xkTm9kZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhlIG5vZGUgd2Fzbid0IGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIG5vZGVzIGluIG5ld05vZGVzIG11c3QgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAgICAgICAgZGlmZi5hZGRlZCA9IG5ld05vZGVzXG5cbiAgICAgICAgICAgIHJldHVybiBkaWZmXG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZERpc2Nvbm5lY3RlZENhbGxiYWNrKGNoaWxkKSB7XG4gICAgICAgICAgICAvLyBtaXJyb3IgdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGltcGVyYXRpdmUgQVBJJ3MgdmlydHVhbCBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxOb2RlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2lzUG9zc2libHlEaXN0cmlidXRlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJbXBlcmF0aXZlQmFzZSNyZW1vdmVDaGlsZCB3YXMgY2FsbGVkIGZpcnN0LCBjaGlsZCdzXG4gICAgICAgICAgICAgICAgLy8gX3BhcmVudCB3aWxsIGFscmVhZHkgYmUgbnVsbCwgc28gcHJldmVudCByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX3BhcmVudCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5yZW1vdmVDaGlsZChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMFxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTENvbnRlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YwJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5vYnNlcnZlIDxjb250ZW50PiBlbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMVxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YxJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRGlzdHJpYnV0ZWRDaGlsZHJlbihjaGlsZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLmRlbGV0ZShjaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy9pZiAodGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ21vdG9yLXNjZW5lJylcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzZXR0aW5nIGF0dHJpYnV0ZScsIGFyZ3VtZW50c1sxXSlcbiAgICAgICAgICAgIHN1cGVyLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ3JlYXRlcyBzZXR0ZXJzL2dldHRlcnMgb24gdGhlIFRhcmdldENsYXNzIHdoaWNoIHByb3h5IHRvIHRoZVxuLy8gc2V0dGVycy9nZXR0ZXJzIG9uIFNvdXJjZUNsYXNzLlxuZXhwb3J0IGZ1bmN0aW9uIHByb3h5R2V0dGVyc1NldHRlcnMoU291cmNlQ2xhc3MsIFRhcmdldENsYXNzKSB7XG5cbiAgICAvLyBOb2RlIG1ldGhvZHMgbm90IHRvIHByb3h5IChwcml2YXRlIHVuZGVyc2NvcmVkIG1ldGhvZHMgYXJlIGFsc28gZGV0ZWN0ZWQgYW5kXG4gICAgLy8gaWdub3JlZCkuXG4gICAgY29uc3QgbWV0aG9kUHJveHlCbGFja2xpc3QgPSBbXG4gICAgICAgICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICdwYXJlbnQnLFxuICAgICAgICAnY2hpbGRyZW4nLCAvLyBwcm94eWluZyB0aGlzIG9uZSB3b3VsZCByZWFsbHkgYnJlYWsgc3R1ZmYgKGYuZS4gUmVhY3QpXG4gICAgICAgICdlbGVtZW50JyxcbiAgICAgICAgJ3NjZW5lJyxcbiAgICAgICAgJ2FkZENoaWxkJyxcbiAgICAgICAgJ2FkZENoaWxkcmVuJyxcbiAgICAgICAgJ3JlbW92ZUNoaWxkJyxcbiAgICAgICAgJ3JlbW92ZUNoaWxkcmVuJyxcbiAgICBdXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFNvdXJjZUNsYXNzLnByb3RvdHlwZSlcblxuICAgIGZvciAobGV0IGw9cHJvcHMubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSkge1xuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gc2tpcCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgbWV0aG9kUHJveHlCbGFja2xpc3QuaW5kZXhPZihwcm9wKSA+PSAwXG5cbiAgICAgICAgICAgIC8vIHNraXAgdGhlIHByaXZhdGUgdW5kZXJzY29yZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgfHwgcHJvcC5pbmRleE9mKCdfJykgPT0gMFxuXG4gICAgICAgICAgICAvLyBza2lwIHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBkZWZpbmVkLlxuICAgICAgICAgICAgfHwgVGFyZ2V0Q2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApXG4gICAgICAgICkgY29udGludWVcblxuICAgICAgICBjb25zdCB0YXJnZXREZXNjcmlwdG9yID0ge31cbiAgICAgICAgY29uc3Qgc291cmNlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU291cmNlQ2xhc3MucHJvdG90eXBlLCBwcm9wKVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBoYXMgYSBzZXR0ZXJcbiAgICAgICAgaWYgKHNvdXJjZURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldERlc2NyaXB0b3IsIHtcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnRbcHJvcF0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaGFzIGEgZ2V0dGVyXG4gICAgICAgIGlmIChzb3VyY2VEZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXREZXNjcmlwdG9yLCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnRbcHJvcF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhcmdldENsYXNzLnByb3RvdHlwZSwgcHJvcCwgdGFyZ2V0RGVzY3JpcHRvcilcbiAgICB9XG59XG5cbmV4cG9ydCB7RGVjbGFyYXRpdmVCYXNlIGFzIGRlZmF1bHR9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsT0FBTyxZQUFZLE1BQU0sZ0JBQWdCO0FBQ3pDLE9BQU8sUUFBUSxNQUFNLFlBQVk7QUFDakMsU0FBUyxlQUFlLDRCQUE0QixjQUFjO0lBQzlELGNBQWMsRUFBRSxxQkFBcUIsUUFBUSxpQkFBaUI7O0FBRWxFLElBQUksZUFBZTs7Ozs7O0FBTW5CLE1BQU0sU0FBUyxHQUFHLElBQUksT0FBTztBQUM3QixTQUFTLE1BQU0sQ0FBQyxRQUFRLEVBQUU7SUFDdEIsT0FBTyxTQUFTLEdBQUcsSUFBSSxFQUFFOzs7OztRQUtyQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVTtRQUMvQixJQUFJLElBQUksR0FBRyxJQUFJO1FBQ2YsSUFBSTtZQUNBLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQztTQUN0QztRQUNELE9BQU8sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLFlBQVksZUFBZSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSTtZQUMxQixJQUFJLE9B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