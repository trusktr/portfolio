/* global customElements */

import { observeChildren } from '../core/Utility'
import jss from '../lib/jss'

// Very very stupid hack needed for Safari in order for us to be able to extend
// the HTMLElement class. See:
// https://github.com/google/traceur-compiler/issues/1709
if (typeof window.HTMLElement != 'function') {
    const _HTMLElement = function HTMLElement(){}
    _HTMLElement.prototype = window.HTMLElement.prototype
    window.HTMLElement = _HTMLElement
}

const classCache = new Map

function classExtendsHTMLElement(constructor) {
    if (!constructor) { return false }
    if (constructor === HTMLElement) { return true }
    else { return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null) }
}

/**
 * Creates a WebComponent base class dynamically, depending on which
 * HTMLElement class you want it to extend from. Extend from WebComponent when
 * making a new Custom Element class.
 *
 * @example
 * const WebComponent = WebComponentMixin(HTMLButtonElement)
 * class AwesomeButton extends WebComponent { ... }
 *
 * @param {Function} elementClass The class that the generated WebComponent
 * base class will extend from.
 */
export default
function WebComponentMixin(elementClass) {
    if (!elementClass) { elementClass = HTMLElement }

    if (!classExtendsHTMLElement(elementClass)) {
        throw new TypeError(
            'The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.'
        )
    }

    // if a base class that extends the given `elementClass` has already been
    // created, return it.
    if (classCache.has(elementClass))
        { return classCache.get(elementClass) }

    // otherwise, create it.
    class WebComponent extends elementClass {

        constructor() {
            super()

            // Throw an error if no Custom Elements v1 API exists.
            if (!('customElements' in window)) {
                throw new Error(`
                    Your browser does not support the Custom Elements API. You'll
                    need to install a polyfill. See how at http://....
                `)
            }

            this._connected = false
            this._initialized = false
            this._initialAttributeChange = false
            this._childObserver = null
            this._style = null
        }

        // Subclasses can implement these.
        childConnectedCallback(child) { }
        childDisconnectedCallback(child) { }

        connectedCallback() {
            if (super.connectedCallback) { super.connectedCallback() }
            this._connected = true

            if (!this._initialized) {
                this.init()
                this._initialized = true
            }
        }

        _createStyles() {
            const rule = jss.createRule(this.getStyles())

            rule.applyTo(this)

            return rule
        }

        disconnectedCallback() {
            if (super.disconnectedCallback) { super.disconnectedCallback() }
            this._connected = false

            // Deferr to the next tick before cleaning up in case the
            // element is actually being re-attached somewhere else within this
            // same tick (detaching and attaching is synchronous, so by
            // deferring to the next tick we'll be able to know if the element
            // was re-attached or not in order to clean up or not). Note that
            // appendChild can be used to move an element to another parent
            // element, in which case connectedCallback and disconnectedCallback
            // both get called, and in which case we don't necessarily want to
            // clean up. If the element gets re-attached before the next tick
            // (for example, gets moved), then we want to preserve the
            // stuff that would be cleaned up by an extending class' deinit
            // method by not running the following this.deinit() call.
            Promise.resolve().then(() => { // deferr to the next tick.

                // As mentioned in the previous comment, if the element was not
                // re-attached in the last tick (for example, it was moved to
                // another element), then clean up.
                if (!this._connected && this._initialized) {
                    this.deinit()
                }
            })
        }
        //async disconnectedCallback() {
            //if (super.disconnectedCallback) super.disconnectedCallback()
            //this._connected = false

            //// Deferr to the next tick before cleaning up in case the
            //// element is actually being re-attached somewhere else within this
            //// same tick (detaching and attaching is synchronous, so by
            //// deferring to the next tick we'll be able to know if the element
            //// was re-attached or not in order to clean up or not). Note that
            //// appendChild can be used to move an element to another parent
            //// element, in which case connectedCallback and disconnectedCallback
            //// both get called, and in which case we don't necessarily want to
            //// clean up. If the element gets re-attached before the next tick
            //// (for example, gets moved), then we want to preserve the
            //// stuff that would be cleaned up by an extending class' deinit
            //// method by not running the following this.deinit() call.
            //await Promise.resolve() // deferr to the next tick.

            //// As mentioned in the previous comment, if the element was not
            //// re-attached in the last tick (for example, it was moved to
            //// another element), then clean up.
            //if (!this._connected && this._initialized) {
                //this.deinit()
            //}
        //}

        /**
         * This method can be overridden by extending classes, it should return
         * JSS-compatible styling. See http://github.com/cssinjs/jss for
         * documentation.
         * @abstract
         */
        getStyles() {
            return {}
        }


        /**
         * Init is called exactly once, the first time this element is
         * connected into the DOM. When an element is disconnected then
         * connected right away within the same synchronous tick, init() is not
         * fired again. However, if an element is disconnected and the current
         * tick completes before the element is connected again, then deinit()
         * will be called (i.e. the element was not simply moved to a new
         * location, it was actually removed), then the next time that the
         * element is connected back into DOM init() will be called again.
         *
         * This is in contrast to connectedCallback and disconnectedCallback:
         * connectedCallback is guaranteed to always fire even if the elemet
         * was previously disconnected in the same synchronous tick.
         *
         * For example, ...
         *
         * Subclasses should extend this to add such logic.
         */
        init() {
            if (!this._style) { this._style = this._createStyles() }

            // Handle any nodes that may have been connected before `this` node
            // was created (f.e. child nodes that were connected before the
            // custom elements were registered and which would therefore not be
            // detected by the following MutationObserver).
            if (!this._childObserver) {

                const children = this.childNodes
                if (children.length) {

                    // Timeout needed in case the Custom Element classes are
                    // registered after the elements are already defined in the
                    // DOM but not yet upgraded. This means that the `node` arg
                    // might be a `<motor-node>` but if it isn't upgraded then
                    // its API won't be available to the logic inside the
                    // childConnectedCallback. The reason this happens is
                    // because parents are upgraded first and their
                    // connectedCallbacks fired before their children are
                    // upgraded.
                    //
                    // TODO FIXME PERFORMANCE: This causes a possibly "buggy" effect where
                    // elements in a tree will appear in intervals of 5
                    // milliseconds. We want elements to be rendered instantly,
                    // in the first frame that they are present in the scene
                    // graph.
                    // How can we fix this? Maybe we can switch to a Promise microtask.
                    setTimeout(() => {
                        for (let l=children.length, i=0; i<l; i+=1) {
                            this.childConnectedCallback(children[i])
                        }
                    }, 5)
                }

                this._childObserver = observeChildren(this, this.childConnectedCallback, this.childDisconnectedCallback)
            }

            // fire this.attributeChangedCallback in case some attributes have
            // existed before the custom element was upgraded.
            if (!this._initialAttributeChange && this.hasAttributes()) {

                // HTMLElement#attributes is a NamedNodeMap which is not an
                // iterable, so we use Array.from. See:
                // https://github.com/zloirock/core-js/issues/234
                var ref = this;
                var attributes = ref.attributes;
                for (let l=attributes.length, i=0; i<l; i+=1)
                    { this.attributeChangedCallback(attributes[i].name, null, attributes[i].value) }
            }
        }

        static get observedAttributes() {
            console.warn(`WebComponent: Your custom element (${ this.name }) should specify observed attributes or attributeChangedCallback won't be called`)
        }

        attributeChangedCallback(...args) {
            //console.log(' --- attributeChangedCallback', typeof args[2])
            if (super.attributeChangedCallback) { super.attributeChangedCallback(...args) }
            this._initialAttributeChange = true
        }

        /**
         * This is the reciprocal of init(). It will be called when an element
         * has been disconnected but not re-connected within the same tick.
         *
         * The reason that init() and deinit() exist is so that if an element is
         * moved from one place to another within the same synchronous tick,
         * that deinit and init logic will not fire unnecessarily. If logic is
         * needed in that case, then connectedCallback and disconnectedCallback
         * can be used directly instead.
         */
        deinit() {
            // Nothing much at the moment, but extending classes can extend
            // this to add deintialization logic.

            this._initialized = false
        }
    }

    classCache.set(elementClass, WebComponent)
    return WebComponent
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViQ29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaHRtbC9XZWJDb21wb25lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIGN1c3RvbUVsZW1lbnRzICovXG5cbmltcG9ydCB7IG9ic2VydmVDaGlsZHJlbiB9IGZyb20gJy4uL2NvcmUvVXRpbGl0eSdcbmltcG9ydCBqc3MgZnJvbSAnLi4vbGliL2pzcydcblxuLy8gVmVyeSB2ZXJ5IHN0dXBpZCBoYWNrIG5lZWRlZCBmb3IgU2FmYXJpIGluIG9yZGVyIGZvciB1cyB0byBiZSBhYmxlIHRvIGV4dGVuZFxuLy8gdGhlIEhUTUxFbGVtZW50IGNsYXNzLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RyYWNldXItY29tcGlsZXIvaXNzdWVzLzE3MDlcbmlmICh0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBfSFRNTEVsZW1lbnQgPSBmdW5jdGlvbiBIVE1MRWxlbWVudCgpe31cbiAgICBfSFRNTEVsZW1lbnQucHJvdG90eXBlID0gd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCA9IF9IVE1MRWxlbWVudFxufVxuXG5jb25zdCBjbGFzc0NhY2hlID0gbmV3IE1hcFxuXG5mdW5jdGlvbiBjbGFzc0V4dGVuZHNIVE1MRWxlbWVudChjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghY29uc3RydWN0b3IpIHJldHVybiBmYWxzZVxuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gSFRNTEVsZW1lbnQpIHJldHVybiB0cnVlXG4gICAgZWxzZSByZXR1cm4gY2xhc3NFeHRlbmRzSFRNTEVsZW1lbnQoY29uc3RydWN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyA/IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18uY29uc3RydWN0b3IgOiBudWxsKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBXZWJDb21wb25lbnQgYmFzZSBjbGFzcyBkeW5hbWljYWxseSwgZGVwZW5kaW5nIG9uIHdoaWNoXG4gKiBIVE1MRWxlbWVudCBjbGFzcyB5b3Ugd2FudCBpdCB0byBleHRlbmQgZnJvbS4gRXh0ZW5kIGZyb20gV2ViQ29tcG9uZW50IHdoZW5cbiAqIG1ha2luZyBhIG5ldyBDdXN0b20gRWxlbWVudCBjbGFzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgV2ViQ29tcG9uZW50ID0gV2ViQ29tcG9uZW50TWl4aW4oSFRNTEJ1dHRvbkVsZW1lbnQpXG4gKiBjbGFzcyBBd2Vzb21lQnV0dG9uIGV4dGVuZHMgV2ViQ29tcG9uZW50IHsgLi4uIH1cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbGVtZW50Q2xhc3MgVGhlIGNsYXNzIHRoYXQgdGhlIGdlbmVyYXRlZCBXZWJDb21wb25lbnRcbiAqIGJhc2UgY2xhc3Mgd2lsbCBleHRlbmQgZnJvbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHRcbmZ1bmN0aW9uIFdlYkNvbXBvbmVudE1peGluKGVsZW1lbnRDbGFzcykge1xuICAgIGlmICghZWxlbWVudENsYXNzKSBlbGVtZW50Q2xhc3MgPSBIVE1MRWxlbWVudFxuXG4gICAgaWYgKCFjbGFzc0V4dGVuZHNIVE1MRWxlbWVudChlbGVtZW50Q2xhc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGFyZ3VtZW50IHRvIFdlYkNvbXBvbmVudE1peGluIG11c3QgYmUgYSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgZnJvbSBvciBpcyBIVE1MRWxlbWVudC4nXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvLyBpZiBhIGJhc2UgY2xhc3MgdGhhdCBleHRlbmRzIHRoZSBnaXZlbiBgZWxlbWVudENsYXNzYCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgLy8gY3JlYXRlZCwgcmV0dXJuIGl0LlxuICAgIGlmIChjbGFzc0NhY2hlLmhhcyhlbGVtZW50Q2xhc3MpKVxuICAgICAgICByZXR1cm4gY2xhc3NDYWNoZS5nZXQoZWxlbWVudENsYXNzKVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgaXQuXG4gICAgY2xhc3MgV2ViQ29tcG9uZW50IGV4dGVuZHMgZWxlbWVudENsYXNzIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKClcblxuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgbm8gQ3VzdG9tIEVsZW1lbnRzIHYxIEFQSSBleGlzdHMuXG4gICAgICAgICAgICBpZiAoISgnY3VzdG9tRWxlbWVudHMnIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgICAgICBZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgQ3VzdG9tIEVsZW1lbnRzIEFQSS4gWW91J2xsXG4gICAgICAgICAgICAgICAgICAgIG5lZWQgdG8gaW5zdGFsbCBhIHBvbHlmaWxsLiBTZWUgaG93IGF0IGh0dHA6Ly8uLi4uXG4gICAgICAgICAgICAgICAgYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxBdHRyaWJ1dGVDaGFuZ2UgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5fY2hpbGRPYnNlcnZlciA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50IHRoZXNlLlxuICAgICAgICBjaGlsZENvbm5lY3RlZENhbGxiYWNrKGNoaWxkKSB7IH1cbiAgICAgICAgY2hpbGREaXNjb25uZWN0ZWRDYWxsYmFjayhjaGlsZCkgeyB9XG5cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKClcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWVcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfY3JlYXRlU3R5bGVzKCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IGpzcy5jcmVhdGVSdWxlKHRoaXMuZ2V0U3R5bGVzKCkpXG5cbiAgICAgICAgICAgIHJ1bGUuYXBwbHlUbyh0aGlzKVxuXG4gICAgICAgICAgICByZXR1cm4gcnVsZVxuICAgICAgICB9XG5cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBpZiAoc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKClcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIERlZmVyciB0byB0aGUgbmV4dCB0aWNrIGJlZm9yZSBjbGVhbmluZyB1cCBpbiBjYXNlIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhY3R1YWxseSBiZWluZyByZS1hdHRhY2hlZCBzb21ld2hlcmUgZWxzZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgLy8gc2FtZSB0aWNrIChkZXRhY2hpbmcgYW5kIGF0dGFjaGluZyBpcyBzeW5jaHJvbm91cywgc28gYnlcbiAgICAgICAgICAgIC8vIGRlZmVycmluZyB0byB0aGUgbmV4dCB0aWNrIHdlJ2xsIGJlIGFibGUgdG8ga25vdyBpZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gd2FzIHJlLWF0dGFjaGVkIG9yIG5vdCBpbiBvcmRlciB0byBjbGVhbiB1cCBvciBub3QpLiBOb3RlIHRoYXRcbiAgICAgICAgICAgIC8vIGFwcGVuZENoaWxkIGNhbiBiZSB1c2VkIHRvIG1vdmUgYW4gZWxlbWVudCB0byBhbm90aGVyIHBhcmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCwgaW4gd2hpY2ggY2FzZSBjb25uZWN0ZWRDYWxsYmFjayBhbmQgZGlzY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgIC8vIGJvdGggZ2V0IGNhbGxlZCwgYW5kIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3QgbmVjZXNzYXJpbHkgd2FudCB0b1xuICAgICAgICAgICAgLy8gY2xlYW4gdXAuIElmIHRoZSBlbGVtZW50IGdldHMgcmUtYXR0YWNoZWQgYmVmb3JlIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgZ2V0cyBtb3ZlZCksIHRoZW4gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGVcbiAgICAgICAgICAgIC8vIHN0dWZmIHRoYXQgd291bGQgYmUgY2xlYW5lZCB1cCBieSBhbiBleHRlbmRpbmcgY2xhc3MnIGRlaW5pdFxuICAgICAgICAgICAgLy8gbWV0aG9kIGJ5IG5vdCBydW5uaW5nIHRoZSBmb2xsb3dpbmcgdGhpcy5kZWluaXQoKSBjYWxsLlxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7IC8vIGRlZmVyciB0byB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICAgICAgICAgICAgLy8gQXMgbWVudGlvbmVkIGluIHRoZSBwcmV2aW91cyBjb21tZW50LCBpZiB0aGUgZWxlbWVudCB3YXMgbm90XG4gICAgICAgICAgICAgICAgLy8gcmUtYXR0YWNoZWQgaW4gdGhlIGxhc3QgdGljayAoZm9yIGV4YW1wbGUsIGl0IHdhcyBtb3ZlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgZWxlbWVudCksIHRoZW4gY2xlYW4gdXAuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWluaXQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy9hc3luYyBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIC8vaWYgKHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKSBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpXG4gICAgICAgICAgICAvL3RoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vLy8gRGVmZXJyIHRvIHRoZSBuZXh0IHRpY2sgYmVmb3JlIGNsZWFuaW5nIHVwIGluIGNhc2UgdGhlXG4gICAgICAgICAgICAvLy8vIGVsZW1lbnQgaXMgYWN0dWFsbHkgYmVpbmcgcmUtYXR0YWNoZWQgc29tZXdoZXJlIGVsc2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgIC8vLy8gc2FtZSB0aWNrIChkZXRhY2hpbmcgYW5kIGF0dGFjaGluZyBpcyBzeW5jaHJvbm91cywgc28gYnlcbiAgICAgICAgICAgIC8vLy8gZGVmZXJyaW5nIHRvIHRoZSBuZXh0IHRpY2sgd2UnbGwgYmUgYWJsZSB0byBrbm93IGlmIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAvLy8vIHdhcyByZS1hdHRhY2hlZCBvciBub3QgaW4gb3JkZXIgdG8gY2xlYW4gdXAgb3Igbm90KS4gTm90ZSB0aGF0XG4gICAgICAgICAgICAvLy8vIGFwcGVuZENoaWxkIGNhbiBiZSB1c2VkIHRvIG1vdmUgYW4gZWxlbWVudCB0byBhbm90aGVyIHBhcmVudFxuICAgICAgICAgICAgLy8vLyBlbGVtZW50LCBpbiB3aGljaCBjYXNlIGNvbm5lY3RlZENhbGxiYWNrIGFuZCBkaXNjb25uZWN0ZWRDYWxsYmFja1xuICAgICAgICAgICAgLy8vLyBib3RoIGdldCBjYWxsZWQsIGFuZCBpbiB3aGljaCBjYXNlIHdlIGRvbid0IG5lY2Vzc2FyaWx5IHdhbnQgdG9cbiAgICAgICAgICAgIC8vLy8gY2xlYW4gdXAuIElmIHRoZSBlbGVtZW50IGdldHMgcmUtYXR0YWNoZWQgYmVmb3JlIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIC8vLy8gKGZvciBleGFtcGxlLCBnZXRzIG1vdmVkKSwgdGhlbiB3ZSB3YW50IHRvIHByZXNlcnZlIHRoZVxuICAgICAgICAgICAgLy8vLyBzdHVmZiB0aGF0IHdvdWxkIGJlIGNsZWFuZWQgdXAgYnkgYW4gZXh0ZW5kaW5nIGNsYXNzJyBkZWluaXRcbiAgICAgICAgICAgIC8vLy8gbWV0aG9kIGJ5IG5vdCBydW5uaW5nIHRoZSBmb2xsb3dpbmcgdGhpcy5kZWluaXQoKSBjYWxsLlxuICAgICAgICAgICAgLy9hd2FpdCBQcm9taXNlLnJlc29sdmUoKSAvLyBkZWZlcnIgdG8gdGhlIG5leHQgdGljay5cblxuICAgICAgICAgICAgLy8vLyBBcyBtZW50aW9uZWQgaW4gdGhlIHByZXZpb3VzIGNvbW1lbnQsIGlmIHRoZSBlbGVtZW50IHdhcyBub3RcbiAgICAgICAgICAgIC8vLy8gcmUtYXR0YWNoZWQgaW4gdGhlIGxhc3QgdGljayAoZm9yIGV4YW1wbGUsIGl0IHdhcyBtb3ZlZCB0b1xuICAgICAgICAgICAgLy8vLyBhbm90aGVyIGVsZW1lbnQpLCB0aGVuIGNsZWFuIHVwLlxuICAgICAgICAgICAgLy9pZiAoIXRoaXMuX2Nvbm5lY3RlZCAmJiB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vdGhpcy5kZWluaXQoKVxuICAgICAgICAgICAgLy99XG4gICAgICAgIC8vfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBleHRlbmRpbmcgY2xhc3NlcywgaXQgc2hvdWxkIHJldHVyblxuICAgICAgICAgKiBKU1MtY29tcGF0aWJsZSBzdHlsaW5nLiBTZWUgaHR0cDovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MgZm9yXG4gICAgICAgICAqIGRvY3VtZW50YXRpb24uXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IGlzIGNhbGxlZCBleGFjdGx5IG9uY2UsIHRoZSBmaXJzdCB0aW1lIHRoaXMgZWxlbWVudCBpc1xuICAgICAgICAgKiBjb25uZWN0ZWQgaW50byB0aGUgRE9NLiBXaGVuIGFuIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIHRoZW5cbiAgICAgICAgICogY29ubmVjdGVkIHJpZ2h0IGF3YXkgd2l0aGluIHRoZSBzYW1lIHN5bmNocm9ub3VzIHRpY2ssIGluaXQoKSBpcyBub3RcbiAgICAgICAgICogZmlyZWQgYWdhaW4uIEhvd2V2ZXIsIGlmIGFuIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGFuZCB0aGUgY3VycmVudFxuICAgICAgICAgKiB0aWNrIGNvbXBsZXRlcyBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIGFnYWluLCB0aGVuIGRlaW5pdCgpXG4gICAgICAgICAqIHdpbGwgYmUgY2FsbGVkIChpLmUuIHRoZSBlbGVtZW50IHdhcyBub3Qgc2ltcGx5IG1vdmVkIHRvIGEgbmV3XG4gICAgICAgICAqIGxvY2F0aW9uLCBpdCB3YXMgYWN0dWFsbHkgcmVtb3ZlZCksIHRoZW4gdGhlIG5leHQgdGltZSB0aGF0IHRoZVxuICAgICAgICAgKiBlbGVtZW50IGlzIGNvbm5lY3RlZCBiYWNrIGludG8gRE9NIGluaXQoKSB3aWxsIGJlIGNhbGxlZCBhZ2Fpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBpbiBjb250cmFzdCB0byBjb25uZWN0ZWRDYWxsYmFjayBhbmQgZGlzY29ubmVjdGVkQ2FsbGJhY2s6XG4gICAgICAgICAqIGNvbm5lY3RlZENhbGxiYWNrIGlzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGZpcmUgZXZlbiBpZiB0aGUgZWxlbWV0XG4gICAgICAgICAqIHdhcyBwcmV2aW91c2x5IGRpc2Nvbm5lY3RlZCBpbiB0aGUgc2FtZSBzeW5jaHJvbm91cyB0aWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgLi4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGV4dGVuZCB0aGlzIHRvIGFkZCBzdWNoIGxvZ2ljLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3R5bGUpIHRoaXMuX3N0eWxlID0gdGhpcy5fY3JlYXRlU3R5bGVzKClcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGFueSBub2RlcyB0aGF0IG1heSBoYXZlIGJlZW4gY29ubmVjdGVkIGJlZm9yZSBgdGhpc2Agbm9kZVxuICAgICAgICAgICAgLy8gd2FzIGNyZWF0ZWQgKGYuZS4gY2hpbGQgbm9kZXMgdGhhdCB3ZXJlIGNvbm5lY3RlZCBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyBjdXN0b20gZWxlbWVudHMgd2VyZSByZWdpc3RlcmVkIGFuZCB3aGljaCB3b3VsZCB0aGVyZWZvcmUgbm90IGJlXG4gICAgICAgICAgICAvLyBkZXRlY3RlZCBieSB0aGUgZm9sbG93aW5nIE11dGF0aW9uT2JzZXJ2ZXIpLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGlsZE9ic2VydmVyKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaW1lb3V0IG5lZWRlZCBpbiBjYXNlIHRoZSBDdXN0b20gRWxlbWVudCBjbGFzc2VzIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlcmVkIGFmdGVyIHRoZSBlbGVtZW50cyBhcmUgYWxyZWFkeSBkZWZpbmVkIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBET00gYnV0IG5vdCB5ZXQgdXBncmFkZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgYG5vZGVgIGFyZ1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBiZSBhIGA8bW90b3Itbm9kZT5gIGJ1dCBpZiBpdCBpc24ndCB1cGdyYWRlZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0cyBBUEkgd29uJ3QgYmUgYXZhaWxhYmxlIHRvIHRoZSBsb2dpYyBpbnNpZGUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkQ29ubmVjdGVkQ2FsbGJhY2suIFRoZSByZWFzb24gdGhpcyBoYXBwZW5zIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgcGFyZW50cyBhcmUgdXBncmFkZWQgZmlyc3QgYW5kIHRoZWlyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RlZENhbGxiYWNrcyBmaXJlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZ3JhZGVkLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEZJWE1FIFBFUkZPUk1BTkNFOiBUaGlzIGNhdXNlcyBhIHBvc3NpYmx5IFwiYnVnZ3lcIiBlZmZlY3Qgd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgaW4gYSB0cmVlIHdpbGwgYXBwZWFyIGluIGludGVydmFscyBvZiA1XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kcy4gV2Ugd2FudCBlbGVtZW50cyB0byBiZSByZW5kZXJlZCBpbnN0YW50bHksXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBmaXJzdCBmcmFtZSB0aGF0IHRoZXkgYXJlIHByZXNlbnQgaW4gdGhlIHNjZW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3cgY2FuIHdlIGZpeCB0aGlzPyBNYXliZSB3ZSBjYW4gc3dpdGNoIHRvIGEgUHJvbWlzZSBtaWNyb3Rhc2suXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbD1jaGlsZHJlbi5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZENvbm5lY3RlZENhbGxiYWNrKGNoaWxkcmVuW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA1KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkT2JzZXJ2ZXIgPSBvYnNlcnZlQ2hpbGRyZW4odGhpcywgdGhpcy5jaGlsZENvbm5lY3RlZENhbGxiYWNrLCB0aGlzLmNoaWxkRGlzY29ubmVjdGVkQ2FsbGJhY2spXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgaW4gY2FzZSBzb21lIGF0dHJpYnV0ZXMgaGF2ZVxuICAgICAgICAgICAgLy8gZXhpc3RlZCBiZWZvcmUgdGhlIGN1c3RvbSBlbGVtZW50IHdhcyB1cGdyYWRlZC5cbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbEF0dHJpYnV0ZUNoYW5nZSAmJiB0aGlzLmhhc0F0dHJpYnV0ZXMoKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gSFRNTEVsZW1lbnQjYXR0cmlidXRlcyBpcyBhIE5hbWVkTm9kZU1hcCB3aGljaCBpcyBub3QgYW5cbiAgICAgICAgICAgICAgICAvLyBpdGVyYWJsZSwgc28gd2UgdXNlIEFycmF5LmZyb20uIFNlZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjM0XG4gICAgICAgICAgICAgICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGw9YXR0cmlidXRlcy5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyaWJ1dGVzW2ldLm5hbWUsIG51bGwsIGF0dHJpYnV0ZXNbaV0udmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2ViQ29tcG9uZW50OiBZb3VyIGN1c3RvbSBlbGVtZW50ICgkeyB0aGlzLm5hbWUgfSkgc2hvdWxkIHNwZWNpZnkgb2JzZXJ2ZWQgYXR0cmlidXRlcyBvciBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgd29uJ3QgYmUgY2FsbGVkYClcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayguLi5hcmdzKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcgLS0tIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsIHR5cGVvZiBhcmdzWzJdKVxuICAgICAgICAgICAgaWYgKHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKC4uLmFyZ3MpXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsQXR0cmlidXRlQ2hhbmdlID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHJlY2lwcm9jYWwgb2YgaW5pdCgpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGFuIGVsZW1lbnRcbiAgICAgICAgICogaGFzIGJlZW4gZGlzY29ubmVjdGVkIGJ1dCBub3QgcmUtY29ubmVjdGVkIHdpdGhpbiB0aGUgc2FtZSB0aWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmVhc29uIHRoYXQgaW5pdCgpIGFuZCBkZWluaXQoKSBleGlzdCBpcyBzbyB0aGF0IGlmIGFuIGVsZW1lbnQgaXNcbiAgICAgICAgICogbW92ZWQgZnJvbSBvbmUgcGxhY2UgdG8gYW5vdGhlciB3aXRoaW4gdGhlIHNhbWUgc3luY2hyb25vdXMgdGljayxcbiAgICAgICAgICogdGhhdCBkZWluaXQgYW5kIGluaXQgbG9naWMgd2lsbCBub3QgZmlyZSB1bm5lY2Vzc2FyaWx5LiBJZiBsb2dpYyBpc1xuICAgICAgICAgKiBuZWVkZWQgaW4gdGhhdCBjYXNlLCB0aGVuIGNvbm5lY3RlZENhbGxiYWNrIGFuZCBkaXNjb25uZWN0ZWRDYWxsYmFja1xuICAgICAgICAgKiBjYW4gYmUgdXNlZCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGVpbml0KCkge1xuICAgICAgICAgICAgLy8gTm90aGluZyBtdWNoIGF0IHRoZSBtb21lbnQsIGJ1dCBleHRlbmRpbmcgY2xhc3NlcyBjYW4gZXh0ZW5kXG4gICAgICAgICAgICAvLyB0aGlzIHRvIGFkZCBkZWludGlhbGl6YXRpb24gbG9naWMuXG5cbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ2FjaGUuc2V0KGVsZW1lbnRDbGFzcywgV2ViQ29tcG9uZW50KVxuICAgIHJldHVybiBXZWJDb21wb25lbnRcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxTQUFTLGVBQWUsUUFBUSxpQkFBaUI7QUFDakQsT0FBTyxHQUFHLE1BQU0sWUFBWTs7Ozs7QUFLNUIsSUFBSSxPQUFPLE1BQU0sQ0FBQyxXQUFXLElBQUksVUFBVSxFQUFFO0lBQ3pDLE1BQU0sWUFBWSxHQUFHLFNBQVMsV0FBVyxFQUFFLEVBQUU7SUFDN0MsWUFBWSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVM7SUFDckQsTUFBTSxDQUFDLFdBQVcsR0FBRyxZQUFZO0NBQ3BDOztBQUVELE1BQU0sVUFBVSxHQUFHLElBQUksR0FB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