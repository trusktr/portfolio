/* global customElements */

import { observeChildren } from '../core/Utility'
import jss from '../lib/jss'

// Very very stupid hack needed for Safari in order for us to be able to extend
// the HTMLElement class. See:
// https://github.com/google/traceur-compiler/issues/1709
if (typeof window.HTMLElement != 'function') {
    const _HTMLElement = function HTMLElement(){}
    _HTMLElement.prototype = window.HTMLElement.prototype
    window.HTMLElement = _HTMLElement
}

const classCache = new Map

function classExtendsHTMLElement(constructor) {
    if (!constructor) { return false }
    if (constructor === HTMLElement) { return true }
    else { return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null) }
}

/**
 * Creates a WebComponent base class dynamically, depending on which
 * HTMLElement class you want it to extend from. Extend from WebComponent when
 * making a new Custom Element class.
 *
 * @example
 * const WebComponent = WebComponentMixin(HTMLButtonElement)
 * class AwesomeButton extends WebComponent { ... }
 *
 * @param {Function} elementClass The class that the generated WebComponent
 * base class will extend from.
 */
export default
function WebComponentMixin(elementClass) {
    if (!elementClass) { elementClass = HTMLElement }

    if (!classExtendsHTMLElement(elementClass)) {
        throw new TypeError(
            'The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.'
        )
    }

    // if a base class that extends the given `elementClass` has already been
    // created, return it.
    if (classCache.has(elementClass))
        { return classCache.get(elementClass) }

    // otherwise, create it.
    var WebComponent = (function (elementClass) {
        function WebComponent() {
            elementClass.call(this)

            // If the following is true, then we know the user should be using
            // `document.registerElement()` to define an element from this class.
            // `document.registerElement()` creates a new constructor, so if the
            // constructor here is being called then that means the user is not
            // instantiating a DOM HTMLElement as expected because it is required
            // that the constructor returned from `document.registerElement` be used
            // instead (this is a flaw of Custom Elements v0 which is fixed in v1
            // where class constructors can be used directly).
            if ('registerElement' in document && !('customElements' in window)) {
                throw new Error("\n                    You cannot instantiate this class directly without first registering it\n                    with `document.registerElement(...)`. See an example at http://....\n                ")
            }

            // Throw an error if no Custom Elements API exists.
            if (!('registerElement' in document) && !('customElements' in window)) {
                throw new Error("\n                    Your browser does not support the Custom Elements API. You'll\n                    need to install a polyfill. See how at http://....\n                ")
            }

            // otherwise the V1 API exists, so call the createdCallback, which
            // is what Custom Elements v0 would call by default. Subclasses of
            // WebComponent should put instantiation logic in createdCallback
            // instead of in a custom constructor if backwards compatibility is
            // to be maintained.
            this.createdCallback()
        }

        if ( elementClass ) WebComponent.__proto__ = elementClass;
        WebComponent.prototype = Object.create( elementClass && elementClass.prototype );
        WebComponent.prototype.constructor = WebComponent;

        WebComponent.prototype.createdCallback = function createdCallback () {
            this._attached = false
            this._initialized = false
            this._initialAttributeChange = false
            this._childObserver = null
            this._style = null
        };

        // Subclasses can implement these.
        WebComponent.prototype.childConnectedCallback = function childConnectedCallback (child) {};
        WebComponent.prototype.childDisconnectedCallback = function childDisconnectedCallback (child) {};

        WebComponent.prototype.connectedCallback = function connectedCallback () {
            if (elementClass.prototype.connectedCallback) { elementClass.prototype.connectedCallback.call(this) }
            this._attached = true

            if (!this._initialized) {
                this.init()
                this._initialized = true
            }
        };
        WebComponent.prototype.attachedCallback = function attachedCallback () { this.connectedCallback() }; // back-compat

        WebComponent.prototype._createStyles = function _createStyles () {
            const rule = jss.createRule(this.getStyles())

            rule.applyTo(this)

            return rule
        };

        WebComponent.prototype.disconnectedCallback = function disconnectedCallback () {
            var this$1 = this;

            if (elementClass.prototype.disconnectedCallback) { elementClass.prototype.disconnectedCallback.call(this) }
            this._attached = false

            // Deferr to the next tick before cleaning up in case the
            // element is actually being re-attached somewhere else within this
            // same tick (detaching and attaching is synchronous, so by
            // deferring to the next tick we'll be able to know if the element
            // was re-attached or not in order to clean up or not). Note that
            // appendChild can be used to move an element to another parent
            // element, in which case connectedCallback and disconnectedCallback
            // both get called, and in which case we don't necessarily want to
            // clean up. If the element gets re-attached before the next tick
            // (for example, gets moved), then we want to preserve the
            // stuff that would be cleaned up by an extending class' deinit
            // method by not running the following this.deinit() call.
            Promise.resolve().then(function () { // deferr to the next tick.

                // As mentioned in the previous comment, if the element was not
                // re-attached in the last tick (for example, it was moved to
                // another element), then clean up.
                if (!this$1._attached && this$1._initialized) {
                    this$1.deinit()
                }
            })
        };
        //async disconnectedCallback() {
            //if (super.disconnectedCallback) super.disconnectedCallback()
            //this._attached = false

            //// Deferr to the next tick before cleaning up in case the
            //// element is actually being re-attached somewhere else within this
            //// same tick (detaching and attaching is synchronous, so by
            //// deferring to the next tick we'll be able to know if the element
            //// was re-attached or not in order to clean up or not). Note that
            //// appendChild can be used to move an element to another parent
            //// element, in which case connectedCallback and disconnectedCallback
            //// both get called, and in which case we don't necessarily want to
            //// clean up. If the element gets re-attached before the next tick
            //// (for example, gets moved), then we want to preserve the
            //// stuff that would be cleaned up by an extending class' deinit
            //// method by not running the following this.deinit() call.
            //await Promise.resolve() // deferr to the next tick.

            //// As mentioned in the previous comment, if the element was not
            //// re-attached in the last tick (for example, it was moved to
            //// another element), then clean up.
            //if (!this._attached && this._initialized) {
                //this.deinit()
            //}
        //}
        WebComponent.prototype.detachedCallback = function detachedCallback () { this.disconnectedCallback() }; // back-compat

        /**
         * This method can be overridden by extending classes, it should return
         * JSS-compatible styling. See http://github.com/cssinjs/jss for
         * documentation.
         * @abstract
         */
        WebComponent.prototype.getStyles = function getStyles () {
            return {}
        };


        /**
         * Init is called exactly once, the first time this element is
         * connected into the DOM. When an element is disconnected then
         * connected right away within the same synchronous tick, init() is not
         * fired again. However, if an element is disconnected and the current
         * tick completes before the element is connected again, then deinit()
         * will be called (i.e. the element was not simply moved to a new
         * location, it was actually removed), then the next time that the
         * element is connected back into DOM init() will be called again.
         *
         * This is in contrast to connectedCallback and disconnectedCallback:
         * connectedCallback is guaranteed to always fire even if the elemet
         * was previously disconnected in the same synchronous tick.
         *
         * For example, ...
         *
         * Subclasses should extend this to add such logic.
         */
        WebComponent.prototype.init = function init () {
            var this$1 = this;

            if (!this._style) { this._style = this._createStyles() }

            // Handle any nodes that may have been connected before `this` node
            // was created (f.e. child nodes that were connected before the
            // custom elements were registered and which would therefore not be
            // detected by the following MutationObserver).
            if (!this._childObserver) {

                const children = this.childNodes
                if (children.length) {

                    // Timeout needed in case the Custom Element classes are
                    // registered after the elements are already defined in the
                    // DOM but not yet upgraded. This means that the `node` arg
                    // might be a `<motor-node>` but if it isn't upgraded then
                    // its API won't be available to the logic inside the
                    // childConnectedCallback. The reason this happens is
                    // because parents are upgraded first and their
                    // connectedCallbacks fired before their children are
                    // upgraded.
                    //
                    // TODO FIXME PERFORMANCE: This causes a possibly "buggy" effect where
                    // elements in a tree will appear in intervals of 5
                    // milliseconds. We want elements to be rendered instantly,
                    // in the first frame that they are present in the scene
                    // graph.
                    // How can we fix this? Maybe we can switch to a Promise microtask.
                    setTimeout(function () {
                        for (let l=children.length, i=0; i<l; i+=1) {
                            this$1.childConnectedCallback(children[i])
                        }
                    }, 5)
                }

                this._childObserver = observeChildren(this, this.childConnectedCallback, this.childDisconnectedCallback)
            }

            // fire this.attributeChangedCallback in case some attributes have
            // existed before the custom element was upgraded.
            if (!this._initialAttributeChange && this.hasAttributes()) {

                // HTMLElement#attributes is a NamedNodeMap which is not an
                // iterable, so we use Array.from. See:
                // https://github.com/zloirock/core-js/issues/234
                var ref = this;
                var attributes = ref.attributes;
                for (let l=attributes.length, i=0; i<l; i+=1)
                    { this$1.attributeChangedCallback(attributes[i].name, null, attributes[i].value) }
            }
        };

        WebComponent.prototype.attributeChangedCallback = function attributeChangedCallback () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            //console.log(' --- attributeChangedCallback', typeof args[2])
            if (elementClass.prototype.attributeChangedCallback) { elementClass.prototype.attributeChangedCallback.apply(this, args) }
            this._initialAttributeChange = true
        };

        /**
         * This is the reciprocal of init(). It will be called when an element
         * has been disconnected but not re-connected within the same tick.
         *
         * The reason that init() and deinit() exist is so that if an element is
         * moved from one place to another within the same synchronous tick,
         * that deinit and init logic will not fire unnecessarily. If logic is
         * needed in that case, then connectedCallback and disconnectedCallback
         * can be used directly instead.
         */
        WebComponent.prototype.deinit = function deinit () {
            // Nothing much at the moment, but extending classes can extend
            // this to add deintialization logic.

            this._initialized = false
        };

        return WebComponent;
    }(elementClass));

    classCache.set(elementClass, WebComponent)
    return WebComponent
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViLWNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2h0bWwvd2ViLWNvbXBvbmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgY3VzdG9tRWxlbWVudHMgKi9cblxuaW1wb3J0IHsgb2JzZXJ2ZUNoaWxkcmVuIH0gZnJvbSAnLi4vY29yZS9VdGlsaXR5J1xuaW1wb3J0IGpzcyBmcm9tICcuLi9saWIvanNzJ1xuXG4vLyBWZXJ5IHZlcnkgc3R1cGlkIGhhY2sgbmVlZGVkIGZvciBTYWZhcmkgaW4gb3JkZXIgZm9yIHVzIHRvIGJlIGFibGUgdG8gZXh0ZW5kXG4vLyB0aGUgSFRNTEVsZW1lbnQgY2xhc3MuIFNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvdHJhY2V1ci1jb21waWxlci9pc3N1ZXMvMTcwOVxuaWYgKHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IF9IVE1MRWxlbWVudCA9IGZ1bmN0aW9uIEhUTUxFbGVtZW50KCl7fVxuICAgIF9IVE1MRWxlbWVudC5wcm90b3R5cGUgPSB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlXG4gICAgd2luZG93LkhUTUxFbGVtZW50ID0gX0hUTUxFbGVtZW50XG59XG5cbmNvbnN0IGNsYXNzQ2FjaGUgPSBuZXcgTWFwXG5cbmZ1bmN0aW9uIGNsYXNzRXh0ZW5kc0hUTUxFbGVtZW50KGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCFjb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSBIVE1MRWxlbWVudCkgcmV0dXJuIHRydWVcbiAgICBlbHNlIHJldHVybiBjbGFzc0V4dGVuZHNIVE1MRWxlbWVudChjb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19wcm90b19fID8gY29uc3RydWN0b3IucHJvdG90eXBlLl9fcHJvdG9fXy5jb25zdHJ1Y3RvciA6IG51bGwpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFdlYkNvbXBvbmVudCBiYXNlIGNsYXNzIGR5bmFtaWNhbGx5LCBkZXBlbmRpbmcgb24gd2hpY2hcbiAqIEhUTUxFbGVtZW50IGNsYXNzIHlvdSB3YW50IGl0IHRvIGV4dGVuZCBmcm9tLiBFeHRlbmQgZnJvbSBXZWJDb21wb25lbnQgd2hlblxuICogbWFraW5nIGEgbmV3IEN1c3RvbSBFbGVtZW50IGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBXZWJDb21wb25lbnQgPSBXZWJDb21wb25lbnRNaXhpbihIVE1MQnV0dG9uRWxlbWVudClcbiAqIGNsYXNzIEF3ZXNvbWVCdXR0b24gZXh0ZW5kcyBXZWJDb21wb25lbnQgeyAuLi4gfVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVsZW1lbnRDbGFzcyBUaGUgY2xhc3MgdGhhdCB0aGUgZ2VuZXJhdGVkIFdlYkNvbXBvbmVudFxuICogYmFzZSBjbGFzcyB3aWxsIGV4dGVuZCBmcm9tLlxuICovXG5leHBvcnQgZGVmYXVsdFxuZnVuY3Rpb24gV2ViQ29tcG9uZW50TWl4aW4oZWxlbWVudENsYXNzKSB7XG4gICAgaWYgKCFlbGVtZW50Q2xhc3MpIGVsZW1lbnRDbGFzcyA9IEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIWNsYXNzRXh0ZW5kc0hUTUxFbGVtZW50KGVsZW1lbnRDbGFzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdUaGUgYXJndW1lbnQgdG8gV2ViQ29tcG9uZW50TWl4aW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIHRoYXQgZXh0ZW5kcyBmcm9tIG9yIGlzIEhUTUxFbGVtZW50LidcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8vIGlmIGEgYmFzZSBjbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGdpdmVuIGBlbGVtZW50Q2xhc3NgIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAvLyBjcmVhdGVkLCByZXR1cm4gaXQuXG4gICAgaWYgKGNsYXNzQ2FjaGUuaGFzKGVsZW1lbnRDbGFzcykpXG4gICAgICAgIHJldHVybiBjbGFzc0NhY2hlLmdldChlbGVtZW50Q2xhc3MpXG5cbiAgICAvLyBvdGhlcndpc2UsIGNyZWF0ZSBpdC5cbiAgICBjbGFzcyBXZWJDb21wb25lbnQgZXh0ZW5kcyBlbGVtZW50Q2xhc3Mge1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKCkgaXMgdXNlZCBpbiB2MSBDdXN0b20gRWxlbWVudHMgaW5zdGVhZCBvZlxuICAgICAgICAvLyBjcmVhdGVkQ2FsbGJhY2soKSBhcyBpbiB2MC5cbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZSwgdGhlbiB3ZSBrbm93IHRoZSB1c2VyIHNob3VsZCBiZSB1c2luZ1xuICAgICAgICAgICAgLy8gYGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgpYCB0byBkZWZpbmUgYW4gZWxlbWVudCBmcm9tIHRoaXMgY2xhc3MuXG4gICAgICAgICAgICAvLyBgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KClgIGNyZWF0ZXMgYSBuZXcgY29uc3RydWN0b3IsIHNvIGlmIHRoZVxuICAgICAgICAgICAgLy8gY29uc3RydWN0b3IgaGVyZSBpcyBiZWluZyBjYWxsZWQgdGhlbiB0aGF0IG1lYW5zIHRoZSB1c2VyIGlzIG5vdFxuICAgICAgICAgICAgLy8gaW5zdGFudGlhdGluZyBhIERPTSBIVE1MRWxlbWVudCBhcyBleHBlY3RlZCBiZWNhdXNlIGl0IGlzIHJlcXVpcmVkXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBjb25zdHJ1Y3RvciByZXR1cm5lZCBmcm9tIGBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnRgIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIGluc3RlYWQgKHRoaXMgaXMgYSBmbGF3IG9mIEN1c3RvbSBFbGVtZW50cyB2MCB3aGljaCBpcyBmaXhlZCBpbiB2MVxuICAgICAgICAgICAgLy8gd2hlcmUgY2xhc3MgY29uc3RydWN0b3JzIGNhbiBiZSB1c2VkIGRpcmVjdGx5KS5cbiAgICAgICAgICAgIGlmICgncmVnaXN0ZXJFbGVtZW50JyBpbiBkb2N1bWVudCAmJiAhKCdjdXN0b21FbGVtZW50cycgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgICAgIFlvdSBjYW5ub3QgaW5zdGFudGlhdGUgdGhpcyBjbGFzcyBkaXJlY3RseSB3aXRob3V0IGZpcnN0IHJlZ2lzdGVyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIHdpdGggXFxgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KC4uLilcXGAuIFNlZSBhbiBleGFtcGxlIGF0IGh0dHA6Ly8uLi4uXG4gICAgICAgICAgICAgICAgYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgbm8gQ3VzdG9tIEVsZW1lbnRzIEFQSSBleGlzdHMuXG4gICAgICAgICAgICBpZiAoISgncmVnaXN0ZXJFbGVtZW50JyBpbiBkb2N1bWVudCkgJiYgISgnY3VzdG9tRWxlbWVudHMnIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgICAgICAgICBZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgQ3VzdG9tIEVsZW1lbnRzIEFQSS4gWW91J2xsXG4gICAgICAgICAgICAgICAgICAgIG5lZWQgdG8gaW5zdGFsbCBhIHBvbHlmaWxsLiBTZWUgaG93IGF0IGh0dHA6Ly8uLi4uXG4gICAgICAgICAgICAgICAgYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBWMSBBUEkgZXhpc3RzLCBzbyBjYWxsIHRoZSBjcmVhdGVkQ2FsbGJhY2ssIHdoaWNoXG4gICAgICAgICAgICAvLyBpcyB3aGF0IEN1c3RvbSBFbGVtZW50cyB2MCB3b3VsZCBjYWxsIGJ5IGRlZmF1bHQuIFN1YmNsYXNzZXMgb2ZcbiAgICAgICAgICAgIC8vIFdlYkNvbXBvbmVudCBzaG91bGQgcHV0IGluc3RhbnRpYXRpb24gbG9naWMgaW4gY3JlYXRlZENhbGxiYWNrXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGluIGEgY3VzdG9tIGNvbnN0cnVjdG9yIGlmIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGlzXG4gICAgICAgICAgICAvLyB0byBiZSBtYWludGFpbmVkLlxuICAgICAgICAgICAgdGhpcy5jcmVhdGVkQ2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbEF0dHJpYnV0ZUNoYW5nZSA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLl9jaGlsZE9ic2VydmVyID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnQgdGhlc2UuXG4gICAgICAgIGNoaWxkQ29ubmVjdGVkQ2FsbGJhY2soY2hpbGQpIHt9XG4gICAgICAgIGNoaWxkRGlzY29ubmVjdGVkQ2FsbGJhY2soY2hpbGQpIHt9XG5cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKClcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KClcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hlZENhbGxiYWNrKCkgeyB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKCkgfSAvLyBiYWNrLWNvbXBhdFxuXG4gICAgICAgIF9jcmVhdGVTdHlsZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0ganNzLmNyZWF0ZVJ1bGUodGhpcy5nZXRTdHlsZXMoKSlcblxuICAgICAgICAgICAgcnVsZS5hcHBseVRvKHRoaXMpXG5cbiAgICAgICAgICAgIHJldHVybiBydWxlXG4gICAgICAgIH1cblxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGlmIChzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaykgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBEZWZlcnIgdG8gdGhlIG5leHQgdGljayBiZWZvcmUgY2xlYW5pbmcgdXAgaW4gY2FzZSB0aGVcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWN0dWFsbHkgYmVpbmcgcmUtYXR0YWNoZWQgc29tZXdoZXJlIGVsc2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgIC8vIHNhbWUgdGljayAoZGV0YWNoaW5nIGFuZCBhdHRhY2hpbmcgaXMgc3luY2hyb25vdXMsIHNvIGJ5XG4gICAgICAgICAgICAvLyBkZWZlcnJpbmcgdG8gdGhlIG5leHQgdGljayB3ZSdsbCBiZSBhYmxlIHRvIGtub3cgaWYgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHdhcyByZS1hdHRhY2hlZCBvciBub3QgaW4gb3JkZXIgdG8gY2xlYW4gdXAgb3Igbm90KS4gTm90ZSB0aGF0XG4gICAgICAgICAgICAvLyBhcHBlbmRDaGlsZCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFuIGVsZW1lbnQgdG8gYW5vdGhlciBwYXJlbnRcbiAgICAgICAgICAgIC8vIGVsZW1lbnQsIGluIHdoaWNoIGNhc2UgY29ubmVjdGVkQ2FsbGJhY2sgYW5kIGRpc2Nvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAvLyBib3RoIGdldCBjYWxsZWQsIGFuZCBpbiB3aGljaCBjYXNlIHdlIGRvbid0IG5lY2Vzc2FyaWx5IHdhbnQgdG9cbiAgICAgICAgICAgIC8vIGNsZWFuIHVwLiBJZiB0aGUgZWxlbWVudCBnZXRzIHJlLWF0dGFjaGVkIGJlZm9yZSB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGdldHMgbW92ZWQpLCB0aGVuIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlXG4gICAgICAgICAgICAvLyBzdHVmZiB0aGF0IHdvdWxkIGJlIGNsZWFuZWQgdXAgYnkgYW4gZXh0ZW5kaW5nIGNsYXNzJyBkZWluaXRcbiAgICAgICAgICAgIC8vIG1ldGhvZCBieSBub3QgcnVubmluZyB0aGUgZm9sbG93aW5nIHRoaXMuZGVpbml0KCkgY2FsbC5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4geyAvLyBkZWZlcnIgdG8gdGhlIG5leHQgdGljay5cblxuICAgICAgICAgICAgICAgIC8vIEFzIG1lbnRpb25lZCBpbiB0aGUgcHJldmlvdXMgY29tbWVudCwgaWYgdGhlIGVsZW1lbnQgd2FzIG5vdFxuICAgICAgICAgICAgICAgIC8vIHJlLWF0dGFjaGVkIGluIHRoZSBsYXN0IHRpY2sgKGZvciBleGFtcGxlLCBpdCB3YXMgbW92ZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGVsZW1lbnQpLCB0aGVuIGNsZWFuIHVwLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYXR0YWNoZWQgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWluaXQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy9hc3luYyBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIC8vaWYgKHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKSBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpXG4gICAgICAgICAgICAvL3RoaXMuX2F0dGFjaGVkID0gZmFsc2VcblxuICAgICAgICAgICAgLy8vLyBEZWZlcnIgdG8gdGhlIG5leHQgdGljayBiZWZvcmUgY2xlYW5pbmcgdXAgaW4gY2FzZSB0aGVcbiAgICAgICAgICAgIC8vLy8gZWxlbWVudCBpcyBhY3R1YWxseSBiZWluZyByZS1hdHRhY2hlZCBzb21ld2hlcmUgZWxzZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgLy8vLyBzYW1lIHRpY2sgKGRldGFjaGluZyBhbmQgYXR0YWNoaW5nIGlzIHN5bmNocm9ub3VzLCBzbyBieVxuICAgICAgICAgICAgLy8vLyBkZWZlcnJpbmcgdG8gdGhlIG5leHQgdGljayB3ZSdsbCBiZSBhYmxlIHRvIGtub3cgaWYgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vLy8gd2FzIHJlLWF0dGFjaGVkIG9yIG5vdCBpbiBvcmRlciB0byBjbGVhbiB1cCBvciBub3QpLiBOb3RlIHRoYXRcbiAgICAgICAgICAgIC8vLy8gYXBwZW5kQ2hpbGQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50XG4gICAgICAgICAgICAvLy8vIGVsZW1lbnQsIGluIHdoaWNoIGNhc2UgY29ubmVjdGVkQ2FsbGJhY2sgYW5kIGRpc2Nvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAvLy8vIGJvdGggZ2V0IGNhbGxlZCwgYW5kIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3QgbmVjZXNzYXJpbHkgd2FudCB0b1xuICAgICAgICAgICAgLy8vLyBjbGVhbiB1cC4gSWYgdGhlIGVsZW1lbnQgZ2V0cyByZS1hdHRhY2hlZCBiZWZvcmUgdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgLy8vLyAoZm9yIGV4YW1wbGUsIGdldHMgbW92ZWQpLCB0aGVuIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlXG4gICAgICAgICAgICAvLy8vIHN0dWZmIHRoYXQgd291bGQgYmUgY2xlYW5lZCB1cCBieSBhbiBleHRlbmRpbmcgY2xhc3MnIGRlaW5pdFxuICAgICAgICAgICAgLy8vLyBtZXRob2QgYnkgbm90IHJ1bm5pbmcgdGhlIGZvbGxvd2luZyB0aGlzLmRlaW5pdCgpIGNhbGwuXG4gICAgICAgICAgICAvL2F3YWl0IFByb21pc2UucmVzb2x2ZSgpIC8vIGRlZmVyciB0byB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICAgICAgICAvLy8vIEFzIG1lbnRpb25lZCBpbiB0aGUgcHJldmlvdXMgY29tbWVudCwgaWYgdGhlIGVsZW1lbnQgd2FzIG5vdFxuICAgICAgICAgICAgLy8vLyByZS1hdHRhY2hlZCBpbiB0aGUgbGFzdCB0aWNrIChmb3IgZXhhbXBsZSwgaXQgd2FzIG1vdmVkIHRvXG4gICAgICAgICAgICAvLy8vIGFub3RoZXIgZWxlbWVudCksIHRoZW4gY2xlYW4gdXAuXG4gICAgICAgICAgICAvL2lmICghdGhpcy5fYXR0YWNoZWQgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAvL3RoaXMuZGVpbml0KClcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAvL31cbiAgICAgICAgZGV0YWNoZWRDYWxsYmFjaygpIHsgdGhpcy5kaXNjb25uZWN0ZWRDYWxsYmFjaygpIH0gLy8gYmFjay1jb21wYXRcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gYnkgZXh0ZW5kaW5nIGNsYXNzZXMsIGl0IHNob3VsZCByZXR1cm5cbiAgICAgICAgICogSlNTLWNvbXBhdGlibGUgc3R5bGluZy4gU2VlIGh0dHA6Ly9naXRodWIuY29tL2Nzc2luanMvanNzIGZvclxuICAgICAgICAgKiBkb2N1bWVudGF0aW9uLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0eWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBpcyBjYWxsZWQgZXhhY3RseSBvbmNlLCB0aGUgZmlyc3QgdGltZSB0aGlzIGVsZW1lbnQgaXNcbiAgICAgICAgICogY29ubmVjdGVkIGludG8gdGhlIERPTS4gV2hlbiBhbiBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCB0aGVuXG4gICAgICAgICAqIGNvbm5lY3RlZCByaWdodCBhd2F5IHdpdGhpbiB0aGUgc2FtZSBzeW5jaHJvbm91cyB0aWNrLCBpbml0KCkgaXMgbm90XG4gICAgICAgICAqIGZpcmVkIGFnYWluLiBIb3dldmVyLCBpZiBhbiBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgICAgICogdGljayBjb21wbGV0ZXMgYmVmb3JlIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCBhZ2FpbiwgdGhlbiBkZWluaXQoKVxuICAgICAgICAgKiB3aWxsIGJlIGNhbGxlZCAoaS5lLiB0aGUgZWxlbWVudCB3YXMgbm90IHNpbXBseSBtb3ZlZCB0byBhIG5ld1xuICAgICAgICAgKiBsb2NhdGlvbiwgaXQgd2FzIGFjdHVhbGx5IHJlbW92ZWQpLCB0aGVuIHRoZSBuZXh0IHRpbWUgdGhhdCB0aGVcbiAgICAgICAgICogZWxlbWVudCBpcyBjb25uZWN0ZWQgYmFjayBpbnRvIERPTSBpbml0KCkgd2lsbCBiZSBjYWxsZWQgYWdhaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gY29ubmVjdGVkQ2FsbGJhY2sgYW5kIGRpc2Nvbm5lY3RlZENhbGxiYWNrOlxuICAgICAgICAgKiBjb25uZWN0ZWRDYWxsYmFjayBpcyBndWFyYW50ZWVkIHRvIGFsd2F5cyBmaXJlIGV2ZW4gaWYgdGhlIGVsZW1ldFxuICAgICAgICAgKiB3YXMgcHJldmlvdXNseSBkaXNjb25uZWN0ZWQgaW4gdGhlIHNhbWUgc3luY2hyb25vdXMgdGljay5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIC4uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBleHRlbmQgdGhpcyB0byBhZGQgc3VjaCBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0eWxlKSB0aGlzLl9zdHlsZSA9IHRoaXMuX2NyZWF0ZVN0eWxlcygpXG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbnkgbm9kZXMgdGhhdCBtYXkgaGF2ZSBiZWVuIGNvbm5lY3RlZCBiZWZvcmUgYHRoaXNgIG5vZGVcbiAgICAgICAgICAgIC8vIHdhcyBjcmVhdGVkIChmLmUuIGNoaWxkIG5vZGVzIHRoYXQgd2VyZSBjb25uZWN0ZWQgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRzIHdlcmUgcmVnaXN0ZXJlZCBhbmQgd2hpY2ggd291bGQgdGhlcmVmb3JlIG5vdCBiZVxuICAgICAgICAgICAgLy8gZGV0ZWN0ZWQgYnkgdGhlIGZvbGxvd2luZyBNdXRhdGlvbk9ic2VydmVyKS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hpbGRPYnNlcnZlcikge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGltZW91dCBuZWVkZWQgaW4gY2FzZSB0aGUgQ3VzdG9tIEVsZW1lbnQgY2xhc3NlcyBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXJlZCBhZnRlciB0aGUgZWxlbWVudHMgYXJlIGFscmVhZHkgZGVmaW5lZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gRE9NIGJ1dCBub3QgeWV0IHVwZ3JhZGVkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIGBub2RlYCBhcmdcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgYmUgYSBgPG1vdG9yLW5vZGU+YCBidXQgaWYgaXQgaXNuJ3QgdXBncmFkZWQgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyBpdHMgQVBJIHdvbid0IGJlIGF2YWlsYWJsZSB0byB0aGUgbG9naWMgaW5zaWRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZENvbm5lY3RlZENhbGxiYWNrLiBUaGUgcmVhc29uIHRoaXMgaGFwcGVucyBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHBhcmVudHMgYXJlIHVwZ3JhZGVkIGZpcnN0IGFuZCB0aGVpclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFja3MgZmlyZWQgYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyB1cGdyYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBGSVhNRSBQRVJGT1JNQU5DRTogVGhpcyBjYXVzZXMgYSBwb3NzaWJseSBcImJ1Z2d5XCIgZWZmZWN0IHdoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIGluIGEgdHJlZSB3aWxsIGFwcGVhciBpbiBpbnRlcnZhbHMgb2YgNVxuICAgICAgICAgICAgICAgICAgICAvLyBtaWxsaXNlY29uZHMuIFdlIHdhbnQgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWQgaW5zdGFudGx5LFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZmlyc3QgZnJhbWUgdGhhdCB0aGV5IGFyZSBwcmVzZW50IGluIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAvLyBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSG93IGNhbiB3ZSBmaXggdGhpcz8gTWF5YmUgd2UgY2FuIHN3aXRjaCB0byBhIFByb21pc2UgbWljcm90YXNrLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGw9Y2hpbGRyZW4ubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRDb25uZWN0ZWRDYWxsYmFjayhjaGlsZHJlbltpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgNSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZE9ic2VydmVyID0gb2JzZXJ2ZUNoaWxkcmVuKHRoaXMsIHRoaXMuY2hpbGRDb25uZWN0ZWRDYWxsYmFjaywgdGhpcy5jaGlsZERpc2Nvbm5lY3RlZENhbGxiYWNrKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXJlIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGluIGNhc2Ugc29tZSBhdHRyaWJ1dGVzIGhhdmVcbiAgICAgICAgICAgIC8vIGV4aXN0ZWQgYmVmb3JlIHRoZSBjdXN0b20gZWxlbWVudCB3YXMgdXBncmFkZWQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxBdHRyaWJ1dGVDaGFuZ2UgJiYgdGhpcy5oYXNBdHRyaWJ1dGVzKCkpIHtcblxuICAgICAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50I2F0dHJpYnV0ZXMgaXMgYSBOYW1lZE5vZGVNYXAgd2hpY2ggaXMgbm90IGFuXG4gICAgICAgICAgICAgICAgLy8gaXRlcmFibGUsIHNvIHdlIHVzZSBBcnJheS5mcm9tLiBTZWU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzIzNFxuICAgICAgICAgICAgICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsPWF0dHJpYnV0ZXMubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0cmlidXRlc1tpXS5uYW1lLCBudWxsLCBhdHRyaWJ1dGVzW2ldLnZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyAtLS0gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJywgdHlwZW9mIGFyZ3NbMl0pXG4gICAgICAgICAgICBpZiAoc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soLi4uYXJncylcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxBdHRyaWJ1dGVDaGFuZ2UgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgcmVjaXByb2NhbCBvZiBpbml0KCkuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYW4gZWxlbWVudFxuICAgICAgICAgKiBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgYnV0IG5vdCByZS1jb25uZWN0ZWQgd2l0aGluIHRoZSBzYW1lIHRpY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZWFzb24gdGhhdCBpbml0KCkgYW5kIGRlaW5pdCgpIGV4aXN0IGlzIHNvIHRoYXQgaWYgYW4gZWxlbWVudCBpc1xuICAgICAgICAgKiBtb3ZlZCBmcm9tIG9uZSBwbGFjZSB0byBhbm90aGVyIHdpdGhpbiB0aGUgc2FtZSBzeW5jaHJvbm91cyB0aWNrLFxuICAgICAgICAgKiB0aGF0IGRlaW5pdCBhbmQgaW5pdCBsb2dpYyB3aWxsIG5vdCBmaXJlIHVubmVjZXNzYXJpbHkuIElmIGxvZ2ljIGlzXG4gICAgICAgICAqIG5lZWRlZCBpbiB0aGF0IGNhc2UsIHRoZW4gY29ubmVjdGVkQ2FsbGJhY2sgYW5kIGRpc2Nvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAqIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWluaXQoKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIG11Y2ggYXQgdGhlIG1vbWVudCwgYnV0IGV4dGVuZGluZyBjbGFzc2VzIGNhbiBleHRlbmRcbiAgICAgICAgICAgIC8vIHRoaXMgdG8gYWRkIGRlaW50aWFsaXphdGlvbiBsb2dpYy5cblxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3NDYWNoZS5zZXQoZWxlbWVudENsYXNzLCBXZWJDb21wb25lbnQpXG4gICAgcmV0dXJuIFdlYkNvbXBvbmVudFxufVxuIl0sIm5hbWVzIjpbInN1cGVyIiwidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsU0FBUyxlQUFlLFFBQVEsaUJBQWlCO0FBQ2pELE9BQU8sR0FBRyxNQUFNLFlBQVk7Ozs7O0FBSzVCLElBQUksT0FBTyxNQUFNLENBQUMsV0FBVyxJQUFJLFVBQVUsRUFBRTtJQUN6QyxNQUFNLFlBQVksR0FBRyxTQUFTLFdBQVcsRUFBRSxFQUFFO0lBQzdDLFlBQVksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTO0lBQ3JELE1BQU0sQ0FBQyxXQUFXLEdBQUcsWUFBWTtDQUNwQzs7QUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUc7O0FBRTFCLFNBQVMsdUJBQXVCLENBQUMsV0FBVyxFQUFFO0lBQzFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBQSxPQUFPLEtBQUssRUFBQTtJQUM5QixJQUFJLFdBQVcsS0FBSyxXQUFXLEVBQUUsRUFBQSxPQUFPLElBQUksRUFBQTtTQUN2QyxFQUFBLE9BQU8sdUJBQXVCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxFQUFBO0NBQzVIOzs7Ozs7Ozs7Ozs7OztBQWNEO0FBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUU7SUFD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