
import styles from './node-style'
import Node from '../core/Node'
import Transformable from '../core/Transformable'
import Sizeable from '../core/Sizeable'
import MotorHTMLBase, {initMotorHTMLBase, proxyGettersSetters} from './base'

initMotorHTMLBase()

var MotorHTMLNode = (function (MotorHTMLBase) {
    function MotorHTMLNode () {
        MotorHTMLBase.apply(this, arguments);
    }

    if ( MotorHTMLBase ) MotorHTMLNode.__proto__ = MotorHTMLBase;
    MotorHTMLNode.prototype = Object.create( MotorHTMLBase && MotorHTMLBase.prototype );
    MotorHTMLNode.prototype.constructor = MotorHTMLNode;

    MotorHTMLNode.prototype.getStyles = function getStyles () {
        return styles
    };

    // this is called by DeclarativeBase#init, which is called by
    // WebComponent#connectedCallback, at which point this element has a
    // parentNode.
    // @override
    MotorHTMLNode.prototype._makeImperativeCounterpart = function _makeImperativeCounterpart () {
        return new Node({
            _motorHtmlCounterpart: this
        })
    };

    MotorHTMLNode.prototype.attributeChangedCallback = function attributeChangedCallback () {
        var this$1 = this;
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        MotorHTMLBase.prototype.attributeChangedCallback.apply(this, args)

        // TODO PERFORMANCE: we could possibly not stack a promise every
        // attribute change, and just cache the latest value to set it when the
        // imperativeCounterpart is ready.
        this._imperativeCounterpartPromise.then(function () {
            (ref = this$1)._updateNodeProperty.apply(ref, args)
            var ref;
        })
    };
    //async attributeChangedCallback(...args) {
        //super.attributeChangedCallback(...args)

        //// TODO PERFORMANCE: we could possibly not stack a promise every
        //// attribute change, and just cache the latest value to set it when the
        //// imperativeCounterpart is ready.
        //await this._imperativeCounterpartPromise
        //this._updateNodeProperty(...args)
    //}

    MotorHTMLNode.prototype._updateNodeProperty = function _updateNodeProperty (attribute, oldValue, newValue) {
        // attributes on our HTML elements are the same name as those on
        // the Node class (the setters).
        if (newValue !== oldValue) {
            if (attribute.match(/opacity/i))
                { this.imperativeCounterpart[attribute] = window.parseFloat(newValue) }
            else if (attribute.match(/sizeMode/i))
                { this.imperativeCounterpart[attribute] = parseStringArray(newValue) }
            else if (
                attribute.match(/rotation/i)
                || attribute.match(/scale/i)
                || attribute.match(/position/i)
                || attribute.match(/absoluteSize/i)
                || attribute.match(/proportionalSize/i)
                || attribute.match(/align/i)
                || attribute.match(/mountPoint/i)
                || attribute.match(/origin/i)
                || attribute.match(/skew/i)
            ) {
                this.imperativeCounterpart[attribute] = parseNumberArray(newValue)
            }
            else {
                /* nothing, ignore other attributes */
            }
        }
    };

    return MotorHTMLNode;
}(MotorHTMLBase));

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.
proxyGettersSetters(Transformable, MotorHTMLNode)
proxyGettersSetters(Sizeable, MotorHTMLNode)

function parseNumberArray(str) {
    checkIsNumberArrayString(str)
    const numbers = str.trim().split(/(?:\s*,\s*)|(?:\s+)/g)
    const length = numbers.length
    if (length > 0) { numbers[0] = window.parseFloat(numbers[0]) }
    if (length > 1) { numbers[1] = window.parseFloat(numbers[1]) }
    if (length > 2) { numbers[2] = window.parseFloat(numbers[2]) }
    return numbers
}

function parseStringArray(str) {
    checkIsSizeArrayString(str)
    const strings = str.trim().toLowerCase().split(/(?:\s*,\s*)|(?:\s+)/g)
    const length = strings.length
    if (length > 0) { strings[0] = strings[0] }
    if (length > 1) { strings[1] = strings[1] }
    if (length > 2) { strings[2] = strings[2] }
    return strings
}

function checkIsNumberArrayString(str) {
    if (!str.match(/^\s*(((\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))\s*,){0,2}(\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))))|((\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))\s){0,2}(\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+))))))\s*$/g))
        { throw new Error(("Attribute must be a comma- or space-separated sequence of up to three numbers, for example \"1 2.5 3\". Yours was \"" + str + "\".")) }
}

function checkIsSizeArrayString(str) {
    if (!str.match(/^\s*(((\s*([a-zA-Z]+)\s*,){0,2}(\s*([a-zA-Z]+)))|((\s*([a-zA-Z]+)\s*){1,3}))\s*$/g))
        { throw new Error(("Attribute must be a comma- or space-separated sequence of up to three strings, for example \"absolute absolute\". Yours was \"" + str + "\".")) }
}

import 'document-register-element'
MotorHTMLNode = document.registerElement('motor-node', MotorHTMLNode)

export {MotorHTMLNode as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2h0bWwvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9ub2RlLXN0eWxlJ1xuaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlJ1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnLi4vY29yZS9UcmFuc2Zvcm1hYmxlJ1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4uL2NvcmUvU2l6ZWFibGUnXG5pbXBvcnQgTW90b3JIVE1MQmFzZSwge2luaXRNb3RvckhUTUxCYXNlLCBwcm94eUdldHRlcnNTZXR0ZXJzfSBmcm9tICcuL2Jhc2UnXG5cbmluaXRNb3RvckhUTUxCYXNlKClcblxuY2xhc3MgTW90b3JIVE1MTm9kZSBleHRlbmRzIE1vdG9ySFRNTEJhc2Uge1xuXG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBjYWxsZWQgYnkgRGVjbGFyYXRpdmVCYXNlI2luaXQsIHdoaWNoIGlzIGNhbGxlZCBieVxuICAgIC8vIFdlYkNvbXBvbmVudCNjb25uZWN0ZWRDYWxsYmFjaywgYXQgd2hpY2ggcG9pbnQgdGhpcyBlbGVtZW50IGhhcyBhXG4gICAgLy8gcGFyZW50Tm9kZS5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBfbWFrZUltcGVyYXRpdmVDb3VudGVycGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHtcbiAgICAgICAgICAgIF9tb3Rvckh0bWxDb3VudGVycGFydDogdGhpc1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayguLi5hcmdzKVxuXG4gICAgICAgIC8vIFRPRE8gUEVSRk9STUFOQ0U6IHdlIGNvdWxkIHBvc3NpYmx5IG5vdCBzdGFjayBhIHByb21pc2UgZXZlcnlcbiAgICAgICAgLy8gYXR0cmlidXRlIGNoYW5nZSwgYW5kIGp1c3QgY2FjaGUgdGhlIGxhdGVzdCB2YWx1ZSB0byBzZXQgaXQgd2hlbiB0aGVcbiAgICAgICAgLy8gaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0IGlzIHJlYWR5LlxuICAgICAgICB0aGlzLl9pbXBlcmF0aXZlQ291bnRlcnBhcnRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVByb3BlcnR5KC4uLmFyZ3MpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8vYXN5bmMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgLy9zdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soLi4uYXJncylcblxuICAgICAgICAvLy8vIFRPRE8gUEVSRk9STUFOQ0U6IHdlIGNvdWxkIHBvc3NpYmx5IG5vdCBzdGFjayBhIHByb21pc2UgZXZlcnlcbiAgICAgICAgLy8vLyBhdHRyaWJ1dGUgY2hhbmdlLCBhbmQganVzdCBjYWNoZSB0aGUgbGF0ZXN0IHZhbHVlIHRvIHNldCBpdCB3aGVuIHRoZVxuICAgICAgICAvLy8vIGltcGVyYXRpdmVDb3VudGVycGFydCBpcyByZWFkeS5cbiAgICAgICAgLy9hd2FpdCB0aGlzLl9pbXBlcmF0aXZlQ291bnRlcnBhcnRQcm9taXNlXG4gICAgICAgIC8vdGhpcy5fdXBkYXRlTm9kZVByb3BlcnR5KC4uLmFyZ3MpXG4gICAgLy99XG5cbiAgICBfdXBkYXRlTm9kZVByb3BlcnR5KGF0dHJpYnV0ZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgb24gb3VyIEhUTUwgZWxlbWVudHMgYXJlIHRoZSBzYW1lIG5hbWUgYXMgdGhvc2Ugb25cbiAgICAgICAgLy8gdGhlIE5vZGUgY2xhc3MgKHRoZSBzZXR0ZXJzKS5cbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5tYXRjaCgvb3BhY2l0eS9pKSlcbiAgICAgICAgICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydFthdHRyaWJ1dGVdID0gd2luZG93LnBhcnNlRmxvYXQobmV3VmFsdWUpXG4gICAgICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUubWF0Y2goL3NpemVNb2RlL2kpKVxuICAgICAgICAgICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0W2F0dHJpYnV0ZV0gPSBwYXJzZVN0cmluZ0FycmF5KG5ld1ZhbHVlKVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm1hdGNoKC9yb3RhdGlvbi9pKVxuICAgICAgICAgICAgICAgIHx8IGF0dHJpYnV0ZS5tYXRjaCgvc2NhbGUvaSlcbiAgICAgICAgICAgICAgICB8fCBhdHRyaWJ1dGUubWF0Y2goL3Bvc2l0aW9uL2kpXG4gICAgICAgICAgICAgICAgfHwgYXR0cmlidXRlLm1hdGNoKC9hYnNvbHV0ZVNpemUvaSlcbiAgICAgICAgICAgICAgICB8fCBhdHRyaWJ1dGUubWF0Y2goL3Byb3BvcnRpb25hbFNpemUvaSlcbiAgICAgICAgICAgICAgICB8fCBhdHRyaWJ1dGUubWF0Y2goL2FsaWduL2kpXG4gICAgICAgICAgICAgICAgfHwgYXR0cmlidXRlLm1hdGNoKC9tb3VudFBvaW50L2kpXG4gICAgICAgICAgICAgICAgfHwgYXR0cmlidXRlLm1hdGNoKC9vcmlnaW4vaSlcbiAgICAgICAgICAgICAgICB8fCBhdHRyaWJ1dGUubWF0Y2goL3NrZXcvaSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0W2F0dHJpYnV0ZV0gPSBwYXJzZU51bWJlckFycmF5KG5ld1ZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogbm90aGluZywgaWdub3JlIG90aGVyIGF0dHJpYnV0ZXMgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVGhpcyBhc3NvY2lhdGVzIHRoZSBUcmFuc2Zvcm1hYmxlIGdldHRlcnMvc2V0dGVycyB3aXRoIHRoZSBIVE1MLUFQSSBjbGFzc2VzLFxuLy8gc28gdGhhdCB0aGUgc2FtZSBnZXR0ZXJzL3NldHRlcnMgY2FuIGJlIGNhbGxlZCBmcm9tIEhUTUwgc2lkZSBvZiB0aGUgQVBJLlxucHJveHlHZXR0ZXJzU2V0dGVycyhUcmFuc2Zvcm1hYmxlLCBNb3RvckhUTUxOb2RlKVxucHJveHlHZXR0ZXJzU2V0dGVycyhTaXplYWJsZSwgTW90b3JIVE1MTm9kZSlcblxuZnVuY3Rpb24gcGFyc2VOdW1iZXJBcnJheShzdHIpIHtcbiAgICBjaGVja0lzTnVtYmVyQXJyYXlTdHJpbmcoc3RyKVxuICAgIGNvbnN0IG51bWJlcnMgPSBzdHIudHJpbSgpLnNwbGl0KC8oPzpcXHMqLFxccyopfCg/OlxccyspL2cpXG4gICAgY29uc3QgbGVuZ3RoID0gbnVtYmVycy5sZW5ndGhcbiAgICBpZiAobGVuZ3RoID4gMCkgbnVtYmVyc1swXSA9IHdpbmRvdy5wYXJzZUZsb2F0KG51bWJlcnNbMF0pXG4gICAgaWYgKGxlbmd0aCA+IDEpIG51bWJlcnNbMV0gPSB3aW5kb3cucGFyc2VGbG9hdChudW1iZXJzWzFdKVxuICAgIGlmIChsZW5ndGggPiAyKSBudW1iZXJzWzJdID0gd2luZG93LnBhcnNlRmxvYXQobnVtYmVyc1syXSlcbiAgICByZXR1cm4gbnVtYmVyc1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZ0FycmF5KHN0cikge1xuICAgIGNoZWNrSXNTaXplQXJyYXlTdHJpbmcoc3RyKVxuICAgIGNvbnN0IHN0cmluZ3MgPSBzdHIudHJpbSgpLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyg/OlxccyosXFxzKil8KD86XFxzKykvZylcbiAgICBjb25zdCBsZW5ndGggPSBzdHJpbmdzLmxlbmd0aFxuICAgIGlmIChsZW5ndGggPiAwKSBzdHJpbmdzWzBdID0gc3RyaW5nc1swXVxuICAgIGlmIChsZW5ndGggPiAxKSBzdHJpbmdzWzFdID0gc3RyaW5nc1sxXVxuICAgIGlmIChsZW5ndGggPiAyKSBzdHJpbmdzWzJdID0gc3RyaW5nc1syXVxuICAgIHJldHVybiBzdHJpbmdzXG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNOdW1iZXJBcnJheVN0cmluZyhzdHIpIHtcbiAgICBpZiAoIXN0ci5tYXRjaCgvXlxccyooKChcXHMqKC18XFwrKT8oKFxcLlxcZCspfChcXGQrXFwuXFxkKyl8KFxcZCspfChcXGQrKFxcLlxcZCspP2UoLXxcXCspPyhcXGQrKSkpXFxzKiwpezAsMn0oXFxzKigtfFxcKyk/KChcXC5cXGQrKXwoXFxkK1xcLlxcZCspfChcXGQrKXwoXFxkKyhcXC5cXGQrKT9lKC18XFwrKT8oXFxkKykpKSkpfCgoXFxzKigtfFxcKyk/KChcXC5cXGQrKXwoXFxkK1xcLlxcZCspfChcXGQrKXwoXFxkKyhcXC5cXGQrKT9lKC18XFwrKT8oXFxkKykpKVxccyl7MCwyfShcXHMqKC18XFwrKT8oKFxcLlxcZCspfChcXGQrXFwuXFxkKyl8KFxcZCspfChcXGQrKFxcLlxcZCspP2UoLXxcXCspPyhcXGQrKSkpKSkpXFxzKiQvZykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIG11c3QgYmUgYSBjb21tYS0gb3Igc3BhY2Utc2VwYXJhdGVkIHNlcXVlbmNlIG9mIHVwIHRvIHRocmVlIG51bWJlcnMsIGZvciBleGFtcGxlIFwiMSAyLjUgM1wiLiBZb3VycyB3YXMgXCIke3N0cn1cIi5gKVxufVxuXG5mdW5jdGlvbiBjaGVja0lzU2l6ZUFycmF5U3RyaW5nKHN0cikge1xuICAgIGlmICghc3RyLm1hdGNoKC9eXFxzKigoKFxccyooW2EtekEtWl0rKVxccyosKXswLDJ9KFxccyooW2EtekEtWl0rKSkpfCgoXFxzKihbYS16QS1aXSspXFxzKil7MSwzfSkpXFxzKiQvZykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIG11c3QgYmUgYSBjb21tYS0gb3Igc3BhY2Utc2VwYXJhdGVkIHNlcXVlbmNlIG9mIHVwIHRvIHRocmVlIHN0cmluZ3MsIGZvciBleGFtcGxlIFwiYWJzb2x1dGUgYWJzb2x1dGVcIi4gWW91cnMgd2FzIFwiJHtzdHJ9XCIuYClcbn1cblxuaW1wb3J0ICdkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50J1xuTW90b3JIVE1MTm9kZSA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnbW90b3Itbm9kZScsIE1vdG9ySFRNTE5vZGUpXG5cbmV4cG9ydCB7TW90b3JIVE1MTm9kZSBhcyBkZWZhdWx0fVxuIl0sIm5hbWVzIjpbInN1cGVyIiwidGhpcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxPQUFPLE1BQU0sTUFBTSxjQUFjO0FBQ2pDLE9BQU8sSUFBSSxNQUFNLGNBQWM7QUFDL0IsT0FBTyxhQUFhLE1BQU0sdUJBQXVCO0FBQ2pELE9BQU8sUUFBUSxNQUFNLGtCQUFrQjtBQUN2QyxPQUFPLGFBQWEsR0FBRyxpQkFBaUIsRUFBRSxtQkFBbUIsT0FBTyxRQUFROztBQUU1RSxpQkFBaUIsRUFBRTs7QUFFbkIsSUFBTSxhQUFhLEdBQXNCO0lBQUM7Ozs7Ozs7O0lBQUEsQUFFdEMsd0JBQUEsU0FBUyxzQkFBQSxHQUFHO1FBQ1IsT0FBTyxNQUFNO0tBQ2hCLENBQUE7Ozs7OztJQU1ELHdCQUFBLDBCQUEwQix1Q0FBQSxHQUFHO1FBQ3pCLE9BQU8sSUFBSSxJQUFJLENBQUM7WUFDWixxQkFBcUIsRUFBRSxJQUFJO1NBQzlCLENBQUM7S0FDTCxDQUFBOztJQUVELHdCQUFBLHdCQUF3QixxQ0FBQSxDQUFDLEFBQU8sRUFBRSxDQUFDOzs7O0FBQUE7UUFDL0JBLHVCQUFLLENBQUMsd0JBQXdCLE1BQUEsQ0FBQyxNQUFBLEFBQUcsSUFBSSxDQUFDOzs7OztRQUt2QyxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLFNBQUEsR0FBRyxBQUFHO1lBQzFDLE9BQUFDLE1BQUksQ0FBQSxDQUFDLG1CQUFtQixNQUFBLENBQUMsS0FBQSxBQUFHLElBQUksQ0FBQztvQkFBQTtTQUNwQyxDQUFDO0tBQ0wsQ0FBQTs7Ozs7Ozs7Ozs7SUFXRCx3QkFBQSxtQkFBbUIsZ0NBQUEsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTs7O1FBRy9DLElBQUksUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUN2QixJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDO2dCQUMzQixFQUFBLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFBO2lCQUNsRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDO2dCQUNqQyxFQUFBLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsRUFBQTtpQkFDakU7Z0JBQ0QsU0FBUyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7bUJBQ3pCLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO21CQUN6QixTQUFTLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQzttQkFDNUIsU0FBUyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUM7bUJBQ2hDLFNBQVMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUM7bUJBQ3BDLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO21CQUN6QixTQUFTLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQzttQkFDOUIsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7bUJBQzFCLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2NBQzdCO2dCQUNFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7YUFDckU7aUJBQ0k7O2FBRUo7U0FDSjtLQUNKLENBQUEsQUFDSjs7O0VBOUQyQixhQThEM0IsR0FBQTs7OztBQUlELG1CQUFtQixDQUFDLGFBQWEsRUFBRSxhQUFhLENBQUM7QUFDakQsbUJBQW1CLENBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQzs7QUFFNUMsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUU7SUFDM0Isd0JBQXdCLENBQUMsR0FBRyxDQUFDO0lBQzdCLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUM7SUFDeEQsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU07SUFDN0IsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUE7SUFDMUQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUE7SUFDMUQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUE7SUFDMUQsT0FBTyxPQUFPO0NBQ2pCOztBQUVELFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFO0lBQzNCLHNCQUFzQixDQUFDLEdBQUcsQ0FBQztJQUMzQixNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDO0lBQ3RFLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNO0lBQzdCLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxFQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUE7SUFDdkMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBQTtJQUN2QyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFBO0lBQ3ZDLE9BQU8sT0FBTztDQUNqQjs7QUFFRCxTQUFTLHdCQUF3QixDQUFDLEdBQUcsRUFBRTtJQUNuQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxzU0FBc1MsQ0FBQztRQUNsVCxFQUFBLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQSxzSEFBa0gsR0FBRSxHQUFHLFFBQUcsQ0FBQyxDQUFDLEVBQUE7Q0FDbko7O0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUU7SUFDakMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsbUZBQW1GLENBQUM7UUFDL0YsRUFBQSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUEsZ0lBQTRILEdBQUUsR0FBRyxRQUFHLENBQUMsQ0FBQyxFQUFBO0NBQzdKOztBQUVELE9BQU8sMkJBQTJCO0FBQ2xDLGFBQWEsR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLFlBQVksRUFBRSxhQUFhLENBQUM7O0FBRXJFLFFBQVEsYUFBYSxJQUFJLE9BQU8sQ0FBQzsifQ==