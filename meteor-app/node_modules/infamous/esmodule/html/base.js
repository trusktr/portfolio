/* global HTMLSlotElement */

import WebComponent from './web-component'
import MotorHTMLNode from './node'
import { observeChildren, /*getShadowRootVersion,*/ hasShadowDomV0,
    hasShadowDomV1, getAncestorShadowRoot } from '../core/Utility'

var DeclarativeBase

// We use this to Override HTMLElement.prototype.attachShadow in v1, and
// HTMLElement.prototype.createShadowRoot in v0, so that we can make the
// connection between parent and child on the iperative side when the HTML side
// is using shadow roots.
const observers = new WeakMap
function hijack(original) {
    return function() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // In v0, shadow roots can be replaced, but in v1 calling attachShadow
        // on an element that already has a root throws. So, we can set this to
        // true, and if the try-catch passes then we know we have a v0 root and
        // that the root was just replaced.
        const oldRoot = this.shadowRoot
        let root = null
        try {
            root = original.call.apply(original, [ this ].concat( args ))
        }
        catch (e) { throw e }
        if (this instanceof DeclarativeBase) {
            this._hasShadowRoot = true
            if (oldRoot) {
                onV0ShadowRootReplaced.call(this, oldRoot)
            }
            const observer = observeChildren(root, shadowRootChildAdded.bind(this), shadowRootChildRemoved.bind(this))
            observers.set(root, observer)

            var ref = this;
            var children = ref.children;
            for (let l=children.length, i=0; i<l; i+=1) {
                if (!(children[i] instanceof DeclarativeBase)) { continue }
                children[i]._isPossiblyDistributed = true
            }
        }
        return root
    }
}

function shadowRootChildAdded(child) {

    // NOTE Logic here is similar to childConnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.addChild(child.imperativeCounterpart)
    }
    else if (
        hasShadowDomV0
        && child instanceof HTMLContentElement
    ) {
        // observe <content> elements.
    }
    else if (
        hasShadowDomV1
        && child instanceof HTMLSlotElement
    ) {
        child.addEventListener('slotchange', this)
        this._handleDistributedChildren(child)
    }
}

function shadowRootChildRemoved(child) {

    // NOTE Logic here is similar to childDisconnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.removeChild(child.imperativeCounterpart)
    }
    else if (
        hasShadowDomV0
        && child instanceof HTMLContentElement
    ) {
        // unobserve <content> element
    }
    else if (
        hasShadowDomV1
        && child instanceof HTMLSlotElement
    ) {
        child.removeEventListener('slotchange', this)
        this._handleDistributedChildren(child)
        this._slotElementsAssignedNodes.delete(child)
    }
}

function onV0ShadowRootReplaced(oldRoot) {
    var this$1 = this;

    observers.get(oldRoot).disconnect()
    observers.delete(oldRoot)
    var childNodes = oldRoot.childNodes;
    for (let l=childNodes.length, i=0; i<l; i+=1) {
        const child = childNodes[i]

        if (!(child instanceof DeclarativeBase)) { continue }

        // We should disconnect the imperative connection (f.e. so it is not
        // rendered in WebGL)
        this$1.imperativeCounterpart.removeChild(child.imperativeCounterpart, true)
    }
}

if (HTMLElement.prototype.createShadowRoot instanceof Function)
    { HTMLElement.prototype.createShadowRoot = hijack(HTMLElement.prototype.createShadowRoot) }
if (HTMLElement.prototype.attachShadow instanceof Function)
    { HTMLElement.prototype.attachShadow = hijack(HTMLElement.prototype.attachShadow) }

initMotorHTMLBase()
export function initMotorHTMLBase() {
    if (DeclarativeBase) { return }

    /**
     * @implements {EventListener}
     */
    DeclarativeBase = (function (superclass) {
        function DeclarativeBase () {
            superclass.apply(this, arguments);
        }

        if ( superclass ) DeclarativeBase.__proto__ = superclass;
        DeclarativeBase.prototype = Object.create( superclass && superclass.prototype );
        DeclarativeBase.prototype.constructor = DeclarativeBase;

        DeclarativeBase.prototype.createdCallback = function createdCallback () {
            var this$1 = this;

            superclass.prototype.createdCallback.call(this)

            this.imperativeCounterpart = null // to hold the imperative API Node instance.

            // true if this node has a shadow root (even if it is "closed", see
            // hijack function above). Once true always true because shadow
            // roots cannot be removed.
            this._hasShadowRoot = false

            // True when this node has a parent that has a shadow root. When
            // using the HTML API, Imperative API can look at this to determine
            // whether to render this node or not, in the case of WebGL.
            this._isPossiblyDistributed = false

            // A map of the slot elements that are children of this node and
            // their last-known assigned nodes. When a slotchange happens while
            // this node is in a shadow root and has a slot child, we can
            // detect what the difference is between the last known and the new
            // assignments, and notate the new distribution of child nodes. See
            // issue #40 for background on why we do this.
            this._slotElementsAssignedNodes = new WeakMap

            // If this node is distributed into a shadow tree, this will
            // reference the parent of the <slot> or <content> element.
            // Basically, this node will render as a child of that parent node
            // in the flat tree.
            this._shadowParent = null

            // If this element has a child <slot> or <content> element while in
            // a shadow root, then this will be a Set of the nodes distributed
            // into the <slot> or <content>, and those nodes render relatively
            // to this node in the flat tree. We instantiate this later, only
            // when/if needed.
            this._shadowChildren = null

            // We use Promise.resolve here to defer to the next microtask.
            // While we support Custom Elements v0, this is necessary because
            // the imperative Node counterpart will have already called the
            // `_associateImperativeNode` method on this element, causing the
            // next microtask's call to be a no-op. When this MotorHTML element
            // API is used instead of the Imperative counterpart, then the next
            // microtask's `_associateImperativeNode` call will not be a no-op.
            // When we drop support for v0 Custom Elements at some point, we
            // can rely on passing a constructor argument similarly to how we
            // do with motor/Node in order to detect that the constructor is
            // being called from the reciprocal API. See the constructor in
            // motor/Node.js to get see the idea.
            // TODO: renewable promise after unmount.
            this._imperativeCounterpartPromise = Promise.resolve()
                .then(function () { return this$1._associateImperativeNode(); })
            this.mountPromise = this._imperativeCounterpartPromise
                .then(function () { return this$1.imperativeCounterpart.mountPromise; })
        };

        /**
         * This method creates the association between this MotorHTMLNode instance
         * and the imperative Node instance.
         *
         * This method may get called by this.init, but can also be called by
         * the Node class if Node is used imperatively. See Node#constructor.
         *
         * @private
         *
         * @param {Object} imperativeCounterpart The imperative counterpart to
         * associate with this MotorHTML element. This parameter is only used in the
         * imperative API constructors, and this happens when using the imperative
         * form of infamous instead of the HTML interface to infamous. When the HTML
         * interface is used, this gets called first without an
         * imperativeCounterpart argument and the call to this in an imperative
         * constructor will be a noop. Basically, either this gets called first by a
         * MotorHTML element, or first by an imperative instance, depending on which
         * API is used first.
         */
        DeclarativeBase.prototype._associateImperativeNode = function _associateImperativeNode (imperativeCounterpart) {
            // if the association is made already, noop
            if (this.imperativeCounterpart) { return }

            // if called from an imperative-side class' constructor, associate
            // the passed instance.
            if (imperativeCounterpart) { this.imperativeCounterpart = imperativeCounterpart }

            // otherwise if called from a MotorHTML class without an argument
            else { this.imperativeCounterpart = this._makeImperativeCounterpart() }
        };

        /**
         * This method should be overriden by child classes. It should return the
         * imperative-side instance that the HTML-side class (this) corresponds to.
         * @abstract
         */
        DeclarativeBase.prototype._makeImperativeCounterpart = function _makeImperativeCounterpart () {
            throw new TypeError('This method should be implemented by classes extending DeclarativeBase.')
        };

        DeclarativeBase.prototype.childConnectedCallback = function childConnectedCallback (child) {

            // mirror the DOM connections in the imperative API's virtual scene graph.
            if (child instanceof MotorHTMLNode) {
                if (this._hasShadowRoot) { child._isPossiblyDistributed = true }

                // If ImperativeBase#addChild was called first, child's
                // _parent will already be set, so prevent recursion.
                if (child.imperativeCounterpart._parent) { return }

                this.imperativeCounterpart.addChild(child.imperativeCounterpart)
            }
            else if (
                hasShadowDomV0
                && child instanceof HTMLContentElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v0'
            ) {
                // observe <content> elements.
            }
            else if (
                hasShadowDomV1
                && child instanceof HTMLSlotElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v1'
            ) {
                child.addEventListener('slotchange', this)
                this._handleDistributedChildren(child)
            }
        };

        // This method is part of the EventListener interface.
        DeclarativeBase.prototype.handleEvent = function handleEvent (event) {
            if (event.type == 'slotchange') {
                const slot = event.target
                this._handleDistributedChildren(slot)
            }
        };

        DeclarativeBase.prototype._handleDistributedChildren = function _handleDistributedChildren (slot) {
            var this$1 = this;

            const diff = this._getDistributedChildDifference(slot)

            var added = diff.added;
            for (let l=added.length, i=0; i<l; i+=1) {
                const addedNode = added[i]

                if (!(addedNode instanceof DeclarativeBase)) { continue }

                // We do this because if the given slot is assigned to another
                // slot, then this logic will run again for the next slot on
                // that next slot's slotchange, so we remove the distributed
                // node from the previous shadowParent and add it to the next
                // one. If we don't do this, then the distributed node will
                // exist in multiple shadowChildren lists when there is a
                // chain of assigned slots. For more info, see
                // https://github.com/w3c/webcomponents/issues/611
                const shadowParent = addedNode._shadowParent
                if (shadowParent && shadowParent._shadowChildren) {
                    const shadowChildren = shadowParent._shadowChildren
                    shadowChildren.splice(shadowChildren.indexOf(addedNode), 1)
                    if (!shadowChildren.length)
                        { shadowParent._shadowChildren = null }
                }

                addedNode._shadowParent = this$1
                if (!this$1._shadowChildren) { this$1._shadowChildren = [] }
                this$1._shadowChildren.add(addedNode)
            }

            var removed = diff.removed;
            for (let l=removed.length, i=0; i<l; i+=1) {
                const removedNode = removed[i]

                if (!(removedNode instanceof DeclarativeBase)) { continue }

                removedNode._shadowParent = null
                this$1._shadowChildren.delete(removedNode)
                if (!this$1._shadowChildren.size) { this$1._shadowChildren = null }
            }
        };

        DeclarativeBase.prototype._getDistributedChildDifference = function _getDistributedChildDifference (slot) {
            let previousNodes

            if (this._slotElementsAssignedNodes.has(slot))
                { previousNodes = this._slotElementsAssignedNodes.get(slot) }
            else
                { previousNodes = [] }

            const newNodes = slot.assignedNodes({flatten: true})

            // save the newNodes to be used as the previousNodes for next time.
            this._slotElementsAssignedNodes.set(slot, newNodes)

            const diff = {
                removed: [],
            }

            for (let i=0, l=previousNodes.length; i<l; i+=1) {
                const oldNode = previousNodes[i]
                const newIndex = newNodes.indexOf(oldNode)

                // if it exists in the previousNodes but not the newNodes, then
                // the node was removed.
                if (!(newIndex >= 0)) {
                    diff.removed.push(oldNode)
                }

                // otherwise the node wasn't added or removed.
                else {
                    newNodes.splice(i, 1)
                }
            }

            // Remaining nodes in newNodes must have been added.
            diff.added = newNodes

            return diff
        };

        DeclarativeBase.prototype.childDisconnectedCallback = function childDisconnectedCallback (child) {
            // mirror the connection in the imperative API's virtual scene graph.
            if (child instanceof MotorHTMLNode) {
                child._isPossiblyDistributed = false

                // If ImperativeBase#removeChild was called first, child's
                // _parent will already be null, so prevent recursion.
                if (!child.imperativeCounterpart._parent) { return }

                this.imperativeCounterpart.removeChild(child.imperativeCounterpart)
            }
            else if (
                hasShadowDomV0
                && child instanceof HTMLContentElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v0'
            ) {
                // unobserve <content> element
            }
            else if (
                hasShadowDomV1
                && child instanceof HTMLSlotElement
                &&
                //getShadowRootVersion(
                    getAncestorShadowRoot(this)
                //) == 'v1'
            ) {
                child.removeEventListener('slotchange', this)
                this._handleDistributedChildren(child)
                this._slotElementsAssignedNodes.delete(child)
            }
        };

        DeclarativeBase.prototype.setAttribute = function setAttribute (attr, value) {
            //if (this.tagName.toLowerCase() == 'motor-scene')
                //console.log('setting attribute', arguments[1])
            superclass.prototype.setAttribute.call(this, attr, value)
        };

        return DeclarativeBase;
    }(WebComponent(window.HTMLElement)))
}

// Creates setters/getters on the TargetClass which proxy to the
// setters/getters on SourceClass.
export function proxyGettersSetters(SourceClass, TargetClass) {

    // Node methods not to proxy (private underscored methods are also detected and
    // ignored).
    const methodProxyBlacklist = [
        'constructor',
        'parent',
        'children', // proxying this one would really break stuff (f.e. React)
        'element',
        'scene',
        'addChild',
        'addChildren',
        'removeChild',
        'removeChildren' ]

    const props = Object.getOwnPropertyNames(SourceClass.prototype)

    for (let l=props.length, i=0; i<l; i+=1) {
        const prop = props[i]
        if (
            // skip the blacklisted properties
            methodProxyBlacklist.indexOf(prop) >= 0

            // skip the private underscored properties
            || prop.indexOf('_') == 0

            // skip properties that are already defined.
            || TargetClass.prototype.hasOwnProperty(prop)
        ) { continue }

        const targetDescriptor = {}
        const sourceDescriptor = Object.getOwnPropertyDescriptor(SourceClass.prototype, prop)

        // if the property has a setter
        if (sourceDescriptor.set) {
            Object.assign(targetDescriptor, {
                set: function set(value) {
                    this.imperativeCounterpart[prop] = value
                }
            })
        }

        // if the property has a getter
        if (sourceDescriptor.get) {
            Object.assign(targetDescriptor, {
                get: function get() {
                    return this.imperativeCounterpart[prop]
                }
            })
        }

        Object.defineProperty(TargetClass.prototype, prop, targetDescriptor)
    }
}

export {DeclarativeBase as default}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2h0bWwvYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgSFRNTFNsb3RFbGVtZW50ICovXG5cbmltcG9ydCBXZWJDb21wb25lbnQgZnJvbSAnLi93ZWItY29tcG9uZW50J1xuaW1wb3J0IE1vdG9ySFRNTE5vZGUgZnJvbSAnLi9ub2RlJ1xuaW1wb3J0IHsgb2JzZXJ2ZUNoaWxkcmVuLCAvKmdldFNoYWRvd1Jvb3RWZXJzaW9uLCovIGhhc1NoYWRvd0RvbVYwLFxuICAgIGhhc1NoYWRvd0RvbVYxLCBnZXRBbmNlc3RvclNoYWRvd1Jvb3QgfSBmcm9tICcuLi9jb3JlL1V0aWxpdHknXG5cbnZhciBEZWNsYXJhdGl2ZUJhc2VcblxuLy8gV2UgdXNlIHRoaXMgdG8gT3ZlcnJpZGUgSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdyBpbiB2MSwgYW5kXG4vLyBIVE1MRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCBpbiB2MCwgc28gdGhhdCB3ZSBjYW4gbWFrZSB0aGVcbi8vIGNvbm5lY3Rpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIG9uIHRoZSBpcGVyYXRpdmUgc2lkZSB3aGVuIHRoZSBIVE1MIHNpZGVcbi8vIGlzIHVzaW5nIHNoYWRvdyByb290cy5cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBXZWFrTWFwXG5mdW5jdGlvbiBoaWphY2sob3JpZ2luYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBJbiB2MCwgc2hhZG93IHJvb3RzIGNhbiBiZSByZXBsYWNlZCwgYnV0IGluIHYxIGNhbGxpbmcgYXR0YWNoU2hhZG93XG4gICAgICAgIC8vIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIHJvb3QgdGhyb3dzLiBTbywgd2UgY2FuIHNldCB0aGlzIHRvXG4gICAgICAgIC8vIHRydWUsIGFuZCBpZiB0aGUgdHJ5LWNhdGNoIHBhc3NlcyB0aGVuIHdlIGtub3cgd2UgaGF2ZSBhIHYwIHJvb3QgYW5kXG4gICAgICAgIC8vIHRoYXQgdGhlIHJvb3Qgd2FzIGp1c3QgcmVwbGFjZWQuXG4gICAgICAgIGNvbnN0IG9sZFJvb3QgPSB0aGlzLnNoYWRvd1Jvb3RcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCAuLi5hcmdzKVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IHRocm93IGUgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkge1xuICAgICAgICAgICAgdGhpcy5faGFzU2hhZG93Um9vdCA9IHRydWVcbiAgICAgICAgICAgIGlmIChvbGRSb290KSB7XG4gICAgICAgICAgICAgICAgb25WMFNoYWRvd1Jvb3RSZXBsYWNlZC5jYWxsKHRoaXMsIG9sZFJvb3QpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG9ic2VydmVDaGlsZHJlbihyb290LCBzaGFkb3dSb290Q2hpbGRBZGRlZC5iaW5kKHRoaXMpLCBzaGFkb3dSb290Q2hpbGRSZW1vdmVkLmJpbmQodGhpcykpXG4gICAgICAgICAgICBvYnNlcnZlcnMuc2V0KHJvb3QsIG9ic2VydmVyKVxuXG4gICAgICAgICAgICBjb25zdCB7Y2hpbGRyZW59ID0gdGhpc1xuICAgICAgICAgICAgZm9yIChsZXQgbD1jaGlsZHJlbi5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBEZWNsYXJhdGl2ZUJhc2UpKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9pc1Bvc3NpYmx5RGlzdHJpYnV0ZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWRvd1Jvb3RDaGlsZEFkZGVkKGNoaWxkKSB7XG5cbiAgICAvLyBOT1RFIExvZ2ljIGhlcmUgaXMgc2ltaWxhciB0byBjaGlsZENvbm5lY3RlZENhbGxiYWNrXG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBEZWNsYXJhdGl2ZUJhc2UpIHtcbiAgICAgICAgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQuYWRkQ2hpbGQoY2hpbGQuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0KVxuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAgICAgaGFzU2hhZG93RG9tVjBcbiAgICAgICAgJiYgY2hpbGQgaW5zdGFuY2VvZiBIVE1MQ29udGVudEVsZW1lbnRcbiAgICApIHtcbiAgICAgICAgLy8gb2JzZXJ2ZSA8Y29udGVudD4gZWxlbWVudHMuXG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgICAgICBoYXNTaGFkb3dEb21WMVxuICAgICAgICAmJiBjaGlsZCBpbnN0YW5jZW9mIEhUTUxTbG90RWxlbWVudFxuICAgICkge1xuICAgICAgICBjaGlsZC5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcylcbiAgICAgICAgdGhpcy5faGFuZGxlRGlzdHJpYnV0ZWRDaGlsZHJlbihjaGlsZClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWRvd1Jvb3RDaGlsZFJlbW92ZWQoY2hpbGQpIHtcblxuICAgIC8vIE5PVEUgTG9naWMgaGVyZSBpcyBzaW1pbGFyIHRvIGNoaWxkRGlzY29ubmVjdGVkQ2FsbGJhY2tcblxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkge1xuICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5yZW1vdmVDaGlsZChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQpXG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgICAgICBoYXNTaGFkb3dEb21WMFxuICAgICAgICAmJiBjaGlsZCBpbnN0YW5jZW9mIEhUTUxDb250ZW50RWxlbWVudFxuICAgICkge1xuICAgICAgICAvLyB1bm9ic2VydmUgPGNvbnRlbnQ+IGVsZW1lbnRcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgICAgIGhhc1NoYWRvd0RvbVYxXG4gICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzKVxuICAgICAgICB0aGlzLl9oYW5kbGVEaXN0cmlidXRlZENoaWxkcmVuKGNoaWxkKVxuICAgICAgICB0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLmRlbGV0ZShjaGlsZClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uVjBTaGFkb3dSb290UmVwbGFjZWQob2xkUm9vdCkge1xuICAgIG9ic2VydmVycy5nZXQob2xkUm9vdCkuZGlzY29ubmVjdCgpXG4gICAgb2JzZXJ2ZXJzLmRlbGV0ZShvbGRSb290KVxuICAgIGNvbnN0IHtjaGlsZE5vZGVzfSA9IG9sZFJvb3RcbiAgICBmb3IgKGxldCBsPWNoaWxkTm9kZXMubGVuZ3RoLCBpPTA7IGk8bDsgaSs9MSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkTm9kZXNbaV1cblxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGRpc2Nvbm5lY3QgdGhlIGltcGVyYXRpdmUgY29ubmVjdGlvbiAoZi5lLiBzbyBpdCBpcyBub3RcbiAgICAgICAgLy8gcmVuZGVyZWQgaW4gV2ViR0wpXG4gICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LnJlbW92ZUNoaWxkKGNoaWxkLmltcGVyYXRpdmVDb3VudGVycGFydCwgdHJ1ZSlcbiAgICB9XG59XG5cbmlmIChIVE1MRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gaGlqYWNrKEhUTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290KVxuaWYgKEhUTUxFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ID0gaGlqYWNrKEhUTUxFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpXG5cbmluaXRNb3RvckhUTUxCYXNlKClcbmV4cG9ydCBmdW5jdGlvbiBpbml0TW90b3JIVE1MQmFzZSgpIHtcbiAgICBpZiAoRGVjbGFyYXRpdmVCYXNlKSByZXR1cm5cblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtFdmVudExpc3RlbmVyfVxuICAgICAqL1xuICAgIERlY2xhcmF0aXZlQmFzZSA9IGNsYXNzIERlY2xhcmF0aXZlQmFzZSBleHRlbmRzIFdlYkNvbXBvbmVudCh3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuY3JlYXRlZENhbGxiYWNrKClcblxuICAgICAgICAgICAgdGhpcy5pbXBlcmF0aXZlQ291bnRlcnBhcnQgPSBudWxsIC8vIHRvIGhvbGQgdGhlIGltcGVyYXRpdmUgQVBJIE5vZGUgaW5zdGFuY2UuXG5cbiAgICAgICAgICAgIC8vIHRydWUgaWYgdGhpcyBub2RlIGhhcyBhIHNoYWRvdyByb290IChldmVuIGlmIGl0IGlzIFwiY2xvc2VkXCIsIHNlZVxuICAgICAgICAgICAgLy8gaGlqYWNrIGZ1bmN0aW9uIGFib3ZlKS4gT25jZSB0cnVlIGFsd2F5cyB0cnVlIGJlY2F1c2Ugc2hhZG93XG4gICAgICAgICAgICAvLyByb290cyBjYW5ub3QgYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgIHRoaXMuX2hhc1NoYWRvd1Jvb3QgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBUcnVlIHdoZW4gdGhpcyBub2RlIGhhcyBhIHBhcmVudCB0aGF0IGhhcyBhIHNoYWRvdyByb290LiBXaGVuXG4gICAgICAgICAgICAvLyB1c2luZyB0aGUgSFRNTCBBUEksIEltcGVyYXRpdmUgQVBJIGNhbiBsb29rIGF0IHRoaXMgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJlbmRlciB0aGlzIG5vZGUgb3Igbm90LCBpbiB0aGUgY2FzZSBvZiBXZWJHTC5cbiAgICAgICAgICAgIHRoaXMuX2lzUG9zc2libHlEaXN0cmlidXRlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIEEgbWFwIG9mIHRoZSBzbG90IGVsZW1lbnRzIHRoYXQgYXJlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBhbmRcbiAgICAgICAgICAgIC8vIHRoZWlyIGxhc3Qta25vd24gYXNzaWduZWQgbm9kZXMuIFdoZW4gYSBzbG90Y2hhbmdlIGhhcHBlbnMgd2hpbGVcbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBpcyBpbiBhIHNoYWRvdyByb290IGFuZCBoYXMgYSBzbG90IGNoaWxkLCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIGRldGVjdCB3aGF0IHRoZSBkaWZmZXJlbmNlIGlzIGJldHdlZW4gdGhlIGxhc3Qga25vd24gYW5kIHRoZSBuZXdcbiAgICAgICAgICAgIC8vIGFzc2lnbm1lbnRzLCBhbmQgbm90YXRlIHRoZSBuZXcgZGlzdHJpYnV0aW9uIG9mIGNoaWxkIG5vZGVzLiBTZWVcbiAgICAgICAgICAgIC8vIGlzc3VlICM0MCBmb3IgYmFja2dyb3VuZCBvbiB3aHkgd2UgZG8gdGhpcy5cbiAgICAgICAgICAgIHRoaXMuX3Nsb3RFbGVtZW50c0Fzc2lnbmVkTm9kZXMgPSBuZXcgV2Vha01hcFxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG5vZGUgaXMgZGlzdHJpYnV0ZWQgaW50byBhIHNoYWRvdyB0cmVlLCB0aGlzIHdpbGxcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0aGUgcGFyZW50IG9mIHRoZSA8c2xvdD4gb3IgPGNvbnRlbnQ+IGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBCYXNpY2FsbHksIHRoaXMgbm9kZSB3aWxsIHJlbmRlciBhcyBhIGNoaWxkIG9mIHRoYXQgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIC8vIGluIHRoZSBmbGF0IHRyZWUuXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dQYXJlbnQgPSBudWxsXG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgYSBjaGlsZCA8c2xvdD4gb3IgPGNvbnRlbnQ+IGVsZW1lbnQgd2hpbGUgaW5cbiAgICAgICAgICAgIC8vIGEgc2hhZG93IHJvb3QsIHRoZW4gdGhpcyB3aWxsIGJlIGEgU2V0IG9mIHRoZSBub2RlcyBkaXN0cmlidXRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgPHNsb3Q+IG9yIDxjb250ZW50PiwgYW5kIHRob3NlIG5vZGVzIHJlbmRlciByZWxhdGl2ZWx5XG4gICAgICAgICAgICAvLyB0byB0aGlzIG5vZGUgaW4gdGhlIGZsYXQgdHJlZS4gV2UgaW5zdGFudGlhdGUgdGhpcyBsYXRlciwgb25seVxuICAgICAgICAgICAgLy8gd2hlbi9pZiBuZWVkZWQuXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDaGlsZHJlbiA9IG51bGxcblxuICAgICAgICAgICAgLy8gV2UgdXNlIFByb21pc2UucmVzb2x2ZSBoZXJlIHRvIGRlZmVyIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cbiAgICAgICAgICAgIC8vIFdoaWxlIHdlIHN1cHBvcnQgQ3VzdG9tIEVsZW1lbnRzIHYwLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgaW1wZXJhdGl2ZSBOb2RlIGNvdW50ZXJwYXJ0IHdpbGwgaGF2ZSBhbHJlYWR5IGNhbGxlZCB0aGVcbiAgICAgICAgICAgIC8vIGBfYXNzb2NpYXRlSW1wZXJhdGl2ZU5vZGVgIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQsIGNhdXNpbmcgdGhlXG4gICAgICAgICAgICAvLyBuZXh0IG1pY3JvdGFzaydzIGNhbGwgdG8gYmUgYSBuby1vcC4gV2hlbiB0aGlzIE1vdG9ySFRNTCBlbGVtZW50XG4gICAgICAgICAgICAvLyBBUEkgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBJbXBlcmF0aXZlIGNvdW50ZXJwYXJ0LCB0aGVuIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2sncyBgX2Fzc29jaWF0ZUltcGVyYXRpdmVOb2RlYCBjYWxsIHdpbGwgbm90IGJlIGEgbm8tb3AuXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGRyb3Agc3VwcG9ydCBmb3IgdjAgQ3VzdG9tIEVsZW1lbnRzIGF0IHNvbWUgcG9pbnQsIHdlXG4gICAgICAgICAgICAvLyBjYW4gcmVseSBvbiBwYXNzaW5nIGEgY29uc3RydWN0b3IgYXJndW1lbnQgc2ltaWxhcmx5IHRvIGhvdyB3ZVxuICAgICAgICAgICAgLy8gZG8gd2l0aCBtb3Rvci9Ob2RlIGluIG9yZGVyIHRvIGRldGVjdCB0aGF0IHRoZSBjb25zdHJ1Y3RvciBpc1xuICAgICAgICAgICAgLy8gYmVpbmcgY2FsbGVkIGZyb20gdGhlIHJlY2lwcm9jYWwgQVBJLiBTZWUgdGhlIGNvbnN0cnVjdG9yIGluXG4gICAgICAgICAgICAvLyBtb3Rvci9Ob2RlLmpzIHRvIGdldCBzZWUgdGhlIGlkZWEuXG4gICAgICAgICAgICAvLyBUT0RPOiByZW5ld2FibGUgcHJvbWlzZSBhZnRlciB1bm1vdW50LlxuICAgICAgICAgICAgdGhpcy5faW1wZXJhdGl2ZUNvdW50ZXJwYXJ0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fYXNzb2NpYXRlSW1wZXJhdGl2ZU5vZGUoKSlcbiAgICAgICAgICAgIHRoaXMubW91bnRQcm9taXNlID0gdGhpcy5faW1wZXJhdGl2ZUNvdW50ZXJwYXJ0UHJvbWlzZVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0Lm1vdW50UHJvbWlzZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBhc3NvY2lhdGlvbiBiZXR3ZWVuIHRoaXMgTW90b3JIVE1MTm9kZSBpbnN0YW5jZVxuICAgICAgICAgKiBhbmQgdGhlIGltcGVyYXRpdmUgTm9kZSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgbWF5IGdldCBjYWxsZWQgYnkgdGhpcy5pbml0LCBidXQgY2FuIGFsc28gYmUgY2FsbGVkIGJ5XG4gICAgICAgICAqIHRoZSBOb2RlIGNsYXNzIGlmIE5vZGUgaXMgdXNlZCBpbXBlcmF0aXZlbHkuIFNlZSBOb2RlI2NvbnN0cnVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0IFRoZSBpbXBlcmF0aXZlIGNvdW50ZXJwYXJ0IHRvXG4gICAgICAgICAqIGFzc29jaWF0ZSB3aXRoIHRoaXMgTW90b3JIVE1MIGVsZW1lbnQuIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiB0aGVcbiAgICAgICAgICogaW1wZXJhdGl2ZSBBUEkgY29uc3RydWN0b3JzLCBhbmQgdGhpcyBoYXBwZW5zIHdoZW4gdXNpbmcgdGhlIGltcGVyYXRpdmVcbiAgICAgICAgICogZm9ybSBvZiBpbmZhbW91cyBpbnN0ZWFkIG9mIHRoZSBIVE1MIGludGVyZmFjZSB0byBpbmZhbW91cy4gV2hlbiB0aGUgSFRNTFxuICAgICAgICAgKiBpbnRlcmZhY2UgaXMgdXNlZCwgdGhpcyBnZXRzIGNhbGxlZCBmaXJzdCB3aXRob3V0IGFuXG4gICAgICAgICAqIGltcGVyYXRpdmVDb3VudGVycGFydCBhcmd1bWVudCBhbmQgdGhlIGNhbGwgdG8gdGhpcyBpbiBhbiBpbXBlcmF0aXZlXG4gICAgICAgICAqIGNvbnN0cnVjdG9yIHdpbGwgYmUgYSBub29wLiBCYXNpY2FsbHksIGVpdGhlciB0aGlzIGdldHMgY2FsbGVkIGZpcnN0IGJ5IGFcbiAgICAgICAgICogTW90b3JIVE1MIGVsZW1lbnQsIG9yIGZpcnN0IGJ5IGFuIGltcGVyYXRpdmUgaW5zdGFuY2UsIGRlcGVuZGluZyBvbiB3aGljaFxuICAgICAgICAgKiBBUEkgaXMgdXNlZCBmaXJzdC5cbiAgICAgICAgICovXG4gICAgICAgIF9hc3NvY2lhdGVJbXBlcmF0aXZlTm9kZShpbXBlcmF0aXZlQ291bnRlcnBhcnQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhc3NvY2lhdGlvbiBpcyBtYWRlIGFscmVhZHksIG5vb3BcbiAgICAgICAgICAgIGlmICh0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydCkgcmV0dXJuXG5cbiAgICAgICAgICAgIC8vIGlmIGNhbGxlZCBmcm9tIGFuIGltcGVyYXRpdmUtc2lkZSBjbGFzcycgY29uc3RydWN0b3IsIGFzc29jaWF0ZVxuICAgICAgICAgICAgLy8gdGhlIHBhc3NlZCBpbnN0YW5jZS5cbiAgICAgICAgICAgIGlmIChpbXBlcmF0aXZlQ291bnRlcnBhcnQpIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0ID0gaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0XG5cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiBjYWxsZWQgZnJvbSBhIE1vdG9ySFRNTCBjbGFzcyB3aXRob3V0IGFuIGFyZ3VtZW50XG4gICAgICAgICAgICBlbHNlIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0ID0gdGhpcy5fbWFrZUltcGVyYXRpdmVDb3VudGVycGFydCgpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRlbiBieSBjaGlsZCBjbGFzc2VzLiBJdCBzaG91bGQgcmV0dXJuIHRoZVxuICAgICAgICAgKiBpbXBlcmF0aXZlLXNpZGUgaW5zdGFuY2UgdGhhdCB0aGUgSFRNTC1zaWRlIGNsYXNzICh0aGlzKSBjb3JyZXNwb25kcyB0by5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBfbWFrZUltcGVyYXRpdmVDb3VudGVycGFydCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgbWV0aG9kIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBjbGFzc2VzIGV4dGVuZGluZyBEZWNsYXJhdGl2ZUJhc2UuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkQ29ubmVjdGVkQ2FsbGJhY2soY2hpbGQpIHtcblxuICAgICAgICAgICAgLy8gbWlycm9yIHRoZSBET00gY29ubmVjdGlvbnMgaW4gdGhlIGltcGVyYXRpdmUgQVBJJ3MgdmlydHVhbCBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1vdG9ySFRNTE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzU2hhZG93Um9vdCkgY2hpbGQuX2lzUG9zc2libHlEaXN0cmlidXRlZCA9IHRydWVcblxuICAgICAgICAgICAgICAgIC8vIElmIEltcGVyYXRpdmVCYXNlI2FkZENoaWxkIHdhcyBjYWxsZWQgZmlyc3QsIGNoaWxkJ3NcbiAgICAgICAgICAgICAgICAvLyBfcGFyZW50IHdpbGwgYWxyZWFkeSBiZSBzZXQsIHNvIHByZXZlbnQgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQuX3BhcmVudCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydC5hZGRDaGlsZChjaGlsZC5pbXBlcmF0aXZlQ291bnRlcnBhcnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMFxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTENvbnRlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YwJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZSA8Y29udGVudD4gZWxlbWVudHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3dEb21WMVxuICAgICAgICAgICAgICAgICYmIGNoaWxkIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50XG4gICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAvL2dldFNoYWRvd1Jvb3RWZXJzaW9uKFxuICAgICAgICAgICAgICAgICAgICBnZXRBbmNlc3RvclNoYWRvd1Jvb3QodGhpcylcbiAgICAgICAgICAgICAgICAvLykgPT0gJ3YxJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRGlzdHJpYnV0ZWRDaGlsZHJlbihjaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIEV2ZW50TGlzdGVuZXIgaW50ZXJmYWNlLlxuICAgICAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ3Nsb3RjaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZURpc3RyaWJ1dGVkQ2hpbGRyZW4oc2xvdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oYW5kbGVEaXN0cmlidXRlZENoaWxkcmVuKHNsb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLl9nZXREaXN0cmlidXRlZENoaWxkRGlmZmVyZW5jZShzbG90KVxuXG4gICAgICAgICAgICBjb25zdCB7YWRkZWR9ID0gZGlmZlxuICAgICAgICAgICAgZm9yIChsZXQgbD1hZGRlZC5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWROb2RlID0gYWRkZWRbaV1cblxuICAgICAgICAgICAgICAgIGlmICghKGFkZGVkTm9kZSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgaWYgdGhlIGdpdmVuIHNsb3QgaXMgYXNzaWduZWQgdG8gYW5vdGhlclxuICAgICAgICAgICAgICAgIC8vIHNsb3QsIHRoZW4gdGhpcyBsb2dpYyB3aWxsIHJ1biBhZ2FpbiBmb3IgdGhlIG5leHQgc2xvdCBvblxuICAgICAgICAgICAgICAgIC8vIHRoYXQgbmV4dCBzbG90J3Mgc2xvdGNoYW5nZSwgc28gd2UgcmVtb3ZlIHRoZSBkaXN0cmlidXRlZFxuICAgICAgICAgICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgcHJldmlvdXMgc2hhZG93UGFyZW50IGFuZCBhZGQgaXQgdG8gdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBvbmUuIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gdGhlIGRpc3RyaWJ1dGVkIG5vZGUgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IGluIG11bHRpcGxlIHNoYWRvd0NoaWxkcmVuIGxpc3RzIHdoZW4gdGhlcmUgaXMgYVxuICAgICAgICAgICAgICAgIC8vIGNoYWluIG9mIGFzc2lnbmVkIHNsb3RzLiBGb3IgbW9yZSBpbmZvLCBzZWVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmNvbXBvbmVudHMvaXNzdWVzLzYxMVxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd1BhcmVudCA9IGFkZGVkTm9kZS5fc2hhZG93UGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvd1BhcmVudCAmJiBzaGFkb3dQYXJlbnQuX3NoYWRvd0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0NoaWxkcmVuID0gc2hhZG93UGFyZW50Ll9zaGFkb3dDaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDaGlsZHJlbi5zcGxpY2Uoc2hhZG93Q2hpbGRyZW4uaW5kZXhPZihhZGRlZE5vZGUpLCAxKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYWRvd0NoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1BhcmVudC5fc2hhZG93Q2hpbGRyZW4gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkZWROb2RlLl9zaGFkb3dQYXJlbnQgPSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFkb3dDaGlsZHJlbikgdGhpcy5fc2hhZG93Q2hpbGRyZW4gPSBbXVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NoaWxkcmVuLmFkZChhZGRlZE5vZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHtyZW1vdmVkfSA9IGRpZmZcbiAgICAgICAgICAgIGZvciAobGV0IGw9cmVtb3ZlZC5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZE5vZGUgPSByZW1vdmVkW2ldXG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZW1vdmVkTm9kZSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlQmFzZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZS5fc2hhZG93UGFyZW50ID0gbnVsbFxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NoaWxkcmVuLmRlbGV0ZShyZW1vdmVkTm9kZSlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWRvd0NoaWxkcmVuLnNpemUpIHRoaXMuX3NoYWRvd0NoaWxkcmVuID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldERpc3RyaWJ1dGVkQ2hpbGREaWZmZXJlbmNlKHNsb3QpIHtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c05vZGVzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLmhhcyhzbG90KSlcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGVzID0gdGhpcy5fc2xvdEVsZW1lbnRzQXNzaWduZWROb2Rlcy5nZXQoc2xvdClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGVzID0gW11cblxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KVxuXG4gICAgICAgICAgICAvLyBzYXZlIHRoZSBuZXdOb2RlcyB0byBiZSB1c2VkIGFzIHRoZSBwcmV2aW91c05vZGVzIGZvciBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLl9zbG90RWxlbWVudHNBc3NpZ25lZE5vZGVzLnNldChzbG90LCBuZXdOb2RlcylcblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHtcbiAgICAgICAgICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaT0wLCBsPXByZXZpb3VzTm9kZXMubGVuZ3RoOyBpPGw7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGROb2RlID0gcHJldmlvdXNOb2Rlc1tpXVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gbmV3Tm9kZXMuaW5kZXhPZihvbGROb2RlKVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZXhpc3RzIGluIHRoZSBwcmV2aW91c05vZGVzIGJ1dCBub3QgdGhlIG5ld05vZGVzLCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgd2FzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgaWYgKCEobmV3SW5kZXggPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5yZW1vdmVkLnB1c2gob2xkTm9kZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhlIG5vZGUgd2Fzbid0IGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIG5vZGVzIGluIG5ld05vZGVzIG11c3QgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAgICAgICAgZGlmZi5hZGRlZCA9IG5ld05vZGVzXG5cbiAgICAgICAgICAgIHJldHVybiBkaWZmXG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZERpc2Nvbm5lY3RlZENhbGxiYWNrKGNoaWxkKSB7XG4gICAgICAgICAgICAvLyBtaXJyb3IgdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGltcGVyYXRpdmUgQVBJJ3MgdmlydHVhbCBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1vdG9ySFRNTE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5faXNQb3NzaWJseURpc3RyaWJ1dGVkID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIC8vIElmIEltcGVyYXRpdmVCYXNlI3JlbW92ZUNoaWxkIHdhcyBjYWxsZWQgZmlyc3QsIGNoaWxkJ3NcbiAgICAgICAgICAgICAgICAvLyBfcGFyZW50IHdpbGwgYWxyZWFkeSBiZSBudWxsLCBzbyBwcmV2ZW50IHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmltcGVyYXRpdmVDb3VudGVycGFydC5fcGFyZW50KSByZXR1cm5cblxuICAgICAgICAgICAgICAgIHRoaXMuaW1wZXJhdGl2ZUNvdW50ZXJwYXJ0LnJlbW92ZUNoaWxkKGNoaWxkLmltcGVyYXRpdmVDb3VudGVycGFydClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGhhc1NoYWRvd0RvbVYwXG4gICAgICAgICAgICAgICAgJiYgY2hpbGQgaW5zdGFuY2VvZiBIVE1MQ29udGVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgIC8vZ2V0U2hhZG93Um9vdFZlcnNpb24oXG4gICAgICAgICAgICAgICAgICAgIGdldEFuY2VzdG9yU2hhZG93Um9vdCh0aGlzKVxuICAgICAgICAgICAgICAgIC8vKSA9PSAndjAnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyB1bm9ic2VydmUgPGNvbnRlbnQ+IGVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGhhc1NoYWRvd0RvbVYxXG4gICAgICAgICAgICAgICAgJiYgY2hpbGQgaW5zdGFuY2VvZiBIVE1MU2xvdEVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgIC8vZ2V0U2hhZG93Um9vdFZlcnNpb24oXG4gICAgICAgICAgICAgICAgICAgIGdldEFuY2VzdG9yU2hhZG93Um9vdCh0aGlzKVxuICAgICAgICAgICAgICAgIC8vKSA9PSAndjEnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVEaXN0cmlidXRlZENoaWxkcmVuKGNoaWxkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Nsb3RFbGVtZW50c0Fzc2lnbmVkTm9kZXMuZGVsZXRlKGNoaWxkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgICAvL2lmICh0aGlzLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnbW90b3Itc2NlbmUnKVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldHRpbmcgYXR0cmlidXRlJywgYXJndW1lbnRzWzFdKVxuICAgICAgICAgICAgc3VwZXIuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDcmVhdGVzIHNldHRlcnMvZ2V0dGVycyBvbiB0aGUgVGFyZ2V0Q2xhc3Mgd2hpY2ggcHJveHkgdG8gdGhlXG4vLyBzZXR0ZXJzL2dldHRlcnMgb24gU291cmNlQ2xhc3MuXG5leHBvcnQgZnVuY3Rpb24gcHJveHlHZXR0ZXJzU2V0dGVycyhTb3VyY2VDbGFzcywgVGFyZ2V0Q2xhc3MpIHtcblxuICAgIC8vIE5vZGUgbWV0aG9kcyBub3QgdG8gcHJveHkgKHByaXZhdGUgdW5kZXJzY29yZWQgbWV0aG9kcyBhcmUgYWxzbyBkZXRlY3RlZCBhbmRcbiAgICAvLyBpZ25vcmVkKS5cbiAgICBjb25zdCBtZXRob2RQcm94eUJsYWNrbGlzdCA9IFtcbiAgICAgICAgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgJ3BhcmVudCcsXG4gICAgICAgICdjaGlsZHJlbicsIC8vIHByb3h5aW5nIHRoaXMgb25lIHdvdWxkIHJlYWxseSBicmVhayBzdHVmZiAoZi5lLiBSZWFjdClcbiAgICAgICAgJ2VsZW1lbnQnLFxuICAgICAgICAnc2NlbmUnLFxuICAgICAgICAnYWRkQ2hpbGQnLFxuICAgICAgICAnYWRkQ2hpbGRyZW4nLFxuICAgICAgICAncmVtb3ZlQ2hpbGQnLFxuICAgICAgICAncmVtb3ZlQ2hpbGRyZW4nLFxuICAgIF1cblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU291cmNlQ2xhc3MucHJvdG90eXBlKVxuXG4gICAgZm9yIChsZXQgbD1wcm9wcy5sZW5ndGgsIGk9MDsgaTxsOyBpKz0xKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBza2lwIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBtZXRob2RQcm94eUJsYWNrbGlzdC5pbmRleE9mKHByb3ApID49IDBcblxuICAgICAgICAgICAgLy8gc2tpcCB0aGUgcHJpdmF0ZSB1bmRlcnNjb3JlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB8fCBwcm9wLmluZGV4T2YoJ18nKSA9PSAwXG5cbiAgICAgICAgICAgIC8vIHNraXAgcHJvcGVydGllcyB0aGF0IGFyZSBhbHJlYWR5IGRlZmluZWQuXG4gICAgICAgICAgICB8fCBUYXJnZXRDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcClcbiAgICAgICAgKSBjb250aW51ZVxuXG4gICAgICAgIGNvbnN0IHRhcmdldERlc2NyaXB0b3IgPSB7fVxuICAgICAgICBjb25zdCBzb3VyY2VEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTb3VyY2VDbGFzcy5wcm90b3R5cGUsIHByb3ApXG5cbiAgICAgICAgLy8gaWYgdGhlIHByb3BlcnR5IGhhcyBhIHNldHRlclxuICAgICAgICBpZiAoc291cmNlRGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0RGVzY3JpcHRvciwge1xuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydFtwcm9wXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBoYXMgYSBnZXR0ZXJcbiAgICAgICAgaWYgKHNvdXJjZURlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldERlc2NyaXB0b3IsIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcGVyYXRpdmVDb3VudGVycGFydFtwcm9wXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFyZ2V0Q2xhc3MucHJvdG90eXBlLCBwcm9wLCB0YXJnZXREZXNjcmlwdG9yKVxuICAgIH1cbn1cblxuZXhwb3J0IHtEZWNsYXJhdGl2ZUJhc2UgYXMgZGVmYXVsdH1cbiJdLCJuYW1lcyI6WyJ0aGlzIiwic3VwZXIiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE9BQU8sWUFBWSxNQUFNLGlCQUFpQjtBQUMxQyxPQUFPLGFBQWEsTUFBTSxRQUFRO0FBQ2xDLFNBQVMsZUFBZSw0QkFBNEIsY0FBYztJQUM5RCxjQUFjLEVBQUUscUJBQXFCLFFBQVEsaUJBQWlCOztBQUVsRSxJQUFJLGVBQWU7Ozs7OztBQU1uQixNQUFNLFNBQVMsR0FBRyxJQUFJLE9BQU87QUFDN0IsU0FBUyxNQUFNLENBQUMsUUFBUSxFQUFFO0lBQ3RCLE9BQU8sU0FBUyxBQUFPLEVBQUUsQ0FBQzs7O0FBQUE7Ozs7O1FBS3RCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUk7UUFDZixJQUFJO1lBQ0EsSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLE1BQUEsQ0FBQyxZQUFBLElBQUksV0FBRSxBQUFHLElBQUksRUFBQSxDQUFDO1NBQ3RDO1FBQ0QsT0FBTyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRTtRQUNyQixJQUFJLElBQUksWUFBWSxlQUFlLEVB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