'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _set2 = require('babel-runtime/core-js/set');

var _set3 = _interopRequireDefault(_set2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _set4 = require('babel-runtime/helpers/set');

var _set5 = _interopRequireDefault(_set4);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _Transformable = require('./Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _ImperativeBase = require('./ImperativeBase');

var _ImperativeBase2 = _interopRequireDefault(_ImperativeBase);

var _XYZValues = require('./XYZValues');

var _XYZValues2 = _interopRequireDefault(_XYZValues);

var _XYZNonNegativeValues = require('./XYZNonNegativeValues');

var _XYZNonNegativeValues2 = _interopRequireDefault(_XYZNonNegativeValues);

var _ValueProcessor2 = require('./ValueProcessor');

var _ValueProcessor3 = _interopRequireDefault(_ValueProcessor2);

var _HTMLScene = require('../html/HTMLScene');

var _HTMLScene2 = _interopRequireDefault(_HTMLScene);

var _documentReady = require('@awaitbox/document-ready');

var _documentReady2 = _interopRequireDefault(_documentReady);

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ImperativeBase.initImperativeBase)();

// TODO: write a test that imports public interfaces in every possible
// permutation to detect circular dependency errors.
// See: https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem

var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

var Scene = null;

var SceneMixin = function (base) {
    var _Scene = function (_ValueProcessor) {
        (0, _inherits3.default)(_Scene, _ValueProcessor);

        function _Scene() {
            (0, _classCallCheck3.default)(this, _Scene);

            return (0, _possibleConstructorReturn3.default)(this, (_Scene.__proto__ || (0, _getPrototypeOf2.default)(_Scene)).apply(this, arguments));
        }

        (0, _createClass3.default)(_Scene, [{
            key: 'construct',
            value: function construct(options) {
                var this$1 = this;
                if (options === void 0) options = {};

                (0, _get3.default)(_Scene.prototype.__proto__ || (0, _getPrototypeOf2.default)(_Scene.prototype), 'construct', this).call(this, options);

                // Used by the this.scene getter in ImperativeBase
                // Motor's loop checks _scene on Nodes and Scenes when determining
                // modified scenes.
                this._scene = this;

                // TODO get default camera values from somewhere.
                this._perspective = 1000;

                // NOTE: z size is always 0, since native DOM elements are always flat.
                this._elementParentSize = { x: 0, y: 0, z: 0 };

                this._onElementParentSizeChange = function (newSize) {
                    this$1._elementParentSize = newSize;
                    this$1._calcSize();
                    this$1._needsToBeRendered();
                };

                this._calcSize();
                this._needsToBeRendered();
            }

            // For now, use the same program (with shaders) for all objects.
            // Basically it has position, frag colors, point light, directional
            // light, and ambient light.
            // TODO: maybe call this in `init()`, and destroy webgl stuff in
            // `deinit()`.
            // TODO: The user might enable this by setting the attribute later, so
            // we can't simply rely on having it in constructor, we need a
            // getter/setter like node properties.
            // TODO: we need to deinit webgl too.

        }, {
            key: 'initWebGl',
            value: function initWebGl() {
                return new Promise(function ($return, $error) {
                    // THREE
                    // maybe keep this in sceneState in WebGLRendererThree
                    (0, _get3.default)(_Scene.prototype.__proto__ || (0, _getPrototypeOf2.default)(_Scene.prototype), 'initWebGl', this).call(this);

                    // We don't let Three update any matrices, we supply our own world
                    // matrices.
                    this.threeObject3d.autoUpdate = false;

                    // this.threeCamera holds the active camera. There can be many
                    // cameras in the scene tree, but the last one with active="true"
                    // will be the one referenced here.
                    // If there are no cameras in the tree, a virtual default camera is
                    // referenced here, who's perspective is that of the scene's
                    // perspective attribute.
                    this.threeCamera = null;
                    this._createDefaultCamera();

                    // TODO: default ambient light when no AmbientLight elements are
                    // present in the Scene.
                    //const ambientLight = new AmbientLight( 0x353535 )
                    //this.threeObject3d.add( ambientLight )

                    // holds the renderer for this scene, renderers have scene-specific
                    // settings so having this reference is okay.
                    this._renderer = null;

                    // a default orange background color. Use the backgroundColor and
                    // backgroundOpacity attributes to customize.
                    this._glBackgroundColor = new _three.Color(0xff6600);
                    this._glBackgroundOpacity = 0;

                    // holds active cameras found in the DOM tree (if this is empty, it
                    // means no camera elements are in the DOM, but this.threeCamera
                    // will still have a reference to the default camera that scenes
                    // are rendered with when no camera elements exist).
                    this._activeCameras = new _set3.default();

                    // TODO: this needs to be cancelable too, search other codes for
                    // "mountcancel" to see.
                    return this.mountPromise.then(function ($await_2) {
                        try {

                            this.webglEnabled = !!this.element.hasAttribute('experimental-webgl');
                            if (!this.webglEnabled) {
                                return $return();
                            }

                            this._renderer = _Motor2.default.getWebGLRenderer(this, 'three');

                            // set default colors
                            this._renderer.setClearColor(this, this._glBackgroundColor, this._glBackgroundOpacity);
                            return $return();
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }.bind(this));
            }
        }, {
            key: 'makeThreeObject3d',
            value: function makeThreeObject3d() {
                return new _three.Scene();
            }

            // TODO ability to init and destroy webgl for the whole scene.

        }, {
            key: 'destroyWebGl',
            value: function destroyWebGl() {}

            // TODO PERFORMANCE: make this static for better performance.

        }, {
            key: '_setDefaultProperties',
            value: function _setDefaultProperties() {
                (0, _get3.default)(_Scene.prototype.__proto__ || (0, _getPrototypeOf2.default)(_Scene.prototype), '_setDefaultProperties', this).call(this);

                (0, _assign2.default)(this._properties, {
                    sizeMode: new _XYZValues2.default('proportional', 'proportional', 'proportional'),
                    size: new _XYZNonNegativeValues2.default(1, 1, 1)
                });
            }
        }, {
            key: '_setCamera',
            value: function _setCamera(camera) {
                if (!camera) {
                    this._createDefaultCamera();
                } else {
                    // TODO?: implement an changecamera event/method and emit/call
                    // that here, then move this logic to the renderer
                    // handler/method?
                    this.threeCamera = camera.threeObject3d;
                    this._updateCameraAspect();
                    this._updateCameraProjection();
                    this._needsToBeRendered();
                }
            }
        }, {
            key: '_createDefaultCamera',
            value: function _createDefaultCamera() {
                var size = this._calculatedSize;
                // THREE-COORDS-TO-DOM-COORDS
                // We apply Three perspective the same way as CSS3D perspective here.
                // TODO CAMERA-DEFAULTS, get defaults from somewhere common.
                // TODO the "far" arg will be auto-calculated to encompass the furthest objects (like CSS3D).
                this.threeCamera = new _three.PerspectiveCamera(45, size.x / size.y || 1, 0.1, 10000);
                this.perspective = 1000;
            }

            // TODO can this be moved to a render task like _calcSize? It depends
            // on size values.

        }, {
            key: '_updateCameraPerspective',
            value: function _updateCameraPerspective() {
                var perspective = this._perspective;
                this.threeCamera.fov = 180 * (2 * Math.atan(this._calculatedSize.y / 2 / perspective)) / Math.PI;
                this.threeCamera.position.z = perspective;
            }
        }, {
            key: '_updateCameraAspect',
            value: function _updateCameraAspect() {
                this.threeCamera.aspect = this._calculatedSize.x / this._calculatedSize.y || 1;
            }
        }, {
            key: '_updateCameraProjection',
            value: function _updateCameraProjection() {
                this.threeCamera.updateProjectionMatrix();
            }
        }, {
            key: '_addCamera',
            value: function _addCamera(camera) {
                this._activeCameras.add(camera);
                this._setCamera(camera);
            }
        }, {
            key: '_removeCamera',
            value: function _removeCamera(camera) {
                this._activeCameras.delete(camera);

                if (this._activeCameras.size) {
                    // get the last camera in the Set
                    this._activeCameras.forEach(function (c) {
                        return camera = c;
                    });
                } else {
                    camera = null;
                }

                this._setCamera(camera);
            }

            /** @override */

        }, {
            key: '_getParentSize',
            value: function _getParentSize() {
                return this._mounted ? this._elementParentSize : { x: 0, y: 0, z: 0 };
            }

            /**
             * Mount the scene into the given target.
             * Resolves the Scene's mountPromise, which can be use to do something once
             * the scene is mounted.
             *
             * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,
             * the mount point will be selected from the DOM. If an HTMLElement is
             * provided, that will be the mount point. If no mount point is provided,
             * the scene will be mounted into document.body.
             */

        }, {
            key: 'mount',
            value: function mount(mountPoint) {
                return new Promise(function ($return, $error) {
                    // Wait for the document to be ready before mounting, otherwise the
                    // target mount point might not exist yet when this function is called.
                    if (document.readyState == 'loading') {
                        return (0, _documentReady2.default)().then(function ($await_3) {
                            try {
                                return $If_1.call(this);
                            } catch ($boundEx) {
                                return $error($boundEx);
                            }
                        }.bind(this), $error);
                    }

                    // if no mountPoint was provided, just mount onto the <body> element.

                    function $If_1() {
                        if (mountPoint === undefined) {
                            mountPoint = document.body;
                        }

                        // if the user supplied a selector, mount there.
                        else if (typeof mountPoint === 'string') {
                                mountPoint = document.querySelector(mountPoint);
                            }

                        // if we have an actual mount point (the user may have supplied one)
                        if (!(mountPoint instanceof HTMLElement)) {
                            return $error(new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.'));
                        }

                        if (this._mounted) {
                            this.unmount();
                        }

                        if (mountPoint !== this.parentNode) {
                            mountPoint.appendChild(this);
                        }

                        this._mounted = true;

                        if (this._mountPromise) {
                            this._resolveMountPromise();
                        }

                        this._elementOperations.shouldRender();
                        this._startOrStopSizePolling();
                        return $return();
                    }

                    return $If_1.call(this);
                }.bind(this));
            }

            /**
             * Unmount the scene from it's mount point. Resets the Scene's
             * mountPromise.
             */

        }, {
            key: 'unmount',
            value: function unmount() {
                if (!this._mounted) {
                    return;
                }

                this._elementOperations.shouldNotRender();
                this._stopSizePolling();

                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                }

                if (this._mountPromise) {
                    this._rejectMountPromise('mountcancel');
                }
                this._resetMountPromise();
            }
        }, {
            key: 'attributeChangedCallback',

            // TODO: generic type system for attributes.
            value: function attributeChangedCallback(attr, oldVal, newVal) {
                return new Promise(function ($return, $error) {
                    (0, _get3.default)(_Scene.prototype.__proto__ || (0, _getPrototypeOf2.default)(_Scene.prototype), 'attributeChangedCallback', this).call(this, attr, oldVal, newVal);

                    // We need to await mountPromise here so that we set values *after*
                    // values are set in initWebGl
                    //
                    // TODO: this needs to be cancelable too, search other codes for
                    // "mountcancel" to see.
                    return this.mountPromise.then(function ($await_4) {
                        try {

                            if (attr == 'backgroundcolor') {
                                this.processClearColorValue(attr, newVal);
                                this._needsToBeRendered();
                            } else if (attr == 'backgroundopacity') {
                                this.processClearAlphaValue(attr, newVal);
                                this._needsToBeRendered();
                            } else if (attr == 'shadowmaptype' || attr == 'shadowmap-type') {
                                this._renderer.setShadowMapType(this, newVal);
                                this._needsToBeRendered();
                            }
                            return $return();
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }.bind(this));
            }
        }, {
            key: 'processClearColorValue',
            value: function processClearColorValue(attr, value) {
                this.processColorValue(value, this, '_glBackgroundColor');
                this._renderer.setClearColor(this, this._glBackgroundColor, this._glBackgroundOpacity);
            }
        }, {
            key: 'processClearAlphaValue',
            value: function processClearAlphaValue(attr, value) {
                this.processNumberValue('_glBackgroundOpacity', value, this);
                this._renderer.setClearAlpha(this, this._glBackgroundOpacity);
            }
        }, {
            key: 'perspective',
            set: function (value) {
                this._perspective = value;
                this._updateCameraPerspective();
                this._updateCameraProjection();
                this._needsToBeRendered();
            },
            get: function () {
                return this._perspective;
            }
        }, {
            key: 'sizeMode',
            set: function (value) {
                (0, _set5.default)(_Scene.prototype.__proto__ || (0, _getPrototypeOf2.default)(_Scene.prototype), 'sizeMode', value, this);
                this._startOrStopSizePolling();
            }
        }], [{
            key: 'defaultElementName',
            get: function () {
                return 'i-scene';
            }
        }, {
            key: '_Class',
            get: function () {
                return Scene;
            }
        }, {
            key: 'observedAttributes',
            get: function () {
                var superAttrs = (0, _get3.default)(_Scene.__proto__ || (0, _getPrototypeOf2.default)(_Scene), 'observedAttributes', this) || [];
                return superAttrs.concat(['backgroundcolor', 'background-color', 'backgroundopacity', 'background-opacity', 'shadowmaptype', 'shadowmap-type']);
            }
        }]);

        return _Scene;
    }((0, _ValueProcessor3.default)(_ImperativeBase2.default.mixin(_Transformable2.default.mixin(base))));

    (0, _defineProperty2.default)(_Scene, _hasInstance2.default, {
        value: function (obj) {
            if (this !== _Scene) {
                return (0, _getPrototypeOf2.default)(_Scene)[_hasInstance2.default].call(this, obj);
            }

            var currentProto = obj;

            while (currentProto) {
                var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = (0, _getPrototypeOf2.default)(currentProto);
            }

            return false;
        }
    });

    _Scene[instanceofSymbol] = true;

    return _Scene;
};

exports.default = Scene = SceneMixin(function () {
    function _class() {
        (0, _classCallCheck3.default)(this, _class);
    }

    return _class;
}());
Scene.mixin = SceneMixin;

// TODO for now, hard-mixin the HTMLInterface class. We'll do this automatically later.
exports.default = Scene = Scene.mixin(_HTMLScene2.default);

exports.default = Scene;