'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _Transformable = require('./Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _Sizeable = require('./Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _ImperativeBase = require('./ImperativeBase');

var _ImperativeBase2 = _interopRequireDefault(_ImperativeBase);

var _XYZValues = require('./XYZValues');

var _XYZValues2 = _interopRequireDefault(_XYZValues);

var _scene = require('../html/scene');

var _scene2 = _interopRequireDefault(_scene);

var _documentReady = require('awaitbox/dom/documentReady');

var _documentReady2 = _interopRequireDefault(_documentReady);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// although Transformable is not used in this file, importing it first prevent
// a cyclical dependeny problem when an App imports Scene before Node (Sizeable
// imports Motor imports Transformable). See:
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem
// TODO: write a test that imports public interfaces in every possible
// permutation to detect circular dependency errors.
(0, _ImperativeBase.initImperativeBase)();

// Scene is Sizeable, which is currently a subset of Transformable.
const ParentClass = _ImperativeBase2.default.mixin(_Sizeable2.default);
var Scene = function (ParentClass) {
    function Scene(options) {
        var this$1 = this;
        if (options === void 0) options = {};

        ParentClass.call(this, options);

        // NOTE: z size is always 0, since native DOM elements are always flat.
        this._elementParentSize = { x: 0, y: 0, z: 0 };

        this._onElementParentSizeChange = function (newSize) {
            this$1._elementParentSize = newSize;
            this$1._calcSize();
            this$1._needsToBeRendered();
        };

        this._calcSize();
        this._needsToBeRendered();
    }

    if (ParentClass) Scene.__proto__ = ParentClass;
    Scene.prototype = Object.create(ParentClass && ParentClass.prototype);
    Scene.prototype.constructor = Scene;

    Scene.prototype._setDefaultProperties = function _setDefaultProperties() {
        ParentClass.prototype._setDefaultProperties.call(this);

        Object.assign(this._properties, {
            sizeMode: new _XYZValues2.default('proportional', 'proportional', 'absolute')
        });
    };

    Scene.prototype._startOrStopSizePolling = function _startOrStopSizePolling() {
        if (this._mounted && (this._properties.sizeMode.x == 'proportional' || this._properties.sizeMode.y == 'proportional' || this._properties.sizeMode.z == 'proportional')) {
            this._startSizePolling();
        } else {
            this._stopSizePolling();
        }
    };

    // observe size changes on the scene element.
    Scene.prototype._startSizePolling = function _startSizePolling() {
        if (!this._elementManager) {
            return;
        }
        this._elementManager.element._startSizePolling();
        this._elementManager.element.on('parentsizechange', this._onElementParentSizeChange);
    };

    // Don't observe size changes on the scene element.
    Scene.prototype._stopSizePolling = function _stopSizePolling() {
        if (!this._elementManager) {
            return;
        }
        this._elementManager.element.off('parentsizechange', this._onElementParentSizeChange);
        this._elementManager.element._stopSizePolling();
    };

    /** @override */
    Scene.prototype._getParentSize = function _getParentSize() {
        return this._mounted ? this._elementParentSize : { x: 0, y: 0, z: 0 };
    };

    /**
     * @override
     */
    Scene.prototype._makeElement = function _makeElement() {
        return new _scene2.default();
    };

    /**
     * Mount the scene into the given target.
     * Resolves the Scene's mountPromise, which can be use to do something once
     * the scene is mounted.
     *
     * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,
     * the mount point will be selected from the DOM. If an HTMLElement is
     * provided, that will be the mount point. If no mount point is provided,
     * the scene will be mounted into document.body.
     */
    Scene.prototype.mount = function mount(mountPoint) {
        var this$1 = this;

        const mountLogic = function () {
            // if no mountPoint was provided, just mount onto the <body> element.
            if (mountPoint === undefined) {
                mountPoint = document.body;
            }

            // if the user supplied a selector, mount there.
            else if (typeof mountPoint === 'string') {
                    mountPoint = document.querySelector(mountPoint);
                }

            // if we have an actual mount point (the user may have supplied one)
            if (!(mountPoint instanceof window.HTMLElement)) {
                throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.');
            }

            if (this$1._mounted) {
                this$1.unmount();
            }

            if (mountPoint !== this$1._elementManager.element.parentNode) {
                mountPoint.appendChild(this$1._elementManager.element);
            }

            this$1._mounted = true;

            if (this$1._mountPromise) {
                this$1._resolveMountPromise();
            }

            this$1._elementManager.shouldRender();
            this$1._startOrStopSizePolling();
        };

        // Wait for the document to be ready before mounting, otherwise the
        // target mount point might not exist yet when this function is called.
        if (document.readyState == 'loading') {
            return (0, _documentReady2.default)().then(mountLogic);
        } else {
            mountLogic();
            return Promise.resolve();
        }
    };
    //async mount(mountPoint) {
    //// Wait for the document to be ready before mounting, otherwise the
    //// target mount point might not exist yet when this function is called.
    //if (document.readyState == 'loading') await documentReady()

    //// if no mountPoint was provided, just mount onto the <body> element.
    //if (mountPoint === undefined) mountPoint = document.body

    //// if the user supplied a selector, mount there.
    //else if (typeof mountPoint === 'string')
    //mountPoint = document.querySelector(mountPoint)

    //// if we have an actual mount point (the user may have supplied one)
    //if (!(mountPoint instanceof window.HTMLElement))
    //throw new Error('Invalid mount point specified in Scene.mount() call. Pass a selector, an actual HTMLElement, or don\'t pass anything to mount to <body>.')

    //if (this._mounted) this.unmount()

    //if (mountPoint !== this._elementManager.element.parentNode)
    //mountPoint.appendChild(this._elementManager.element)

    //this._mounted = true

    //if (this._mountPromise) this._resolveMountPromise()

    //this._elementManager.shouldRender()
    //this._startOrStopSizePolling()
    //}

    /**
     * Unmount the scene from it's mount point. Resets the Scene's
     * mountPromise.
     */
    Scene.prototype.unmount = function unmount() {
        if (!this._mounted) {
            return;
        }

        this._elementManager.shouldNotRender();
        this._stopSizePolling();

        if (this._elementManager.element.parentNode) {
            this._elementManager.element.parentNode.removeChild(this._elementManager.element);
        }

        if (this._mountPromise) {
            this._rejectMountPromise('mountcancel');
        }
        this._resetMountPromise();
    };

    return Scene;
}(ParentClass);

// Here we know that `super` is Sizeable
var ref = Object.getOwnPropertyDescriptor(_Sizeable2.default.prototype, 'sizeMode');
var superSizeModeSet = ref.set;
var superSizeModeGet = ref.get;

Object.defineProperties(Scene.prototype, {

    // When we set the scene's size mode, we should start polling if it has
    // proportional sizing.
    sizeMode: {
        set: function (value) {
            superSizeModeSet.call(this, value);
            this._startOrStopSizePolling();
        },
        get: function () {
            return superSizeModeGet.call(this);
        },
        configurable: true,
        enumerable: true
    }

});

exports.default = Scene;
//# sourceMappingURL=Scene.js.map