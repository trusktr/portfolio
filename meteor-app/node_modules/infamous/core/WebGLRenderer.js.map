{"version":3,"file":"WebGLRenderer.js","sources":["../../src/core/WebGLRenderer.js"],"sourcesContent":["import {\n    createWebGLContext,\n    //removeWebGLContext,\n    setGlResolution,\n    v3,\n    m4,\n    vertShaderSource,\n    fragShaderSource,\n    createShader,\n    createProgram,\n    Cube,\n    Quad,\n    FourSidedPyramid,\n    IsoscelesTriangle,\n    SymmetricTrapezoid,\n} from './webglUtils'\n\nconst updateResolution = state => {\n    const resolution = [\n        parseFloat(getComputedStyle(state.gl.canvas).width) * window.devicePixelRatio,\n        parseFloat(getComputedStyle(state.gl.canvas).height) * window.devicePixelRatio,\n        1000,\n    ]\n\n    setGlResolution(state.gl, ...resolution)\n    state.projectionMatrix = m4.perspective(45, resolution[0] / resolution[1], 1, 2000)\n}\n\nclass WebGlRenderer {\n    /**\n     * Creates the WebGL program for the given scene.\n     */\n    initGl(scene) {\n        const gl = createWebGLContext(scene)\n        const state = scene.webGlRendererState\n        state.gl = gl\n\n        if (!gl) { console.log('You need WebGL.') }\n\n        const vertShader = createShader(gl, gl.VERTEX_SHADER, vertShaderSource)\n        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource)\n        const program = createProgram(gl, vertShader, fragShader)\n        gl.useProgram(program)\n\n\n        state.colorsBuffer = gl.createBuffer()\n        state.colorAttributeLocation = gl.getAttribLocation(program, 'a_color')\n        gl.enableVertexAttribArray(state.colorAttributeLocation)\n\n        state.vertexBuffer = gl.createBuffer()\n        state.vertexAttributeLocation = gl.getAttribLocation(program, \"a_vertexPosition\")\n        gl.enableVertexAttribArray(state.vertexAttributeLocation)\n\n        state.normalsBuffer = gl.createBuffer()\n        state.normalAttributeLocation = gl.getAttribLocation(program, 'a_normal')\n        gl.enableVertexAttribArray(state.normalAttributeLocation)\n\n        state.textureCoordinatesBuffer = gl.createBuffer()\n        state.textureCoordinateLocation = gl.getAttribLocation(program, 'a_textureCoordinate')\n\n        // cull_face doesn't work, because I've drawn my vertices in the wrong\n        // order. They should be clockwise to be front facing (I seem to have done\n        // them counter-clockwise). See \"CULL_FACE\" at\n        // https://webglfundamentals.org/webgl/lessons/webgl-3d-orthographic.html\n        //gl.enable(gl.CULL_FACE)\n\n        // enables depth sorting, so pixels aren't drawn in order of appearance, but order only if they are visible (on top of other pixels).\n        gl.enable(gl.DEPTH_TEST)\n\n        // enable alpha blending (transparency)\n        // XXX: For blending (transparency) to work, we have to disable depth testing.\n        // TODO: Maybe we have to selectively enable depth testing and disable\n        // blending, or vice versa, depending on the object we want to draw...\n        // ...Or perhaps we must draw things in a certain order, from back to front,\n        // so we can have depth testing AND blending at the same time.\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE)\n        gl.enable(gl.BLEND)\n        //gl.disable(gl.DEPTH_TEST)\n\n        state.projectionMatrix = m4.identity\n\n        updateResolution(state)\n        scene.on('parentsizechange', () => updateResolution(state))\n\n        state.worldViewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_worldViewProjectionMatrix')\n        //const worldInverseTransposeMatrixLocation = gl.getUniformLocation(program, 'u_worldInverseTransposeMatrix')\n        state.worldMatrixLocation = gl.getUniformLocation(program, 'u_worldMatrix')\n        //const reverseLightDirectionLocation = gl.getUniformLocation(program, 'reverseLightDirection')\n        //gl.uniform3fv(reverseLightDirectionLocation, v3.normalize([0.5, 0.7, 1]))\n        state.lightWorldPositionLocation = gl.getUniformLocation(program, 'u_lightWorldPosition')\n        state.cameraWorldPositionLocation = gl.getUniformLocation(program, 'u_cameraWorldPosition')\n        const shininessLocation = gl.getUniformLocation(program, 'u_shininess')\n        const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor')\n        const specularColorLocation = gl.getUniformLocation(program, 'u_specularColor')\n        state.textureLocation = gl.getUniformLocation(program, 'u_texture')\n        state.hasTextureLocation = gl.getUniformLocation(program, 'u_hasTexture')\n\n        let shininess = 200\n        gl.uniform1f(shininessLocation, shininess)\n\n        const red = [1, 0.6, 0.6]\n        const white = [1, 1, 1]\n\n        let lightColor = white\n        gl.uniform3fv(lightColorLocation, v3.normalize(lightColor))\n\n        let specularColor = white\n        gl.uniform3fv(specularColorLocation, v3.normalize(specularColor))\n\n\n        state.lightAnimParam = 0\n        state.lightWorldPosition = [20,30,50]\n        state.cameraAngle = 0\n        state.cameraRadius   = 200\n    }\n\n    drawScene(scene) {\n        const state = scene.webGlRendererState\n        const {gl} = state\n\n        // TODO: light does not affect the back side of polygons?...\n        state.lightAnimParam += 0.05\n        state.lightWorldPosition = [\n            300*Math.sin(state.lightAnimParam),\n            300*Math.sin(state.lightAnimParam*2),\n\n            Math.abs(300*Math.cos(state.lightAnimParam))\n            //300\n        ]\n\n        gl.uniform3fv(state.lightWorldPositionLocation, state.lightWorldPosition)\n\n        let backgroundColor = scene.getAttribute('background')\n\n        if (typeof backgroundColor == 'string')\n            backgroundColor = backgroundColor.split(' ').map(rgbPart => parseFloat(rgbPart))\n        else\n            backgroundColor = [0, 0, 0, 0]\n\n        gl.clearColor(...backgroundColor)\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // why do we need to do this?\n\n        //state.cameraAngle++\n        let cameraMatrix  = m4.identity\n        cameraMatrix      = m4.multiply(cameraMatrix, m4.yRotation(state.cameraAngle))\n        cameraMatrix      = m4.multiply(cameraMatrix, m4.translation(0, 0, state.cameraRadius * 1.5))\n        const viewMatrix  = m4.inverse(cameraMatrix)\n\n        state.viewProjectionMatrix = m4.multiply(state.projectionMatrix, viewMatrix)\n\n        const cameraWorldPosition = [cameraMatrix[12], cameraMatrix[13], cameraMatrix[14]]\n        gl.uniform3fv(state.cameraWorldPositionLocation, cameraWorldPosition)\n\n        // TODO: we need to use the traversal that takes into consideration ShadowDOM.\n        const children = scene.imperativeCounterpart._children\n        for (let i=0, l=children.length; i<l; i+=1) {\n            this.drawNodeAndRecurse(state, children[i])\n        }\n    }\n\n    drawNodeAndRecurse(state, node) {\n        const {gl} = state\n\n        const meshAttr = node.element.getAttribute('mesh')\n\n        if (meshAttr) {\n            const size = node._calculatedSize\n\n            const svgElement = Array.from(node.element.children)\n                .find(child => child instanceof SVGSVGElement)\n\n            const hasTexture = !!svgElement\n\n            if (meshAttr == 'cube') {\n                if (!(node.__shape instanceof Cube))\n                    node.__shape = new Cube(0, 0, size.x)\n                // TODO else, like quad or symtrap\n            }\n            else if (meshAttr == 'quad') {\n                if (!(node.__shape instanceof Quad))\n                    node.__shape = new Quad(size.x, size.y)\n                else {\n                    node.__shape.width = size.x\n                    node.__shape.height = size.y\n                    node.__shape._calcVerts()\n                }\n\n                if (hasTexture) {\n\n                    // TODO we would create one per Geometry (and eventually multiple per\n                    // geometry), but for now just one texture for all quads to get it working.\n                    // TODO Make the texture only once, not each tick.\n                    if (!node.__texture) {\n\n                        // XXX this will eventually be set with a texture map feature\n                        // TODO: for now, we should at least set default\n                        // coordinates for each geometry, even if that's not\n                        // ideal; it's more ideal than nothing.\n                        node.__shape.textureCoordinates = new Float32Array([\n                            0, 0,\n                            1, 0,\n                            1, 1,\n                            1, 1,\n                            0, 1,\n                            0, 0,\n                        ])\n\n                        node.__texture = gl.createTexture()\n                    }\n\n                    ///// SVG TEXTURE FROM TWO.JS {\n                    if (!node.__two) {\n                        node.__two = new Two({\n                            type: Two.Types.webgl,\n                            fullscreen: false,\n                            autostart: false,\n                        })\n\n                        node.__two.interpret(svgElement)\n                    }\n\n                    node.__two.update()\n\n                    const image = node.__two.renderer.domElement\n                    const isPowerOf2 = value => (value & (value - 1)) == 0\n\n                    // copy the pixi canvas image to the texture.\n                    gl.bindTexture(gl.TEXTURE_2D, node.__texture)\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)\n\n                    // TODO: unbind from buffers and textures when done\n                    // using them, to prevent modification from outside\n\n                    // Mip maps can only be generated on images whose width and height are a power of 2.\n                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n                        gl.generateMipmap(gl.TEXTURE_2D)\n                        // TODO make filters configurable?\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)\n\n                        // Using just NEAREST or LINEAR only can increase performance, for example.\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                    }\n                    else {\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n                        // TODO make filters configurable?\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                    }\n                    ///// }\n\n                    ///// SVG TEXTURE FROM PIXI-SVG {\n                    //if (!node.__pixiRenderer) {\n                        //node.__pixiRenderer = PIXI.autoDetectRenderer({\n\n                            //width: node._calculatedSize.x * window.devicePixelRatio,\n                            //height: node._calculatedSize.y * window.devicePixelRatio,\n                            ////width: 300 * window.devicePixelRatio,\n                            ////height: 300 * window.devicePixelRatio,\n\n                            //resolution: window.devicePixelRatio,\n                        //});\n\n                        //node.__pixiStage = new PIXI.Container()\n                        //window.stage = node.__pixiStage\n                    //}\n\n                    //node.__pixiStage.removeChild(node.__svgGraphic)\n\n                    //node.__svgGraphic = new SVG(svgElement)\n\n                    //node.__pixiStage.addChild(node.__svgGraphic)\n\n                    //node.__pixiRenderer.render(node.__pixiStage);\n\n                    //const image = node.__pixiRenderer.view\n                    //const isPowerOf2 = value => (value & (value - 1)) == 0\n\n                    //// copy the pixi canvas image to the texture.\n                    //gl.bindTexture(gl.TEXTURE_2D, node.__texture)\n                    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)\n\n                    //// TODO: unbind from buffers and textures when done\n                    //// using them, to prevent modification from outside\n\n                    //// Mip maps can only be generated on images whose width and height are a power of 2.\n                    //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n                        //gl.generateMipmap(gl.TEXTURE_2D)\n                        //// TODO make filters configurable?\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)\n\n                        //// Using just NEAREST or LINEAR only can increase performance, for example.\n                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                    //}\n                    //else {\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n                        //// TODO make filters configurable?\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                    //}\n\n                    ///// }\n\n                    ///// PRE-DEFINED TEXTURE FROM IMAGE {\n\n                    //// set a temporary solid color texture for the meantime\n                    //// while the following texture loads.\n                    //gl.bindTexture(gl.TEXTURE_2D, node.__texture)\n                    //// Fill the texture with a 1x1 blue pixel to start with.\n                    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]))\n                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n                    //const image = new Image\n                    //const isPowerOf2 = value => (value & (value - 1)) == 0\n                    //image.addEventListener('load', () => {\n                        //// Now that the image has loaded copy it to the texture.\n                        //gl.bindTexture(gl.TEXTURE_2D, node.__texture)\n                        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image)\n\n                        //// TODO: unbind from buffers and textures when done\n                        //// using them, to prevent modification from outside\n\n                        //// Mip maps can only be generated on images whose width and height are a power of 2.\n                        //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n                            //gl.generateMipmap(gl.TEXTURE_2D)\n                            //// TODO make filters configurable?\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)\n\n                            //// Using just NEAREST or LINEAR only can increase performance, for example.\n                            ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                            ////gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                        //}\n                        //else {\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n                            //// TODO make filters configurable?\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n                            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n                        //}\n                    //})\n                    //image.src = imageUrl // imageUrl should be a data URL\n                    //// }\n                }\n            }\n            else if (meshAttr == 'isotriangle') {\n                if (!(node.__shape instanceof IsoscelesTriangle))\n                    node.__shape = new IsoscelesTriangle(size.x, size.y)\n                // TODO else, like quad or symtrap\n            }\n            else if (meshAttr == 'pyramid4') {\n                if (!(node.__shape instanceof FourSidedPyramid))\n                    node.__shape = new FourSidedPyramid(size.x, size.y)\n                // TODO else, like quad or symtrap\n            }\n            else if (meshAttr == 'symtrap') {\n                if (!(node.__shape instanceof SymmetricTrapezoid))\n                    node.__shape = new SymmetricTrapezoid(size.x/2, size.x, size.y)\n                else {\n                    node.__shape.baseWidth = size.x/2\n                    node.__shape.topWidth = size.x\n                    node.__shape.height = size.y\n                    node.__shape._calcVerts()\n                }\n            }\n            //else node.__shape = null\n            else {\n                if (!(node.__shape instanceof Quad))\n                    node.__shape = new Quad(size.x, size.y)\n                else {\n                    node.__shape.width = size.x\n                    node.__shape.height = size.y\n                    node.__shape._calcVerts()\n                }\n                // TODO this will eventually be set with a texture map feature\n                if (hasTexture) {\n                    node.__shape.textureCoordinates = new Float32Array([\n                        0, 0,\n                        1, 0,\n                        1, 1,\n                        1, 1,\n                        0, 1,\n                        0, 0,\n                    ])\n                }\n            }\n\n            if (node.__shape) {\n                // COLORS /////////////////////////////////\n                node.__shape.color = node.element.getAttribute('color')\n\n                gl.bindBuffer(gl.ARRAY_BUFFER, state.colorsBuffer)\n                gl.bufferData(gl.ARRAY_BUFFER, node.__shape._colors, gl.STATIC_DRAW)\n\n                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)\n                const colorSize = 4          // components per iteration\n                const colorType = gl.FLOAT\n                const normalizeColorData = false // don't normalize the data\n                const colorStride = 0        // 0 = move forward colorSize * sizeof(colorType) each iteration to get the next vertex\n                const colorOffset = 0        // start at the beginning of the buffer\n                gl.vertexAttribPointer(\n                    state.colorAttributeLocation, colorSize, colorType, normalizeColorData, colorStride, colorOffset)\n\n                // VERTICES /////////////////////////////////\n                gl.bindBuffer(gl.ARRAY_BUFFER, state.vertexBuffer)\n                gl.bufferData(gl.ARRAY_BUFFER, node.__shape.verts, gl.STATIC_DRAW)\n\n                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)\n                const vertexSize = 3          // components per iteration\n                const type = gl.FLOAT\n                const normalizeVertexData = false // don't normalize the data\n                const stride = 0        // 0 = move forward vertexSize * sizeof(type) each iteration to get the next vertex\n                const offset = 0        // start at the beginning of the buffer\n                gl.vertexAttribPointer(\n                    state.vertexAttributeLocation, vertexSize, type, normalizeVertexData, stride, offset)\n\n                // NORMALS /////////////////////////////////\n                gl.bindBuffer(gl.ARRAY_BUFFER, state.normalsBuffer)\n                gl.bufferData(gl.ARRAY_BUFFER, node.__shape.normals, gl.STATIC_DRAW)\n\n                // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)\n                const normalSize = 3          // components per iteration\n                const normalType = gl.FLOAT\n                const normalizeNormalsData = false // don't normalize the data\n                const normalStride = 0        // 0 = move forward normalSize * sizeof(normalType) each iteration to get the next vertex\n                const normalOffset = 0        // start at the beginning of the buffer\n                gl.vertexAttribPointer(\n                    state.normalAttributeLocation, normalSize, normalType, normalizeNormalsData, normalStride, normalOffset)\n\n                // TEXTURE COORDINATES /////////////////////////////////\n                if (hasTexture) {\n                    gl.uniform1i(state.hasTextureLocation, +true)\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, state.textureCoordinatesBuffer)\n                    gl.bufferData(gl.ARRAY_BUFFER, node.__shape.textureCoordinates, gl.STATIC_DRAW)\n\n                    // Tell the attribute how to get data out of vertexBuffer (ARRAY_BUFFER)\n                    const textureCoordinateSize = 2          // components per iteration\n                    const textureCoordinateType = gl.FLOAT\n                    const normalizeTextureCoordinateData = false // don't normalize the data\n                    const textureCoordinateStride = 0        // 0 = move forward textureCoordinateSize * sizeof(textureCoordinateType) each iteration to get the next vertex\n                    const textureCoordinateOffset = 0        // start at the beginning of the buffer\n                    gl.enableVertexAttribArray(state.textureCoordinateLocation)\n                    gl.vertexAttribPointer(\n                        state.textureCoordinateLocation, textureCoordinateSize, textureCoordinateType, normalizeTextureCoordinateData, textureCoordinateStride, textureCoordinateOffset)\n\n                    // Tell the shader to use texture unit 0 for u_texture\n                    // TODO: Get index of the node's texture, but right now there's only one texture.\n                    gl.uniform1i(state.textureLocation, 0)\n                }\n                else {\n                    gl.uniform1i(state.hasTextureLocation, +false)\n                    gl.disableVertexAttribArray(state.textureCoordinateLocation)\n                }\n\n                // TRANFORMS /////////////////////////////////\n                gl.uniformMatrix4fv(state.worldMatrixLocation, false, node._worldMatrix.toFloat32Array())\n\n                // for correct lighting normals\n                // TODO: waiting for transpose() method on DOMMatrix\n                //const worldInverseTransposeMatrix = m4.transpose(m4.inverse(node._worldMatrix))\n                //gl.uniformMatrix4fv(worldInverseTransposeMatrixLocation, false, worldInverseTransposeMatrix)\n\n                const worldViewProjectionMatrix = m4.multiply(state.viewProjectionMatrix, node._worldMatrix.toFloat32Array())\n                gl.uniformMatrix4fv(state.worldViewProjectionMatrixLocation, false, worldViewProjectionMatrix)\n\n                const count = node.__shape.verts.length / 3\n                gl.drawArrays(gl.TRIANGLES, offset, count)\n            }\n        }\n\n        const children = node._children\n        for (let i=0, l=children.length; i<l; i+=1) {\n            this.drawNodeAndRecurse(state, children[i])\n        }\n    }\n}\n\nlet instance = null\n\nexport default\nfunction getWebGlRenderer() {\n    if (instance) return instance\n    else return instance = new WebGlRenderer\n}\n"],"names":[],"mappings":"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"}