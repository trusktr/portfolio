'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _documentReady = require('@awaitbox/document-ready');

var _documentReady2 = _interopRequireDefault(_documentReady);

var _Transformable = require('./Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _WebGLRendererThree = require('./WebGLRendererThree');

var _Utility = require('./Utility');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var documentIsReady = false;

// TODO use Array if IE11 doesn't have Map.
var webGLRenderers = new _map2.default();

var Motor = function () {
    function Motor() {
        (0, _classCallCheck3.default)(this, Motor);

        this._inFrame = false; // true when inside a requested animation frame.
        this._rAF = null; // the current animation frame, or null.
        this._animationLoopStarted = false;
        this._allRenderTasks = [];
        this._taskIterationIndex = 0;
        this._numberOfTasks = 0;
        this._nodesToBeRendered = [];
        this._modifiedScenes = [];

        // A set of nodes that are the root nodes of subtrees where all nodes
        // in each subtree need to have their world matrices updated.
        this._worldMatrixRootNodes = [];
    }

    /**
     * Starts an rAF loop and runs the render tasks in the _renderTasks stack.
     * As long as there are tasks in the stack, the loop continues. When the
     * stack becomes empty due to removal of tasks, the rAF stops and the app
     * sits there doing nothing -- silence, crickets.
     */

    (0, _createClass3.default)(Motor, [{
        key: '_startAnimationLoop',
        value: function _startAnimationLoop() {
            return new Promise(function ($return, $error) {
                var motorLoop;

                if (this._animationLoopStarted) {
                    return $return();
                }

                this._animationLoopStarted = true;

                if (!documentIsReady) {
                    return (0, _documentReady2.default)().then(function ($await_2) {
                        try {
                            documentIsReady = true;
                            return $If_1.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }

                // DIRECT ANIMATION LOOP ///////////////////////////////////
                // So now we can render after the scene is mounted.

                function $If_1() {
                    var this$1 = this;

                    motorLoop = function (timestamp) {
                        this$1._inFrame = true;

                        this$1._runRenderTasks(timestamp);
                        this$1._renderNodes(timestamp);

                        // If any tasks are left to run, continue the animation loop.
                        if (this$1._allRenderTasks.length) {
                            this$1._rAF = requestAnimationFrame(motorLoop);
                        } else {
                            this$1._rAF = null;
                            this$1._animationLoopStarted = false;
                        }

                        this$1._inFrame = false;
                    };

                    this._rAF = requestAnimationFrame(motorLoop);
                    return $return();
                }

                return $If_1.call(this);
            }.bind(this));
        }
        //async _startAnimationLoop() {
        //if (this._animationLoopStarted) return

        //this._animationLoopStarted = true

        //if (!documentIsReady) {
        //await documentReady()
        //documentIsReady = true
        //}

        //// ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////
        //this._rAF = true
        //let timestamp = null
        //while (this._rAF) {
        //timestamp = await animationFrame()
        //this._inFrame = true

        //this._runRenderTasks(timestamp)
        //this._renderNodes(timestamp)

        //// If any tasks are left to run, continue the animation loop.
        //if (!this._allRenderTasks.length) {
        //this._rAF = null
        //this._animationLoopStarted = false
        //}

        //this._inFrame = false
        //}
        //}

        /**
         * When a render tasks is added a new rAF loop will be started if there
         * isn't one currently.
         *
         * A render task is simply a function that will be called over and over
         * again, in the Motor's animation loop. That's all, nothing special.
         * However, if a Node setter is used inside of a render task, then the Node
         * will tell Motor that it needs to be re-rendered, which will happen at
         * the end of the current frame. If a Node setter is used outside of a
         * render task (i.e. outside of the Motor's animation loop), then the Node
         * tells Motor to re-render the Node on the next animation loop tick.
         * Basically, regardless of where the Node's setters are used (inside or
         * outside of the Motor's animation loop), rendering always happens inside
         * the loop.
         *
         * @param {Function} fn The render task to add.
         * @return {Function} A reference to the render task. Useful for saving to
         * a variable so that it can later be passed to Motor.removeRenderTask().
         */

    }, {
        key: 'addRenderTask',
        value: function addRenderTask(fn) {
            if (typeof fn != 'function') {
                throw new Error('Render task must be a function.');
            }

            if (this._allRenderTasks.indexOf(fn) !== -1) {
                return;
            }

            this._allRenderTasks.push(fn);
            this._numberOfTasks += 1;

            // If the render loop isn't started, start it.
            if (!this._animationLoopStarted) {
                this._startAnimationLoop();
            }

            return fn;
        }
    }, {
        key: 'removeRenderTask',
        value: function removeRenderTask(fn) {
            var taskIndex = this._allRenderTasks.indexOf(fn);

            if (taskIndex == -1) {
                return;
            }

            this._allRenderTasks.splice(taskIndex, 1);
            this._numberOfTasks -= 1;
            this._taskIterationIndex -= 1;
        }
    }, {
        key: '_runRenderTasks',
        value: function _runRenderTasks(timestamp) {
            var this$1 = this;

            for (this._taskIterationIndex = 0; this._taskIterationIndex < this._numberOfTasks; this._taskIterationIndex += 1) {
                var task = this$1._allRenderTasks[this$1._taskIterationIndex];

                if (task(timestamp) === false) {
                    this$1.removeRenderTask(task);
                }
            }
        }
    }, {
        key: '_setNodeToBeRendered',
        value: function _setNodeToBeRendered(node) {
            if (this._nodesToBeRendered.indexOf(node) !== -1) {
                return;
            }
            this._nodesToBeRendered.push(node);
            if (!this._inFrame) {
                this._startAnimationLoop();
            }
        }
    }, {
        key: '_renderNodes',
        value: function _renderNodes(timestamp) {
            var this$1 = this;

            if (!this._nodesToBeRendered.length) {
                return;
            }

            for (var i = 0, l = this._nodesToBeRendered.length; i < l; i += 1) {
                var node = this$1._nodesToBeRendered[i];

                node._render(timestamp);

                // If the node is root of a subtree containing updated nodes and
                // has no ancestors that were modified, then add it to the
                // _worldMatrixRootNodes set so we can update the world matrices of
                // all the nodes in the root node's subtree.
                if (
                // a node could be a Scene, which is not Transformable
                (0, _Utility.isInstanceof)(node, _Transformable2.default) &&

                // and if ancestor is not instanceof Transformable, f.e.
                // `false` if there is no ancestor that should be rendered or
                // no Transformable parent which means the current node is the
                // root node
                !(0, _Utility.isInstanceof)(node._getAncestorThatShouldBeRendered(), _Transformable2.default) &&

                // and the node isn't already added.
                !(this$1._worldMatrixRootNodes.indexOf(node) !== -1)) {
                    this$1._worldMatrixRootNodes.push(node);
                }

                // keep track of which scenes are modified so we can render webgl
                // only for those scenes.
                // TODO FIXME: at this point, a node should always have a scene,
                // otherwise it should not ever be rendered here, but turns out
                // some nodes are getting into this queue without a scene. We
                // shouldn't need the conditional check for node._scene, and it
                // will save CPU by not allowing the code to get here in that case.
                // UPDATE: it may be because we're using `node._scene` which is
                // null unless `node.scene` was first used. Maybe we just need to
                // use `node.scene`.
                if (node._scene && !(this$1._modifiedScenes.indexOf(node._scene) !== -1)) {
                    this$1._modifiedScenes.push(node._scene);
                }
            }

            // Update world matrices of the subtrees.
            var worldMatrixRootNodes = this._worldMatrixRootNodes;
            for (var i$1 = 0, l$1 = worldMatrixRootNodes.length; i$1 < l$1; i$1 += 1) {
                worldMatrixRootNodes[i$1]._calculateWorldMatricesInSubtree();
            }
            worldMatrixRootNodes.length = 0;

            // render webgl of modified scenes.
            // TODO PERFORMANCE: store a list of webgl-enabled modified scenes, and
            // iterate only through those so we don't iterate over non-webgl
            // scenes.
            var modifiedScenes = this._modifiedScenes;
            for (var i$2 = 0, l$2 = modifiedScenes.length; i$2 < l$2; i$2 += 1) {
                var scene = modifiedScenes[i$2];
                if (scene.webglEnabled) {
                    webGLRenderers.get(scene).drawScene(scene);
                }
            }
            modifiedScenes.length = 0;

            var nodesToBeRendered = this._nodesToBeRendered;
            for (var i$3 = 0, l$3 = nodesToBeRendered.length; i$3 < l$3; i$3 += 1) {
                nodesToBeRendered[i$3]._willBeRendered = false;
            }
            nodesToBeRendered.length = 0;
        }

        // in the future we might have "babylon", "playcanvas", etc, on a
        // per scene basis.

    }, {
        key: 'getWebGLRenderer',
        value: function getWebGLRenderer(scene, type) {
            if (webGLRenderers.has(scene)) {
                return webGLRenderers.get(scene);
            }

            var rendererGetter = null;

            if (type === "three") {
                rendererGetter = _WebGLRendererThree.getWebGLRendererThree;
            } else {
                throw new Error('invalid WebGL renderer');
            }

            var renderer = rendererGetter(scene);
            webGLRenderers.set(scene, renderer);
            renderer.initGl(scene);

            return renderer;
        }
    }]);

    return Motor;
}();

// export a singleton instance rather than the class directly.


exports.default = new Motor();