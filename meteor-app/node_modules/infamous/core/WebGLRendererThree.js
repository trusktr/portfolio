'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getWebGLRendererThree = getWebGLRendererThree;
exports.destroyWebGLRendererThree = destroyWebGLRendererThree;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sceneStates = new _weakMap2.default();

// A singleton responsible for setting up and drawing a WebGL scene for a given
// infamous/core/Scene using Three.js

var WebGLRendererThree = function () {
    function WebGLRendererThree() {
        (0, _classCallCheck3.default)(this, WebGLRendererThree);
    }

    (0, _createClass3.default)(WebGLRendererThree, [{
        key: 'initGl',
        value: function initGl(scene) {
            var this$1 = this;

            var sceneState = sceneStates.has(scene);

            if (sceneState) {
                sceneState = sceneStates.get(scene);
            } else {
                sceneStates.set(scene, sceneState = {
                    // TODO: get the active camera from the scene
                    //camera: new PerspectiveCamera( 75, 16/9, 0.1, 1000 ),

                    // TODO: options controlled by HTML attributes on scene elements.
                    renderer: new _three.WebGLRenderer({
                        // TODO: how do we change alpha:true to alpha:false after the
                        // fact?
                        alpha: true,

                        antialias: true
                    })
                });
            }

            var renderer = sceneState.renderer;

            // TODO: make configurable by property/attribute
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = _three.PCFSoftShadowMap; // default PCFShadowMap

            this.updateResolution(scene);
            scene.on('sizechange', function () {
                return this$1.updateResolution(scene);
            });

            // TODO? Maybe the html/scene.js element should be responsible for
            // making this, so that DOM logic is encapsulated there?
            scene._canvasContainer.appendChild(renderer.domElement);
        }
    }, {
        key: 'drawScene',
        value: function drawScene(scene) {
            var ref = sceneStates.get(scene);
            var renderer = ref.renderer;
            renderer.render(scene.threeObject3d, scene.threeCamera);
        }

        // TODO FIXME This is tied to the `sizechange` event of Scene, which means
        // camera and renderer resize happens outside of the animation loop, but as
        // with _calcSize, we want to see if we can put this in the nimation loop
        // as well. Putting this logic in the loop depends on putting _calcSize in
        // the loop. #66

    }, {
        key: 'updateResolution',
        value: function updateResolution(scene) {
            var state = sceneStates.get(scene);

            scene._updateCameraAspect();
            scene._updateCameraPerspective();
            scene._updateCameraProjection();

            state.renderer.setSize(scene._calculatedSize.x, scene._calculatedSize.y);

            // Indirectly causes Motor to call this.drawScene(). It's important to
            // call this rather than just this.drawScene() directly because Motor
            // will make sure it runs in an animation frame.
            scene._needsToBeRendered();
        }
    }, {
        key: 'setClearColor',
        value: function setClearColor(scene, color, opacity) {
            sceneStates.get(scene).renderer.setClearColor(color, opacity);
        }
    }, {
        key: 'setClearAlpha',
        value: function setClearAlpha(scene, opacity) {
            sceneStates.get(scene).renderer.setClearAlpha(opacity);
        }
    }, {
        key: 'setShadowMapType',
        value: function setShadowMapType(scene, type) {
            type = type.toLowerCase();

            if (type == 'pcf') {
                sceneStates.get(scene).renderer.shadowMap.type = _three.PCFShadowMap;
            } else if (type == 'pcfsoft') {
                sceneStates.get(scene).renderer.shadowMap.type = _three.PCFSoftShadowMap;
            } else if (type == 'basic') {
                sceneStates.get(scene).renderer.shadowMap.type = _three.BasicShadowMap;
            } else {
                // default
                sceneStates.get(scene).renderer.shadowMap.type = _three.PCFShadowMap;
            }
        }
    }]);

    return WebGLRendererThree;
}();

var instance = null;

function getWebGLRendererThree(scene) {
    if (instance) {
        return instance;
    } else {
        return instance = new WebGLRendererThree();
    }
}

function destroyWebGLRendererThree() {
    instance = null;
}