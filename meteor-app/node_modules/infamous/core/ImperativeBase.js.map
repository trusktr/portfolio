{"version":3,"file":"ImperativeBase.js","sources":["../../src/core/ImperativeBase.js"],"sourcesContent":["import ElementManager from './ElementManager'\nimport Sizeable from './Sizeable'\nimport Node from './Node'\nimport Scene from './Scene'\nimport Motor from './Motor'\nimport {isInstanceof} from './Utility'\n\n// We explicitly use `var` instead of `let` here because it is hoisted for the\n// Node and Scene modules. This, along with the following initImperativeBase\n// function, allows the circular dependency between this module and the Node and\n// Scene modules to work. For details on why, see\n// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem.\nvar ImperativeBase\n\n// Here we wrap the definition of the ImperativeBase class with this function in\n// order to solve the circular depdendency problem caused by the\n// Node<->ImperativeBase and Scene<->ImperativeBase circles. The Node and Scene\n// modules call initImperativeBase to ensure that the ImperativeBase declaration\n// happens first, and then those modules can use the live binding in their\n// declarations.\ninitImperativeBase()\nexport function initImperativeBase() {\n    if (ImperativeBase) return\n\n    const instanceofSymbol = Symbol('instanceofSymbol')\n\n    /**\n     * The ImperativeBase class is the base class for the Imperative version of the\n     * API, for people who chose to take the all-JavaScript approach and who will\n     * not use the HTML-based API (infamous/motor-html).\n     *\n     * In the future when there is an option to disable the HTML-DOM rendering (and\n     * render only WebGL, for example) then the imperative API will be the only API\n     * available since the HTML API will be turned off as a result of disabling\n     * HTML rendering. Disabling both WebGL and HTML won't make sense, as we'll need\n     * at least one of those to render with.\n     */\n    const ImperativeBaseMixin = base => {\n        const ParentClass = base\n        class ImperativeBase extends ParentClass {\n            constructor(options = {}) {\n\n                // The presence of a _motorHtmlCounterpart argument signifies that\n                // the HTML interface is being used, otherwise the imperative interface\n                // here is being used. For example, see MotorHTMLNode. This means the\n                // Node and MotorHTMLNode classes are coupled together, but it's in the\n                // name of the API that we're supporting.\n                const {_motorHtmlCounterpart} = options\n\n                super(options)\n\n                this._willBeRendered = false\n\n                // Here we create the DOM HTMLElement associated with this\n                // Imperative-API Node.\n                this._elementManager = new ElementManager(\n                    _motorHtmlCounterpart || this._makeElement()\n                )\n                this._elementManager.element._associateImperativeNode(this)\n\n                // For Nodes, true when this Node is added to a parent AND it\n                // has an anancestor Scene that is mounted into DOM. For\n                // Scenes, true when mounted into DOM.\n                this._mounted = false;\n\n                // For Nodes, a promise that resolves when this Node is\n                // attached to a tree that has a root Scene TreeNode *and* when\n                // that root Scene has been mounted into the DOM. For Scenes,\n                // resolves when mounted into DOM.\n                this._mountPromise = null\n                this._resolveMountPromise = null\n                this._rejectMountPromise = null\n\n                this._awaitingMountPromiseToRender = false\n                this._waitingForMountConditions = false\n\n                // See Transformable/Sizeable propertychange event.\n                this.on('propertychange', prop => {\n                    if (\n                        prop == 'sizeMode' ||\n                        prop == 'absoluteSize' ||\n                        prop == 'proportionalSize'\n                    ) {\n                        this._calcSize()\n                    }\n\n                    this._needsToBeRendered()\n                })\n            }\n\n            /**\n             * Subclasses are required to override this. It should return the HTML-API\n             * counterpart for this Imperative-API instance. See Node or Scene classes\n             * for example.\n             *\n             * @private\n             */\n            _makeElement() {\n                throw new Error('Subclasses need to override ImperativeBase#_makeElement.')\n            }\n\n            /**\n             * @readonly\n             */\n            get mountPromise() {\n                if (!this._mountPromise) {\n                    this._mountPromise = new Promise((resolve, reject) => {\n                        this._resolveMountPromise = resolve\n                        this._rejectMountPromise = reject\n                    })\n                }\n\n                if (!this._mounted)\n                    this._waitForMountThenResolveMountPromise()\n                else if (this._mounted)\n                    this._resolveMountPromise()\n\n                return this._mountPromise\n            }\n\n            _waitForMountThenResolveMountPromise() {\n                // extended in Node or Scene to await for anything that mount\n                // depends on.\n            }\n\n            /**\n             * @readonly\n             */\n            get element() {\n                return this._elementManager.element\n            }\n\n            /**\n             * @override\n             */\n            addChild(childNode) {\n                if (!isInstanceof(childNode, ImperativeBase)) return\n\n                // We cannot add Scenes to Nodes, for now.\n                if (childNode instanceof Scene) {\n                    throw new Error(`\n                        A Scene cannot be added to another Node or Scene (at\n                        least for now). To place a Scene in a Node, just mount\n                        a new Scene onto a MotorHTMLNode with Scene.mount().\n                    `)\n                }\n\n                super.addChild(childNode)\n\n                // Pass this parent node's Scene reference (if any, checking this cache\n                // first) to the new child and the child's children.\n                if (childNode._scene || childNode.scene) {\n                    if (childNode._resolveScenePromise)\n                        childNode._resolveScenePromise(childNode._scene)\n                    childNode._giveSceneRefToChildren()\n                }\n\n                // Calculate sizing because proportional size might depend on\n                // the new parent.\n                childNode._calcSize()\n                childNode._needsToBeRendered()\n\n                // child should watch the parent for size changes.\n                this.on('sizechange', childNode._onParentSizeChange)\n\n                this._elementManager.connectChildElement(childNode)\n\n                return this\n            }\n\n            removeChild(childNode, /*private use*/leaveInDom) {\n                if (!(childNode instanceof Node)) return\n\n                super.removeChild(childNode)\n\n                this.off('sizechange', childNode._onParentSizeChange)\n\n                childNode._resetSceneRef()\n\n                if (childNode._mountPromise) childNode._rejectMountPromise('mountcancel')\n                if (childNode._mounted) childNode._elementManager.shouldNotRender()\n                childNode._resetMountPromise()\n\n                if (!leaveInDom)\n                    this._elementManager.disconnectChildElement(childNode)\n            }\n\n            _resetMountPromise() {\n                this._mounted = false\n                this._mountPromise = null\n                this._resolveMountPromise = null\n                this._rejectMountPromise = null\n                const children = this._children\n                for (let i=0, l=children.length; i<l; i+=1) {\n                    children[i]._resetMountPromise();\n                }\n            }\n\n            _needsToBeRendered() {\n                if (this._awaitingMountPromiseToRender) return Promise.resolve()\n\n                const logic = () => {\n                    this._willBeRendered = true\n                    Motor._setNodeToBeRendered(this)\n                }\n\n                if (!this._mounted) {\n                    this._awaitingMountPromiseToRender = true\n\n                    let possibleError = undefined\n\n                    // try\n                    return this.mountPromise\n\n                    .then(logic)\n\n                    // catch\n                    .catch(() => {\n                        if (e == 'mountcancel') return\n                        else possibleError = e\n                    })\n\n                    // finally\n                    .then(() => {\n                        this._awaitingMountPromiseToRender = false\n\n                        if (possibleError) throw possibleError\n                    })\n                }\n\n                logic()\n                return Promise.resolve()\n            }\n            //async _needsToBeRendered() {\n                //if (this._awaitingMountPromiseToRender) return\n\n                //if (!this._mounted) {\n                    //try {\n                        //this._awaitingMountPromiseToRender = true\n                        //await this.mountPromise\n                    //} catch(e) {\n                        //if (e == 'mountcancel') return\n                        //else throw e\n                    //} finally {\n                        //this._awaitingMountPromiseToRender = false\n                    //}\n                //}\n\n                //this._willBeRendered = true\n                //Motor._setNodeToBeRendered(this)\n            //}\n\n            // This method is used by Motor._renderNodes().\n            _getAncestorToBeRendered() {\n                let parent = this._parent\n\n                while (parent) {\n                    if (parent._willBeRendered) return parent\n                    parent = parent._parent\n                }\n\n                return false\n            }\n\n            _render(timestamp) {\n                super._render()\n                // applies the transform matrix to the element's style property.\n                this._elementManager.applyImperativeNodeProperties(this)\n            }\n        }\n\n        const {set: superPropertiesSet} = Object.getOwnPropertyDescriptor(ParentClass.prototype, 'properties')\n\n        Object.defineProperties(ImperativeBase.prototype, {\n\n            /**\n             * Set all properties of an ImperativeBase instance in one method.\n             *\n             * @param {Object} properties Properties object - see example.\n             *\n             * @example\n             * node.properties = {\n             *   classes: ['open', 'big'],\n             * }\n             */\n            properties: {\n                set(properties = {}) {\n                    superPropertiesSet.call(this, properties)\n\n                    if (properties.classes)\n                        this._elementManager.setClasses(...properties.classes);\n                },\n                configurable: true,\n            },\n        })\n\n        Object.defineProperty(ImperativeBase, Symbol.hasInstance, {\n            value: function(obj) {\n                if (this !== ImperativeBase) return Object.getPrototypeOf(ImperativeBase)[Symbol.hasInstance].call(this, obj)\n\n                let currentProto = obj\n\n                while(currentProto) {\n                    const desc = Object.getOwnPropertyDescriptor(currentProto, \"constructor\")\n\n                    if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))\n                        return true\n\n                    currentProto = Object.getPrototypeOf(currentProto)\n                }\n\n                return false\n            }\n        })\n\n        ImperativeBase[instanceofSymbol] = true\n\n        return ImperativeBase\n    }\n\n    ImperativeBase = ImperativeBaseMixin(Sizeable)\n    ImperativeBase.mixin = ImperativeBaseMixin\n\n}\n\nexport {ImperativeBase as default}\n"],"names":["super","this"],"mappings":"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"}