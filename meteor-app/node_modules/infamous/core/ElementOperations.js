'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _Node = require('./Node');

var _Node2 = _interopRequireDefault(_Node);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manages a DOM element. Exposes a set of recommended APIs for working with
 * DOM efficiently. Currently doesn't do much yet...
 */

var ElementOperations = function () {
    function ElementOperations(element) {
        (0, _classCallCheck3.default)(this, ElementOperations);

        this.element = element;
    }

    /**
     * @param {Array.string} classes An array of class names to add to the
     * managed element.
     *
     * Note: updating class names with `el.classList.add()` won't thrash the
     * layout. See: http://www.html5rocks.com/en/tutorials/speed/animations
     */

    (0, _createClass3.default)(ElementOperations, [{
        key: 'setClasses',
        value: function setClasses() {
            var classes = [],
                len = arguments.length;
            while (len--) classes[len] = arguments[len];

            if (classes.length) {
                (ref = this.element.classList).add.apply(ref, classes);
            }
            return this;
            var ref;
        }

        /**
         * Apply a style property to the element.
         *
         * @private
         * @param  {string} property The CSS property we will a apply.
         * @param  {string} value    The value the CSS property wil have.
         */

    }, {
        key: 'applyStyle',
        value: function applyStyle(property, value) {
            this.element.style[property] = value;
        }
    }, {
        key: 'add',
        value: function add(child) {
            this.element.appendChild(child);
        }
    }, {
        key: 'remove',
        value: function remove(child) {
            // This conditional check is needed incase the element was already
            // removed from the HTML-API side.
            if (child.parentNode === this.element) {
                this.element.removeChild(child);
            }
        }
    }, {
        key: 'connectChildElement',
        value: function connectChildElement(child) {
            if (

            // When using the imperative API, this statement is
            // true, so the DOM elements need to be connected.
            !child.parentNode

            // This condition is irrelevant when strictly using the
            // imperative API. However, it is possible that when
            // using the HTML API that the HTML-API node can be placed
            // somewhere that isn't another HTML-API node, and the
            // imperative Node can be gotten and used to add the
            // node to another imperative Node. In this case, the
            // HTML-API node will be added to the proper HTMLparent.
            || child.parentElement && child.parentElement !== this.element

            // When an HTML-API node is already child of the
            // relevant parent, or it is child of a shadow root of
            // the relevant parent, there there's nothing to do,
            // everything is already as expected, so the following
            // conditional body is skipped.
            ) {
                    this.add(child);
                }
        }
    }, {
        key: 'disconnectChildElement',
        value: function disconnectChildElement(child) {
            // If DeclarativeBase#remove was called first, we don't need to
            // call this again.
            if (!child.parentNode) {
                return;
            }

            this.remove(child);
        }

        /**
         * Apply the DOMMatrix value to the style of this Node's element.
         */

    }, {
        key: 'applyTransform',
        value: function applyTransform(domMatrix) {

            // for now, template strings need to be on one line, otherwise Meteor
            // users will have bugs from Meteor's injected line numbers. See:
            // https://github.com/meteor/meteor/issues/9160
            //
            // THREE-COORDS-TO-DOM-COORDS
            // -- We negate the 13th matrix value to make the DOM's positive Y
            // direction downward again because we first negated the value in
            // Transformable when calculating world transforms so that
            // Three.js positive Y would go downward like DOM.
            // -- We also translate the DOM element into the middle of the view
            // (similar to align and mountPoint values of 0.5) so that the DOM
            // element is aligned with the Three mesh in the middle of the view,
            // then in Transformable#_calculateMatrix we adjust the world matrix
            // back into DOM coordinates at the top/left.
            // -- We apply opposite X rotation to counter the negated X rotation in
            // Transformable for the Three.js objects.
            //
            // TODO #66: moving _calcSize to a render task affets this code
            var el = this.element;
            var elSize = el._calculatedSize;
            var parentSize = el.parent._calculatedSize;

            // THREE-COORDS-TO-DOM-COORDS: moves DOM elements to the Three.js
            // coordinate space (align and mountPoint are in the middle of the
            // view). The threeJsPostAdjustment in Transformable moves both the
            // pre-adjusted DOM element and the Three objects into the top/left
            // coordinate space.
            var threeJsPreAdjustment = "translate3d(calc(" + parentSize.x / 2 + "px - " + elSize.x / 2 + "px), calc(" + parentSize.y / 2 + "px - " + elSize.y / 2 + "px), 0px)";

            var cssMatrixString = threeJsPreAdjustment + " matrix3d( " + domMatrix.m11 + ", " + domMatrix.m12 + ", " + domMatrix.m13 + ", " + domMatrix.m14 + ", " + domMatrix.m21 + ", " + domMatrix.m22 + ", " + domMatrix.m23 + ", " + domMatrix.m24 + ", " + domMatrix.m31 + ", " + domMatrix.m32 + ", " + domMatrix.m33 + ", " + domMatrix.m34 + ", " + domMatrix.m41 + ", " + -domMatrix.m42 + ", " + domMatrix.m43 + ", " + domMatrix.m44 + ")";

            // THREE-COORDS-TO-DOM-COORDS: rotate X and Z the opposite direction for Three.js
            domMatrix.rotateAxisAngleSelf(0, 0, 1, -2 * el.rotation.z);
            domMatrix.rotateAxisAngleSelf(1, 0, 0, -2 * el.rotation.x);

            this.applyStyle('transform', cssMatrixString);
        }

        /**
         * [applySize description]
         */

    }, {
        key: 'applySize',
        value: function applySize(size) {
            var x = size.x;
            var y = size.y;

            this.applyStyle('width', x + "px");
            this.applyStyle('height', y + "px");

            // NOTE: we ignore the Z axis on elements, since they are flat.
        }
    }, {
        key: 'applyOpacity',
        value: function applyOpacity(opacity) {
            this.applyStyle('opacity', opacity);
        }
    }, {
        key: 'applyImperativeNodeProperties',
        value: function applyImperativeNodeProperties(node) {

            // Only Node is Transformable
            if (node instanceof _Node2.default) {
                this.applyOpacity(node._properties.opacity);
                this.applyTransform(node._properties.transform);
            }

            // But both Node and Scene are Sizeable
            this.applySize(node._calculatedSize);
        }
    }, {
        key: 'shouldRender',
        value: function shouldRender() {
            var this$1 = this;

            var task = _Motor2.default.addRenderTask(function () {
                this$1.applyStyle('display', 'block');
                _Motor2.default.removeRenderTask(task);
            });
        }
    }, {
        key: 'shouldNotRender',
        value: function shouldNotRender() {
            var this$1 = this;

            var task = _Motor2.default.addRenderTask(function () {
                this$1.applyStyle('display', 'none');
                _Motor2.default.removeRenderTask(task);
            });
        }
    }]);

    return ElementOperations;
}();

exports.default = ElementOperations;