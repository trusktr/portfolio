'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

require('geometry-interfaces');

var _Transformable = require('./Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _ImperativeBase = require('./ImperativeBase');

var _ImperativeBase2 = _interopRequireDefault(_ImperativeBase);

var _HTMLNode = require('../html/HTMLNode');

var _HTMLNode2 = _interopRequireDefault(_HTMLNode);

var _Scene = require('./Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var radiansPerDegree = 1 / 360 * 2 * Math.PI;

(0, _ImperativeBase.initImperativeBase)();

var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

var NodeMixin = function (base) {
    var Node = function (_ImperativeBase$mixin) {
        (0, _inherits3.default)(Node, _ImperativeBase$mixin);

        function Node() {
            (0, _classCallCheck3.default)(this, Node);

            return (0, _possibleConstructorReturn3.default)(this, (Node.__proto__ || (0, _getPrototypeOf2.default)(Node)).apply(this, arguments));
        }

        (0, _createClass3.default)(Node, [{
            key: 'construct',

            /**
             * @constructor
             *
             * @param {Object} options Initial properties that the node will
             * have. This can be used when creating a node, alternatively to using the
             * setters/getters for position, rotation, etc.
             *
             * @example
             * var node = new Node({
             *   size: {x:100, y:100, z:100},
             *   rotation: {x:30, y:20, z:25}
             * })
             */
            value: function construct(options) {
                var this$1 = this;
                if (options === void 0) options = {};

                (0, _get3.default)(Node.prototype.__proto__ || (0, _getPrototypeOf2.default)(Node.prototype), 'construct', this).call(this, options);

                // This was when using my `multiple()` implementation, we could call
                // specific constructors using specific arguments. But, we're using
                // class-factory style mixins for now, so we don't have control over the
                // specific arguments we can pass to the constructors, so we're just
                // using a single `options` parameter in all the constructors.
                //this.callSuperConstructor(Transformable, options)
                //this.callSuperConstructor(TreeNode)
                //this.callSuperConstructor(ImperativeBase)

                this._scene = null; // stores a ref to this Node's root Scene.

                // This is an internal promise that resolves when this Node is added to
                // to a scene graph that has a root Scene TreeNode. The resolved value
                // is the root Scene.
                this._scenePromise = null;
                this._resolveScenePromise = null;

                /**
                 * @private
                 * This method is defined here in the consructor as an arrow function
                 * because parent Nodes pass it to Observable#on and Observable#off. If
                 * it were a prototype method, then it would need to be bound when
                 * passed to Observable#on, which would require keeping track of the
                 * bound function reference in order to be able to pass it to
                 * Observable#off later. See ImperativeBase#add and
                 * ImperativeBase#remove.
                 */
                this._onParentSizeChange = function () {

                    // We only need to recalculate sizing and matrices if this node has
                    // properties that depend on parent sizing (proportional size,
                    // align, and mountPoint). mountPoint isn't obvious: if this node
                    // is proportionally sized, then the mountPoint will depend on the
                    // size of this element which depends on the size of this element's
                    // parent. Align also depends on parent sizing.
                    if (this$1._properties.sizeMode.x === "proportional" || this$1._properties.sizeMode.y === "proportional" || this$1._properties.sizeMode.z === "proportional" || this$1._properties.align.x !== 0 || this$1._properties.align.y !== 0 || this$1._properties.align.z !== 0) {
                        this$1._calcSize();
                        this$1._needsToBeRendered();
                    }
                };

                this._calcSize();
                this._needsToBeRendered();
            }
        }, {
            key: 'makeThreeObject3d',
            value: function makeThreeObject3d() {
                return new _three.Object3D();
            }

            /**
             * @private
             */

        }, {
            key: '_waitForMountThenResolveMountPromise',
            value: function _waitForMountThenResolveMountPromise() {
                return new Promise(function ($return, $error) {
                    var $Try_1_Finally = function ($Try_1_Exit) {
                        return function ($Try_1_Value) {
                            try {
                                this._awaitingScenePromise = false;
                                return $Try_1_Exit && $Try_1_Exit.call(this, $Try_1_Value);
                            } catch ($boundEx) {
                                return $error($boundEx);
                            }
                        }.bind(this);
                    }.bind(this);

                    if (this._awaitingScenePromise) {
                        return $return();
                    }
                    var $Try_1_Post = function () {
                        try {

                            this._mounted = true;
                            this._resolveMountPromise();
                            this._elementOperations.shouldRender();
                            return $return();
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this);var $Try_1_Catch = function (e) {
                        try {
                            if (e == 'mountcancel') {
                                return $Try_1_Finally($return)();
                            } else {
                                throw e;
                            }
                            return $Try_1_Finally($Try_1_Post)();
                        } catch ($boundEx) {
                            return $Try_1_Finally($error)($boundEx);
                        }
                    }.bind(this);try {
                        this._awaitingScenePromise = true;
                        return this._getScenePromise().then(function ($await_2) {
                            try {
                                return this._scene.mountPromise.then(function ($await_3) {
                                    try {
                                        return $Try_1_Finally($Try_1_Post)();
                                    } catch ($boundEx) {
                                        return $Try_1_Catch($boundEx);
                                    }
                                }.bind(this), $Try_1_Catch);
                            } catch ($boundEx) {
                                return $Try_1_Catch($boundEx);
                            }
                        }.bind(this), $Try_1_Catch);
                    } catch (e) {
                        $Try_1_Catch(e);
                    }
                }.bind(this));
            }

            /**
             * @private
             * Get a promise for the node's eventual scene.
             */

        }, {
            key: '_getScenePromise',
            value: function _getScenePromise() {
                var this$1 = this;

                if (!this._scenePromise) {
                    this._scenePromise = new _promise2.default(function (a, b) {
                        this$1._resolveScenePromise = a;
                    });
                }

                if (this._scene) {
                    this._resolveScenePromise();
                }

                return this._scenePromise;
            }

            /**
             * Get the Scene that this Node is in, null if no Scene. This is recursive
             * at first, then cached.
             *
             * This traverses up the scene graph tree starting at this Node and finds
             * the root Scene, if any. It caches the value for performance. If this
             * Node is removed from a parent node with parent.remove(), then the
             * cache is invalidated so the traversal can happen again when this Node is
             * eventually added to a new tree. This way, if the scene is cached on a
             * parent Node that we're adding this Node to then we can get that cached
             * value instead of traversing the tree.
             *
             * @readonly
             */

        }, {
            key: '_giveSceneRefToChildren',

            /**
             * @private
             * This method to be called only when this Node has this.scene.
             * Resolves the _scenePromise for all children of the tree of this Node.
             */
            value: function _giveSceneRefToChildren() {
                var this$1 = this;

                var children = this._children;
                for (var i = 0, l = children.length; i < l; i += 1) {
                    var childNode = children[i];
                    childNode._scene = this$1._scene;
                    if (childNode._resolveScenePromise) {
                        childNode._resolveScenePromise(childNode._scene);
                    }
                    childNode._giveSceneRefToChildren();
                }
            }
        }, {
            key: '_resetSceneRef',
            value: function _resetSceneRef() {
                this._scene = null;
                this._scenePromise = null;
                this._resolveScenePromise = null;
                var children = this._children;
                for (var i = 0, l = children.length; i < l; i += 1) {
                    children[i]._resetSceneRef();
                }
            }
        }, {
            key: 'scene',
            get: function () {
                // NOTE: this._scene is initally null, created in the constructor.

                // if already cached, return it. Or if no parent, return it (it'll be null).
                if (this._scene || !this._parent) {
                    return this._scene;
                }

                // if the parent node already has a ref to the scene, use that.
                if (this._parent._scene) {
                    this._scene = this._parent._scene;
                } else if (this._parent instanceof _Scene2.default) {
                    this._scene = this._parent;
                }
                // otherwise call the scene getter on the parent, which triggers
                // traversal up the scene graph in order to find the root scene (null
                // if none).
                else {
                        this._scene = this._parent.scene;
                    }

                return this._scene;
            }
        }], [{
            key: 'defaultElementName',
            get: function () {
                return 'i-node';
            }
        }, {
            key: '_Class',
            get: function () {
                return _Node;
            }
        }]);

        return Node;
    }(_ImperativeBase2.default.mixin(_Transformable2.default.mixin(base)));

    (0, _defineProperty2.default)(Node, _hasInstance2.default, {
        value: function (obj) {
            if (this !== Node) {
                return (0, _getPrototypeOf2.default)(Node)[_hasInstance2.default].call(this, obj);
            }

            var currentProto = obj;

            while (currentProto) {
                var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = (0, _getPrototypeOf2.default)(currentProto);
            }

            return false;
        }
    });

    Node[instanceofSymbol] = true;

    return Node;
};

var _Node = NodeMixin(function () {
    function _class() {
        (0, _classCallCheck3.default)(this, _class);
    }

    return _class;
}());
_Node.mixin = NodeMixin;

// TODO for now, hard-mixin the HTMLInterface class. We'll do this automatically later.
exports.default = _Node = _Node.mixin(_HTMLNode2.default);

exports.default = _Node;