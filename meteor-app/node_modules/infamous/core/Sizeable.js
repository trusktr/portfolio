'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _Utility = require('./Utility');

var _TreeNode = require('./TreeNode');

var _TreeNode2 = _interopRequireDefault(_TreeNode);

var _XYZValues = require('./XYZValues');

var _XYZValues2 = _interopRequireDefault(_XYZValues);

var _XYZNonNegativeValues = require('./XYZNonNegativeValues');

var _XYZNonNegativeValues2 = _interopRequireDefault(_XYZNonNegativeValues);

var _Observable = require('./Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// fallback to experimental CSS transform if browser doesn't have it (fix for Safari 9)
if (typeof document.createElement('div').style.transform == 'undefined') {
    Object.defineProperty(CSSStyleDeclaration.prototype, 'transform', {
        set: function set(value) {
            this.webkitTransform = value;
        },
        get: function get() {
            return this.webkitTransform;
        },
        enumerable: true
    });
}

var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

var SizeableMixin = function (base) {

    // Sizeable extends TreeNode because Sizeable knows about its _parent when
    // calculating proportional sizes. Also Transformable knows about it's parent
    // in order to calculate it's world matrix based on it's parent's.
    var Sizeable = function (_Observable$mixin) {
        (0, _inherits3.default)(Sizeable, _Observable$mixin);

        function Sizeable() {
            (0, _classCallCheck3.default)(this, Sizeable);

            return (0, _possibleConstructorReturn3.default)(this, (Sizeable.__proto__ || (0, _getPrototypeOf2.default)(Sizeable)).apply(this, arguments));
        }

        (0, _createClass3.default)(Sizeable, [{
            key: 'construct',
            value: function construct(options) {
                if (options === void 0) options = {};

                (0, _get3.default)(Sizeable.prototype.__proto__ || (0, _getPrototypeOf2.default)(Sizeable.prototype), 'construct', this).call(this, options);

                this._propertyFunctions = null;
                this._calculatedSize = { x: 0, y: 0, z: 0 };
                this._properties = {};
                this._setDefaultProperties();
                this._setPropertyObservers();
                this.properties = options;
            }
        }, {
            key: '_setDefaultProperties',
            value: function _setDefaultProperties() {
                (0, _assign2.default)(this._properties, {
                    sizeMode: new _XYZValues2.default('literal', 'literal', 'literal'),
                    size: new _XYZNonNegativeValues2.default(100, 100, 100)
                });
            }

            // TODO change all event values to objects. See here for reasoning:
            // https://github.com/airbnb/javascript#events

        }, {
            key: '_setPropertyObservers',
            value: function _setPropertyObservers() {
                var this$1 = this;

                this._properties.sizeMode.on('valuechanged', function () {
                    return this$1.trigger('propertychange', 'sizeMode');
                });
                this._properties.size.on('valuechanged', function () {
                    return this$1.trigger('propertychange', 'size');
                });
            }
        }, {
            key: '_calcSize',
            value: function _calcSize() {
                var calculatedSize = this._calculatedSize;
                var previousSize = (0, _extends3.default)({}, calculatedSize);
                var props = this._properties;
                var parentSize = this._getParentSize();

                if (props.sizeMode._x == 'literal') {
                    calculatedSize.x = props.size._x;
                } else {
                    // proportional
                    calculatedSize.x = parentSize.x * props.size._x;
                }

                if (props.sizeMode._y == 'literal') {
                    calculatedSize.y = props.size._y;
                } else {
                    // proportional
                    calculatedSize.y = parentSize.y * props.size._y;
                }

                if (props.sizeMode._z == 'literal') {
                    calculatedSize.z = props.size._z;
                } else {
                    // proportional
                    calculatedSize.z = parentSize.z * props.size._z;
                }

                if (previousSize.x !== calculatedSize.x || previousSize.y !== calculatedSize.y || previousSize.z !== calculatedSize.z) {
                    this.trigger('sizechange', (0, _extends3.default)({}, calculatedSize));
                }
            }
        }, {
            key: '_getParentSize',
            value: function _getParentSize() {
                return this._parent ? this._parent._calculatedSize : { x: 0, y: 0, z: 0 };
            }
        }, {
            key: '_setPropertyXYZ',
            value: function _setPropertyXYZ(Class, name, newValue) {
                var this$1 = this;

                if (newValue instanceof Array) {
                    // remove previous task if any.
                    if (!this._propertyFunctions) {
                        this._propertyFunctions = new _map2.default();
                    }

                    if (typeof newValue[0] != 'undefined') {
                        this._properties[name].x = newValue[0];
                    }
                    if (typeof newValue[1] != 'undefined') {
                        this._properties[name].y = newValue[1];
                    }
                    if (typeof newValue[2] != 'undefined') {
                        this._properties[name].z = newValue[2];
                    }
                } else if (typeof newValue == 'object') {
                    // remove previous task if any.
                    if (!this._propertyFunctions) {
                        this._propertyFunctions = new _map2.default();
                    }

                    if (typeof newValue.x != 'undefined') {
                        this._properties[name].x = newValue.x;
                    }
                    if (typeof newValue.y != 'undefined') {
                        this._properties[name].y = newValue.y;
                    }
                    if (typeof newValue.z != 'undefined') {
                        this._properties[name].z = newValue.z;
                    }
                } else if (typeof newValue == 'function') {
                    // remove previous task if any.
                    if (!this._propertyFunctions) {
                        this._propertyFunctions = new _map2.default();
                    }

                    if (this._propertyFunctions.has(name)) {
                        _Motor2.default.removeRenderTask(this._propertyFunctions.get(name));
                    }

                    this._propertyFunctions.set(name, _Motor2.default.addRenderTask(function (time) {
                        var result = newValue(this$1._properties[name].x, this$1._properties[name].y, this$1._properties[name].z, time);

                        if (result === false) {
                            this$1._propertyFunctions.delete(name);
                            return false;
                        }

                        this$1[name] = result;
                    }));
                } else {
                    throw new TypeError("Invalid value for " + Class.name + "#" + name + ".");
                }
            }
        }, {
            key: '_setPropertySingle',
            value: function _setPropertySingle(Class, name, newValue, type) {
                var this$1 = this;

                if (!(typeof newValue == type || newValue instanceof Function)) {
                    throw new TypeError("Invalid value for " + Class.name + "#" + name + ".");
                }

                if (newValue instanceof Function) {
                    // remove previous task if any.
                    _Motor2.default.addRenderTask(function (time) {
                        var result = newValue(this$1._properties[name], time);

                        if (result === false) {
                            return false;
                        }

                        this$1[name] = result;
                    });
                } else {
                    this._properties[name] = newValue;
                    this.trigger('propertychange', name);
                }
            }

            /**
             * Set the size mode for each axis. Possible size modes are "literal"
             * and "proportional". The default values are "literal" for all axes.
             *
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis sizeMode to apply. Default: `"literal"`
             * @param {number} [newValue.y] The y-axis sizeMode to apply. Default: `"literal"`
             * @param {number} [newValue.z] The z-axis sizeMode to apply. Default: `"literal"`
             */

        }, {
            key: 'sizeMode',
            set: function (newValue) {
                this._setPropertyXYZ(Sizeable, 'sizeMode', newValue);
            },
            get: function () {
                return this._properties.sizeMode;
            }

            // TODO: A "differential" size would be cool. Good for padding,
            // borders, etc. Inspired from Famous' differential sizing.
            //
            // TODO: A "target" size where sizing can be relative to another node.
            // This would be tricky though, because there could be circular size
            // dependencies. Maybe we'd throw an error in that case, because there'd be no original size to base off of.

            /**
             * Set the size of each axis. The size for each axis depends on the
             * sizeMode for each axis. For example, if node.sizeMode is set to
             * `sizeMode = ['literal', 'proportional', 'literal']`, then setting
             * `size = [20, 0.5, 30]` means that X size is a literal value of 20,
             * Y size is 0.5 of it's parent Y size, and Z size is a literal value
             * of 30. It is easy this way to mix literal and proportional sizes for
             * the different axes.
             *
             * Literal sizes can be any value (the literal size that you want) and
             * proportional sizes are a number between 0 and 1 representing a
             * proportion of the parent node size. 0 means 0% of the parent size,
             * and 1.0 means 100% of the parent size.
             *
             * All size values must be positive numbers.
             *
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis size to apply.
             * @param {number} [newValue.y] The y-axis size to apply.
             * @param {number} [newValue.z] The z-axis size to apply.
             */

        }, {
            key: 'size',
            set: function (newValue) {
                this._setPropertyXYZ(Sizeable, 'size', newValue);
            },
            get: function () {
                return this._properties.size;
            }

            /**
             * Get the actual size of the Node. This can be useful when size is
             * proportional, as the actual size of the Node depends on the size of
             * it's parent.
             *
             * @readonly
             *
             * @return {Array.number} An Oject with x, y, and z properties, each
             * property representing the computed size of the x, y, and z axes
             * respectively.
             */

        }, {
            key: 'calculatedSize',
            get: function () {
                var ref = this._calculatedSize;
                var x = ref.x;
                var y = ref.y;
                var z = ref.z;
                return { x: x, y: y, z: z };
            }

            /**
             * Set all properties of a Sizeable in one method.
             *
             * @param {Object} properties Properties object - see example
             *
             * @example
             * node.properties = {
             *   sizeMode: {x:'literal', y:'proportional', z:'literal'},
             *   size: {x:300, y:0.2, z:200},
             * }
             */

        }, {
            key: 'properties',
            set: function (properties) {
                if (properties === void 0) properties = {};

                if (properties.sizeMode) {
                    this.sizeMode = properties.sizeMode;
                }

                if (properties.size) {
                    this.size = properties.size;
                }
            }
            // no need for a properties getter?
            // TODO: maybe getting properties is a good way to serialize to JSON,
            // for people that might want that.

        }]);

        return Sizeable;
    }(_Observable2.default.mixin(_TreeNode2.default.mixin(base)));

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.


    (0, _Utility.makeLowercaseSetterAliases)(Sizeable.prototype);

    (0, _defineProperty2.default)(Sizeable, _hasInstance2.default, {
        value: function (obj) {
            if (this !== Sizeable) {
                return (0, _getPrototypeOf2.default)(Sizeable)[_hasInstance2.default].call(this, obj);
            }

            var currentProto = obj;

            while (currentProto) {
                var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = (0, _getPrototypeOf2.default)(currentProto);
            }

            return false;
        }
    });

    Sizeable[instanceofSymbol] = true;

    return Sizeable;
};

var Sizeable = SizeableMixin(function () {
    function _class() {
        (0, _classCallCheck3.default)(this, _class);
    }

    return _class;
}());
Sizeable.mixin = SizeableMixin;

exports.default = Sizeable;