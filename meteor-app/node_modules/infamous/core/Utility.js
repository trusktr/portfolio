'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isInstanceof = exports.traverse = exports.getAncestorShadowRoot = exports.hasShadowDomV1 = exports.hasShadowDomV0 = exports.getShadowRootVersion = exports.observeChildren = exports.makeLowercaseSetterAliases = exports.animationFrame = exports.applyCSSLabel = exports.epsilon = undefined;

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function epsilon(value) {
    return Math.abs(value) < 0.000001 ? 0 : value;
}

function applyCSSLabel(value, label) {
    if (value === 0) {
        return '0px';
    } else if (label === '%') {
        return value * 100 + '%';
    } else if (label === 'px') {
        return value + 'px';
    }
}

function animationFrame() {
    var resolve = null;
    var promise = new _promise2.default(function (r) {
        return resolve = r;
    });
    window.requestAnimationFrame(resolve);
    return promise;
}

// Create lowercase versions of each setter property.
// we care only about the setters, for now.
function makeLowercaseSetterAliases(object) {
    var props = (0, _getOwnPropertyNames2.default)(object);
    for (var l = props.length, i = 0; i < l; i += 1) {
        var prop = props[i];
        var lowercaseProp = prop.toLowerCase();
        if (lowercaseProp != prop) {
            var descriptor = (0, _getOwnPropertyDescriptor2.default)(object, prop);
            if (typeof descriptor.set != 'undefined') {
                (0, _defineProperty2.default)(object, lowercaseProp, descriptor);
            }
        }
    }
}

var childObservationHandlers = null;
var childObserver = null;
function observeChildren(ctx, onConnect, onDisconnect) {
    // TODO this Map is never cleaned, leaks memory.
    if (!childObservationHandlers) {
        childObservationHandlers = new _map2.default();
    }
    if (!childObserver) {
        childObserver = createChildObserver();
    }
    childObservationHandlers.set(ctx, { onConnect: onConnect, onDisconnect: onDisconnect });
    childObserver.observe(ctx, { childList: true });
    return true;
}

// NOTE: If a child is disconnected then connected to the same parent in the
// same turn, then the onConnect and onDisconnect callbacks won't be called
// because the DOM tree will be back in the exact state as before (this is
// possible thanks to the logic associated with weightsPerTarget).
function createChildObserver() {
    return new MutationObserver(function (changes) {
        var weightsPerTarget = new _map2.default();

        // We're just counting how many times each child node was added and
        // removed from the parent we're observing.
        for (var i = 0, l = changes.length; i < l; i += 1) {
            var change = changes[i];

            if (change.type != 'childList') {
                continue;
            }

            if (!weightsPerTarget.has(change.target)) {
                weightsPerTarget.set(change.target, new _map2.default());
            }

            var weights = weightsPerTarget.get(change.target);

            var addedNodes = change.addedNodes;
            for (var l$1 = addedNodes.length, i$1 = 0; i$1 < l$1; i$1 += 1) {
                weights.set(addedNodes[i$1], (weights.get(addedNodes[i$1]) || 0) + 1);
            }

            var removedNodes = change.removedNodes;
            for (var l$2 = removedNodes.length, i$2 = 0; i$2 < l$2; i$2 += 1) {
                weights.set(removedNodes[i$2], (weights.get(removedNodes[i$2]) || 0) - 1);
            }
        }

        for (var i$4 = 0, list$1 = (0, _from2.default)(weightsPerTarget); i$4 < list$1.length; i$4 += 1) {
            var ref$2 = list$1[i$4];
            var target = ref$2[0];
            var weights$1 = ref$2[1];

            var ref = childObservationHandlers.get(target);
            var onConnect = ref.onConnect;
            var onDisconnect = ref.onDisconnect;

            for (var i$3 = 0, list = (0, _from2.default)(weights$1); i$3 < list.length; i$3 += 1) {
                // If the number of times a child was added is greater than the
                // number of times it was removed, then the net result is that
                // it was added, so we call onConnect just once.
                var ref$1 = list[i$3];
                var node = ref$1[0];
                var weight = ref$1[1];

                if (weight > 0 && typeof onConnect == 'function') {
                    onConnect.call(target, node);
                }

                // If the number of times a child was added is less than the
                // number of times it was removed, then the net result is that
                // it was removed, so we call onConnect just once.
                else if (weight < 0 && typeof onDisconnect == 'function') {
                        onDisconnect.call(target, node);
                    }

                // If the number of times a child was added is equal to the
                // number of times it was removed, then it was essentially left
                // in place, so we don't call anything.
            }
        }
    });
}

var hasShadowDomV0 = typeof Element.prototype.createShadowRoot == 'function' && typeof HTMLContentElement == 'function' ? true : false;

var hasShadowDomV1 = typeof Element.prototype.attachShadow == 'function' && typeof HTMLSlotElement == 'function' ? true : false;

function getShadowRootVersion(shadowRoot) {
    console.log('getShadowRootVersion');
    if (!shadowRoot) {
        return null;
    }
    var slot = document.createElement('slot');
    shadowRoot.appendChild(slot);
    slot.appendChild(document.createElement('div'));
    var assignedNodes = slot.assignedNodes({ flatten: true });
    slot.remove();
    console.log('hmm', assignedNodes.length, assignedNodes.length > 0 ? 'v1' : 'v0');
    return assignedNodes.length > 0 ? 'v1' : 'v0';
}

function getAncestorShadowRoot(node) {
    var current = node;

    while (current && !(current instanceof ShadowRoot)) {
        current = current.parentNode;
    }

    return current;
}

// in the future, the user will be able to toggle the HTML API.
var hasHtmlApi = true;

// Traverses a tree while considering ShadowDOM disribution.
function traverse(node, isShadowChild) {
    console.log(isShadowChild ? 'distributedNode:' : 'node:', node);

    var children = node.children;
    for (var l = children.length, i = 0; i < l; i += 1) {
        // skip nodes that are possiblyDistributed, i.e. they have a parent
        // that has a ShadowRoot.
        if (!hasHtmlApi || !children[i]._isPossiblyDistributed) {
            traverse(children[i]);
        }
    }

    var shadowChildren = node._shadowChildren;
    if (hasHtmlApi && shadowChildren) {
        for (var l$1 = shadowChildren.length, i$1 = 0; i$1 < l$1; i$1 += 1) {
            traverse(shadowChildren[i$1], true);
        }
    }
}

// helper function to use instead of instanceof for classes that implement the
// static Symbol.hasInstance method, because the behavior of instanceof isn't
// polyfillable.
function isInstanceof(lhs, rhs) {
    if (typeof rhs == 'function' && rhs[_hasInstance2.default]) {
        return rhs[_hasInstance2.default](lhs);
    } else {
        return lhs instanceof rhs;
    }
}

exports.epsilon = epsilon;
exports.applyCSSLabel = applyCSSLabel;
exports.animationFrame = animationFrame;
exports.makeLowercaseSetterAliases = makeLowercaseSetterAliases;
exports.observeChildren = observeChildren;
exports.getShadowRootVersion = getShadowRootVersion;
exports.hasShadowDomV0 = hasShadowDomV0;
exports.hasShadowDomV1 = hasShadowDomV1;
exports.getAncestorShadowRoot = getAncestorShadowRoot;
exports.traverse = traverse;
exports.isInstanceof = isInstanceof;