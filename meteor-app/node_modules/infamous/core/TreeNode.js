'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _Utility = require('./Utility');

const instanceofSymbol = Symbol('instanceofSymbol');

const TreeNodeMixin = function (base) {
    var TreeNode = function (base) {
        function TreeNode(options) {
            if (options === void 0) options = {};

            base.call(this, options);
            this._parent = null; // default to no parent.
            this._children = [];
        }

        if (base) TreeNode.__proto__ = base;
        TreeNode.prototype = Object.create(base && base.prototype);
        TreeNode.prototype.constructor = TreeNode;

        var prototypeAccessors = { parent: {}, children: {}, childCount: {} };

        /**
         * this._parent is protected (node's can access other node._parent).
         * The user should use the addChild methods, which automatically handles
         * setting a parent.
         *
         * @readonly
         */
        prototypeAccessors.parent.get = function () {
            return this._parent;
        };

        /**
         * @readonly
         */
        prototypeAccessors.children.get = function () {
            // return a new array, so that the user modifying it doesn't affect
            // this node's actual children.
            return [].concat(this._children);
        };

        /**
         * Add a child node to this TreeNode.
         *
         * @param {TreeNode} childNode The child node to add.
         */
        TreeNode.prototype.addChild = function addChild(childNode) {

            if (!(0, _Utility.isInstanceof)(childNode, TreeNode)) {
                throw new TypeError('TreeNode.addChild expects the childNode argument to be a TreeNode instance.');
            }

            if (childNode._parent === this) {
                throw new ReferenceError('childNode is already a child of this parent.');
            }

            if (childNode._parent) {
                childNode._parent.removeChild(childNode);
            }

            childNode._parent = this;

            this._children.push(childNode);

            return this;
        };

        /**
         * Add all the child nodes in the given array to this node.
         *
         * @param {Array.TreeNode} nodes The nodes to add.
         */
        TreeNode.prototype.addChildren = function addChildren(nodes) {
            var this$1 = this;

            nodes.forEach(function (node) {
                return this$1.addChild(node);
            });
            return this;
        };

        /**
         * Remove a child node from this node.
         *
         * @param {TreeNode} childNode The node to remove.
         */
        TreeNode.prototype.removeChild = function removeChild(childNode) {
            if (!(0, _Utility.isInstanceof)(childNode, TreeNode)) {
                throw new Error("\n                    TreeNode.removeChild expects the childNode argument to be an\n                    instance of TreeNode. There should only be TreeNodes in the\n                    tree.\n                ");
            }

            if (childNode._parent !== this) {
                throw new ReferenceError('childNode is not a child of this parent.');
            }

            childNode._parent = null;
            this._children.splice(this._children.indexOf(childNode), 1);

            return this;
        };

        /**
         * Remove all the child nodes in the given array from this node.
         *
         * @param {Array.TreeNode} nodes The nodes to remove.
         */
        TreeNode.prototype.removeChildren = function removeChildren(nodes) {
            var this$1 = this;

            nodes.forEach(function (node) {
                return this$1.removeChild(node);
            });
            return this;
        };

        /**
         * Shortcut to remove all children.
         */
        TreeNode.prototype.removeAllChildren = function removeAllChildren() {
            this.removeChildren(this._children);
            return this;
        };

        /**
         * @readonly
         * @return {number} How many children this TreeNode has.
         */
        prototypeAccessors.childCount.get = function () {
            return this._children.length;
        };

        Object.defineProperties(TreeNode.prototype, prototypeAccessors);

        return TreeNode;
    }(base);

    Object.defineProperty(TreeNode, Symbol.hasInstance, {
        value: function (obj) {
            if (this !== TreeNode) {
                return Object.getPrototypeOf(TreeNode)[Symbol.hasInstance].call(this, obj);
            }

            let currentProto = obj;

            while (currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = Object.getPrototypeOf(currentProto);
            }

            return false;
        }
    });

    TreeNode[instanceofSymbol] = true;

    return TreeNode;
};

const TreeNode = TreeNodeMixin(function () {
    function anonymous() {}

    return anonymous;
}());
TreeNode.mixin = TreeNodeMixin;

exports.default = TreeNode;
//# sourceMappingURL=TreeNode.js.map