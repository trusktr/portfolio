'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _Utility = require('./Utility');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

var TreeNodeMixin = function (base) {
    var TreeNode = function (_base) {
        (0, _inherits3.default)(TreeNode, _base);

        function TreeNode() {
            (0, _classCallCheck3.default)(this, TreeNode);

            return (0, _possibleConstructorReturn3.default)(this, (TreeNode.__proto__ || (0, _getPrototypeOf2.default)(TreeNode)).apply(this, arguments));
        }

        (0, _createClass3.default)(TreeNode, [{
            key: 'construct',
            value: function construct() {
                var args = [],
                    len = arguments.length;
                while (len--) args[len] = arguments[len];

                (ref = (0, _get3.default)(TreeNode.prototype.__proto__ || (0, _getPrototypeOf2.default)(TreeNode.prototype), 'construct', this)).call.apply(ref, [this].concat(args));
                this._parent = null; // default to no parent.
                this._children = [];
                var ref;
            }

            /**
             * this._parent is protected (node's can access other node._parent).
             * The user should use the add() method, which automatically handles
             * setting a parent.
             *
             * @readonly
             */

        }, {
            key: 'add',

            /**
             * Add a child node to this TreeNode.
             *
             * @param {TreeNode} childNode The child node to add.
             */
            value: function add(childNode) {
                var this$1 = this;

                if (!(0, _Utility.isInstanceof)(childNode, TreeNode)) {
                    throw new TypeError('TreeNode.add() expects the childNode argument to be a TreeNode instance.');
                }

                if (childNode._parent === this) {
                    throw new ReferenceError('childNode is already a child of this parent.');
                }

                if (childNode._parent) {
                    childNode._parent.remove(childNode);
                }

                childNode._parent = this;

                this._children.push(childNode);

                _promise2.default.resolve().then(function () {
                    childNode.connected();
                    this$1.childConnected(childNode);
                });

                return this;
            }

            /**
             * Add all the child nodes in the given array to this node.
             *
             * @param {Array.TreeNode} nodes The nodes to add.
             */

        }, {
            key: 'addChildren',
            value: function addChildren(nodes) {
                var this$1 = this;

                nodes.forEach(function (node) {
                    return this$1.add()(node);
                });
                return this;
            }

            /**
             * Remove a child node from this node.
             *
             * @param {TreeNode} childNode The node to remove.
             */

        }, {
            key: 'remove',
            value: function remove(childNode) {
                var this$1 = this;

                if (!(0, _Utility.isInstanceof)(childNode, TreeNode)) {
                    throw new Error("\n                    TreeNode.remove expects the childNode argument to be an\n                    instance of TreeNode. There should only be TreeNodes in the\n                    tree.\n                ");
                }

                if (childNode._parent !== this) {
                    throw new ReferenceError('childNode is not a child of this parent.');
                }

                childNode._parent = null;
                this._children.splice(this._children.indexOf(childNode), 1);

                _promise2.default.resolve().then(function () {
                    childNode.disconnected();
                    this$1.childDisconnected(childNode);
                });

                return this;
            }

            /**
             * Remove all the child nodes in the given array from this node.
             *
             * @param {Array.TreeNode} nodes The nodes to remove.
             */

        }, {
            key: 'removeChildren',
            value: function removeChildren(nodes) {
                var this$1 = this;

                nodes.forEach(function (node) {
                    return this$1.remove(node);
                });
                return this;
            }

            /**
             * Shortcut to remove all children.
             */

        }, {
            key: 'removeAllChildren',
            value: function removeAllChildren() {
                this.removeChildren(this._children);
                return this;
            }

            /**
             * @readonly
             * @return {number} How many children this TreeNode has.
             */

        }, {
            key: 'connected',

            // generic life cycle methods
            value: function connected() {}
        }, {
            key: 'disconnected',
            value: function disconnected() {}
        }, {
            key: 'childConnected',
            value: function childConnected(child) {}
        }, {
            key: 'childDisconnected',
            value: function childDisconnected(child) {}
        }, {
            key: 'propertyChanged',
            value: function propertyChanged() {}
        }, {
            key: 'parent',
            get: function () {
                return this._parent;
            }

            /**
             * Named "subnodes" to avoid conflict with HTML Elements' "children"
             * @readonly
             */

        }, {
            key: 'subnodes',
            get: function () {
                // return a new array, so that the user modifying it doesn't affect
                // this node's actual children.
                return [].concat(this._children);
            }
        }, {
            key: 'childCount',
            get: function () {
                return this._children.length;
            }
        }]);

        return TreeNode;
    }(base);

    (0, _defineProperty2.default)(TreeNode, _hasInstance2.default, {
        value: function (obj) {
            if (this !== TreeNode) {
                return (0, _getPrototypeOf2.default)(TreeNode)[_hasInstance2.default].call(this, obj);
            }

            var currentProto = obj;

            while (currentProto) {
                var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = (0, _getPrototypeOf2.default)(currentProto);
            }

            return false;
        }
    });

    TreeNode[instanceofSymbol] = true;

    return TreeNode;
};

var TreeNode = TreeNodeMixin(function () {
    function _class() {
        (0, _classCallCheck3.default)(this, _class);
    }

    return _class;
}());
TreeNode.mixin = TreeNodeMixin;

exports.default = TreeNode;