'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Node2 = require('./Node');

var _Node3 = _interopRequireDefault(_Node2);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: update this to have a CSS3D-perspective-like API like with the Scene's
// default camera.

var PerspectiveCamera = function (_Node) {
    (0, _inherits3.default)(PerspectiveCamera, _Node);

    function PerspectiveCamera() {
        (0, _classCallCheck3.default)(this, PerspectiveCamera);

        return (0, _possibleConstructorReturn3.default)(this, (PerspectiveCamera.__proto__ || (0, _getPrototypeOf2.default)(PerspectiveCamera)).apply(this, arguments));
    }

    (0, _createClass3.default)(PerspectiveCamera, [{
        key: 'construct',
        value: function construct(options) {
            if (options === void 0) options = {};

            return new Promise(function ($return, $error) {
                (0, _get3.default)(PerspectiveCamera.prototype.__proto__ || (0, _getPrototypeOf2.default)(PerspectiveCamera.prototype), 'construct', this).call(this, options);

                this._lastKnownScene = null;

                // TODO TODO: abstract away having to use mountPromise with a
                // mountedCallback that is called everytime a node is added to a scene.
                // Right now, this will only be called the first time a node is added
                // to a scene, but not to any subsequent scenes.
                // We can't just rely on connectedCallback because that can be called
                // if the node is added to any element. See how mountPromise logic is
                // canceled in Node to get more ideas on how we can do this and not
                // replicate that canceling logic here.
                // Maybe we write it on top of init/deinit functionality?
                return this.mountPromise.then(function ($await_3) {
                    try {
                        this.mountedCallback();
                        return $return();
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }.bind(this), $error);
            }.bind(this));
        }
    }, {
        key: 'makeThreeObject3d',
        value: function makeThreeObject3d() {
            return new _three.PerspectiveCamera(75, 16 / 9, 1, 1000);
        }
    }, {
        key: 'mountedCallback',
        value: function mountedCallback() {

            // default aspect value based on the scene size.
            if (!this.hasAttribute('aspect')) {
                var ref = this.scene.calculatedSize;
                var width = ref.x;
                var height = ref.y;
                this.threeObject3d.aspect = width / height;
            }

            this._lastKnownScene = this.scene;
        }

        // TODO replace with unmountedCallback #150

    }, {
        key: 'deinit',
        value: function deinit() {
            (0, _get3.default)(PerspectiveCamera.prototype.__proto__ || (0, _getPrototypeOf2.default)(PerspectiveCamera.prototype), 'deinit', this).call(this);

            // TODO we want to call this in the upcoming
            // unmountedCallback, but for now it's harmless but
            // will run unnecessary logic. #150
            this._setSceneCamera('unset');
        }

        // TODO, unmountedCallback functionality. issue #150

    }, {
        key: 'unmountedCallback',
        value: function unmountedCallback() {}
    }, {
        key: 'attributeAddedOrChanged',
        value: function attributeAddedOrChanged(attr, newVal) {
            if (attr == 'fov') {
                this.threeObject3d.fov = parseFloat(newVal);
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'aspect') {
                this.threeObject3d.aspect = parseFloat(newVal);
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'near') {
                this.threeObject3d.near = parseFloat(newVal);
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'far') {
                this.threeObject3d.far = parseFloat(newVal);
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'zoom') {
                this.threeObject3d.zoom = parseFloat(newVal);
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'active') {
                console.log('camera attr changed, ', attr);
                this._setSceneCamera();
            }
        }

        // TODO CAMERA-DEFAULTS, get defaults from somewhere common.

    }, {
        key: 'attributeRemoved',
        value: function attributeRemoved(attr, newVal) {
            if (attr == 'fov') {
                this.threeObject3d.fov = 75;
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'aspect') {
                this.threeObject3d.aspect = this.getDefaultAspect();
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'near') {
                this.threeObject3d.near = 0.1;
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'far') {
                this.threeObject3d.far = 1000;
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'zoom') {
                this.threeObject3d.zoom = 1;
                this.threeObject3d.updateProjectionMatrix();
            } else if (attr == 'active') {
                this._setSceneCamera('unset');
            }
        }
    }, {
        key: 'getDefaultAspect',
        value: function getDefaultAspect() {
            if (this.scene) {
                return this.scene.calculatedSize.x / this.scene.calculatedSize.y;
            } else {
                return 16 / 9;
            }
        }
    }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(attr, oldVal, newVal) {
            (0, _get3.default)(PerspectiveCamera.prototype.__proto__ || (0, _getPrototypeOf2.default)(PerspectiveCamera.prototype), 'attributeChangedCallback', this).call(this, attr, oldVal, newVal);

            if (typeof newVal == 'string') {
                this.attributeAddedOrChanged(attr, newVal);
            } else {
                this.attributeRemoved(attr);
            }
        }
    }, {
        key: '_setSceneCamera',
        value: function _setSceneCamera(unset) {
            return new Promise(function ($return, $error) {

                if (unset) {

                    // TODO: unset might be triggered before the scene was mounted, so
                    // there might not be a last known scene. We won't need this check
                    // when we add unmountedCallback. #150
                    if (this._lastKnownScene) {
                        this._lastKnownScene._removeCamera(this);
                    }
                    return $If_1.call(this);
                } else {

                    // wait to be mounted, because otherwise there isn't a scene to
                    // set the active camera on.
                    // TODO: needs to be cancellable. #150
                    if (!this._mounted) {
                        return this.mountPromise.then(function ($await_4) {
                            try {
                                return $If_2.call(this);
                            } catch ($boundEx) {
                                return $error($boundEx);
                            }
                        }.bind(this), $error);
                    }

                    function $If_2() {
                        this.scene._addCamera(this);
                        return $If_1.call(this);
                    }

                    return $If_2.call(this);
                }

                function $If_1() {
                    return $return();
                }
            }.bind(this));
        }
    }], [{
        key: 'defaultElementName',
        get: function () {
            return 'i-perspective-camera';
        }
    }, {
        key: '_Class',
        get: function () {
            return PerspectiveCamera;
        }
    }, {
        key: 'observedAttributes',
        get: function () {
            var superAttrs = (0, _get3.default)(PerspectiveCamera.__proto__ || (0, _getPrototypeOf2.default)(PerspectiveCamera), 'observedAttributes', this) || [];
            return superAttrs.concat(['active', 'fov', 'near', 'far', 'aspect', 'zoom'].map(function (a) {
                return a.toLowerCase();
            }));
        }
    }]);

    return PerspectiveCamera;
}(_Node3.default);

exports.default = PerspectiveCamera;