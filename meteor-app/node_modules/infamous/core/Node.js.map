{"version":3,"file":"Node.js","sources":["../../src/core/Node.js"],"sourcesContent":["import 'geometry-interfaces'\nimport Transformable from './Transformable'\nimport ImperativeBase, {initImperativeBase} from './ImperativeBase'\nimport HTMLNode from '../html/HTMLNode'\nimport Scene from './Scene'\n\ninitImperativeBase()\n\nclass Node extends ImperativeBase.mixin(Transformable) {\n\n    /**\n     * @constructor\n     *\n     * @param {Object} options Initial properties that the node will\n     * have. This can be used when creating a node, alternatively to using the\n     * setters/getters for position, rotation, etc.\n     *\n     * @example\n     * var node = new Node({\n     *   absoluteSize: {x:100, y:100, z:100},\n     *   rotation: {x:30, y:20, z:25}\n     * })\n     */\n    constructor (options = {}) {\n        super(options)\n\n        // This was when using my `multiple()` implementation, we could call\n        // specific constructors using specific arguments. But, we're using\n        // class-factory style mixins for now, so we don't have control over the\n        // specific arguments we can pass to the constructors, so we're just\n        // using a single `options` parameter in all the constructors.\n        //this.callSuperConstructor(Transformable, options)\n        //this.callSuperConstructor(TreeNode)\n        //this.callSuperConstructor(ImperativeBase)\n\n        this._scene = null // stores a ref to this Node's root Scene.\n\n        // This is an internal promise that resolves when this Node is added to\n        // to a scene graph that has a root Scene TreeNode. The resolved value\n        // is the root Scene.\n        this._scenePromise = null\n        this._resolveScenePromise = null\n\n        /**\n         * @private\n         * This method is defined here in the consructor as an arrow function\n         * because parent Nodes pass it to Observable#on and Observable#off. If\n         * it were a prototype method, then it would need to be bound when\n         * passed to Observable#on, which would require keeping track of the\n         * bound function reference in order to be able to pass it to\n         * Observable#off later. See ImperativeBase#addChild and\n         * ImperativeBase#removeChild.\n         */\n        this._onParentSizeChange = () => {\n\n            // We only need to recalculate sizing and matrices if this node has\n            // properties that depend on parent sizing (proportional size,\n            // align, and mountPoint). mountPoint isn't obvious: if this node\n            // is proportionally sized, then the mountPoint will depend on the\n            // size of this element which depends on the size of this element's\n            // parent.\n            if (\n                this._properties.sizeMode.x === \"proportional\"\n                || this._properties.sizeMode.y === \"proportional\"\n                || this._properties.sizeMode.z === \"proportional\"\n\n                || this._properties.align.x !== 0\n                || this._properties.align.y !== 0\n                || this._properties.align.z !== 0\n            ) {\n                this._calcSize()\n                this._needsToBeRendered()\n            }\n        }\n\n        this._calcSize()\n        this._needsToBeRendered()\n    }\n\n    /**\n     * @private\n     */\n    _waitForMountThenResolveMountPromise() {\n        if (this._awaitingScenePromise) return Promise.resolve()\n\n        const logic = () => {\n            this._mounted = true\n            this._resolveMountPromise()\n            this._elementManager.shouldRender()\n        }\n\n        this._awaitingScenePromise = true\n\n        let possibleError = undefined\n\n        // try\n        return this._getScenePromise()\n        .then(() => this._scene.mountPromise)\n\n        .then(logic)\n\n        // catch\n        .catch(() => {\n            if (e == 'mountcancel') return\n            else possibleError = e\n        })\n\n        // finally\n        .then(() => {\n            this._awaitingScenePromise = false\n\n            if (possibleError) throw possibleError\n        })\n    }\n    //async _waitForMountThenResolveMountPromise() {\n        //if (this._awaitingScenePromise) return\n        //try {\n            //this._awaitingScenePromise = true\n            //await this._getScenePromise()\n            //await this._scene.mountPromise\n        //} catch (e) {\n            //if (e == 'mountcancel') return\n            //else throw e\n        //} finally {\n            //this._awaitingScenePromise = false\n        //}\n\n        //this._mounted = true\n        //this._resolveMountPromise()\n        //this._elementManager.shouldRender()\n    //}\n\n    /**\n     * @override\n     */\n    _makeElement() {\n        return new HTMLNode\n    }\n\n    /**\n     * @private\n     * Get a promise for the node's eventual scene.\n     */\n    _getScenePromise() {\n        if (!this._scenePromise) {\n            this._scenePromise = new Promise((a, b) => {\n                this._resolveScenePromise = a\n            })\n        }\n\n        if (this._scene)\n            this._resolveScenePromise()\n\n        return this._scenePromise\n    }\n\n    /**\n     * Get the Scene that this Node is in, null if no Scene. This is recursive\n     * at first, then cached.\n     *\n     * This traverses up the scene graph tree starting at this Node and finds\n     * the root Scene, if any. It caches the value for performance. If this\n     * Node is removed from a parent node with parent.removeChild(), then the\n     * cache is invalidated so the traversal can happen again when this Node is\n     * eventually added to a new tree. This way, if the scene is cached on a\n     * parent Node that we're adding this Node to then we can get that cached\n     * value instead of traversing the tree.\n     *\n     * @readonly\n     */\n    get scene() {\n        // NOTE: this._scene is initally null, created in the constructor.\n\n        // if already cached, return it. Or if no parent, return it (it'll be null).\n        if (this._scene || !this._parent) return this._scene\n\n        // if the parent node already has a ref to the scene, use that.\n        if (this._parent._scene) {\n            this._scene = this._parent._scene\n        }\n        else if (this._parent instanceof Scene) {\n            this._scene = this._parent\n        }\n        // otherwise call the scene getter on the parent, which triggers\n        // traversal up the scene graph in order to find the root scene (null\n        // if none).\n        else {\n            this._scene = this._parent.scene\n        }\n\n        return this._scene\n    }\n\n    /**\n     * @private\n     * This method to be called only when this Node has this.scene.\n     * Resolves the _scenePromise for all children of the tree of this Node.\n     */\n    _giveSceneRefToChildren() {\n        const children = this._children;\n        for (let i=0, l=children.length; i<l; i+=1) {\n            const childNode = children[i]\n            childNode._scene = this._scene\n            if (childNode._resolveScenePromise)\n                childNode._resolveScenePromise(childNode._scene)\n            childNode._giveSceneRefToChildren();\n        }\n    }\n\n    _resetSceneRef() {\n        this._scene = null\n        this._scenePromise = null\n        this._resolveScenePromise = null\n        const children = this._children;\n        for (let i=0, l=children.length; i<l; i+=1) {\n            children[i]._resetSceneRef();\n        }\n    }\n}\n\nexport {Node as default}\n"],"names":[],"mappings":"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"}