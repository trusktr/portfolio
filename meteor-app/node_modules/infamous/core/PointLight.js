'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _LightBase2 = require('./LightBase');

var _LightBase3 = _interopRequireDefault(_LightBase2);

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PointLight = function (_LightBase) {
    (0, _inherits3.default)(PointLight, _LightBase);

    function PointLight() {
        (0, _classCallCheck3.default)(this, PointLight);

        return (0, _possibleConstructorReturn3.default)(this, (PointLight.__proto__ || (0, _getPrototypeOf2.default)(PointLight)).apply(this, arguments));
    }

    (0, _createClass3.default)(PointLight, [{
        key: 'construct',
        value: function construct(options) {
            if (options === void 0) options = {};

            (0, _get3.default)(PointLight.prototype.__proto__ || (0, _getPrototypeOf2.default)(PointLight.prototype), 'construct', this).call(this, options);
        }
    }, {
        key: 'makeThreeObject3d',
        value: function makeThreeObject3d() {
            var light = new _three.PointLight();
            light.intensity = 1; // default 1
            light.distance = 0; // default 0
            light.decay = 1; // default 1
            light.castShadow = true; // default false
            light.shadow.mapSize.width = 512; // default 512
            light.shadow.mapSize.height = 512; // default 512
            light.shadow.radius = 3; // default 1
            light.shadow.bias = 0; // default 0
            // TODO: auto-adjust near and far planes like we will with Camera,
            // unless the user supplies a manual value.
            light.shadow.camera.near = 1; // default 1
            light.shadow.camera.far = 2000; // default 2000

            return light;
        }

        // TODO: make way to map attributes to properties.

    }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(attr, oldVal, newVal) {
            (0, _get3.default)(PointLight.prototype.__proto__ || (0, _getPrototypeOf2.default)(PointLight.prototype), 'attributeChangedCallback', this).call(this, attr, oldVal, newVal);

            if (attr == 'distance' || attr == 'decay') {
                this.processNumberValue(attr, newVal);
                this._needsToBeRendered();
            } else if (attr == 'castshadow' || attr == 'cast-shadow') {

                // TODO: generic function to handle boolean attributes
                if (newVal == 'false' || newVal == null) {
                    this.threeObject3d.castShadow = false;
                } else {
                    this.threeObject3d.castShadow = true;
                }

                this._needsToBeRendered();
            } else if (attr == 'shadowmapwidth' || attr == 'shadow-map-width') {
                this.processNumberValue('width', newVal, this.threeObject3d.shadow.mapSize);
                this._needsToBeRendered();
            } else if (attr == 'shadowmapheight' || attr == 'shadow-map-height') {
                this.processNumberValue('height', newVal, this.threeObject3d.shadow.mapSize);
                this._needsToBeRendered();
            } else if (attr == 'shadowradius' || attr == 'shadow-radius') {
                this.processNumberValue('radius', newVal, this.threeObject3d.shadow);
                this._needsToBeRendered();
            } else if (attr == 'shadowbias' || attr == 'shadow-bias') {
                this.processNumberValue('bias', newVal, this.threeObject3d.shadow);
                this._needsToBeRendered();
            } else if (attr == 'shadowcameranear' || attr == 'shadow-camera-near') {
                this.processNumberValue('near', newVal, this.threeObject3d.shadow.camera);
                this._needsToBeRendered();
            } else if (attr == 'shadowcamerafar' || attr == 'shadow-camera-far') {
                this.processNumberValue('far', newVal, this.threeObject3d.shadow.camera);
                this._needsToBeRendered();
            }
        }
    }], [{
        key: 'defaultElementName',
        get: function () {
            return 'i-point-light';
        }
    }, {
        key: '_Class',
        get: function () {
            return PointLight;
        }
    }, {
        key: 'observedAttributes',
        get: function () {
            return (0, _get3.default)(PointLight.__proto__ || (0, _getPrototypeOf2.default)(PointLight), 'observedAttributes', this).concat(['distance', 'decay', 'castshadow', 'cast-shadow', 'shadowmapwidth', 'shadow-map-width', 'shadowmapheight', 'shadow-map-height', 'shadowradius', 'shadow-radius', 'shadowbias', 'shadow-bias', 'shadowcameranear', 'shadow-camera-near', 'shadowcamerafar', 'shadow-camera-far']);
        }
    }]);

    return PointLight;
}(_LightBase3.default);

exports.default = PointLight;