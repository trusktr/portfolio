'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

const instanceofSymbol = Symbol('instanceofSymbol');

const ObservableMixin = function (base) {
    var Observable = function (base) {
        function Observable(options) {
            if (options === void 0) options = {};

            base.call(this, options);
        }

        if (base) Observable.__proto__ = base;
        Observable.prototype = Object.create(base && base.prototype);
        Observable.prototype.constructor = Observable;

        Observable.prototype.on = function on(eventName, callback) {
            if (!this._eventMap) {
                this._eventMap = new Map();
            }

            if (!this._eventMap.has(eventName)) {
                this._eventMap.set(eventName, []);
            }

            if (typeof callback == 'function') {
                this._eventMap.get(eventName).push(callback);
            } else {
                throw new Error('Expected a function in callback argument of Observable#on.');
            }
        };

        Observable.prototype.off = function off(eventName, callback) {
            if (!this._eventMap || !this._eventMap.has(eventName)) {
                return;
            }

            const callbacks = this._eventMap.get(eventName);

            if (callbacks.indexOf(callback) === -1) {
                return;
            }

            callbacks.splice(callbacks.indexOf(callback), 1);

            if (callbacks.length === 0) {
                this._eventMap.delete(eventName);
            }

            if (this._eventMap.size === 0) {
                this._eventMap = null;
            }
        };

        Observable.prototype.triggerEvent = function triggerEvent(eventName, data) {
            if (!this._eventMap || !this._eventMap.has(eventName)) {
                return;
            }

            const callbacks = this._eventMap.get(eventName);

            for (let i = 0, len = callbacks.length; i < len; i += 1) {
                callbacks[i](data);
            }
        };

        return Observable;
    }(base);

    Object.defineProperty(Observable, Symbol.hasInstance, {
        value: function (obj) {
            if (this !== Observable) {
                return Object.getPrototypeOf(Observable)[Symbol.hasInstance].call(this, obj);
            }

            let currentProto = obj;

            while (currentProto) {
                const desc = Object.getOwnPropertyDescriptor(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                    return true;
                }

                currentProto = Object.getPrototypeOf(currentProto);
            }

            return false;
        }
    });

    Observable[instanceofSymbol] = true;

    return Observable;
};

const Observable = ObservableMixin(function () {
    function anonymous() {}

    return anonymous;
}());
Observable.mixin = ObservableMixin;

exports.default = Observable;
//# sourceMappingURL=Observable.js.map