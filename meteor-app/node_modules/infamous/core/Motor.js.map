{"version":3,"file":"Motor.js","sources":["../../src/core/Motor.js"],"sourcesContent":["import documentReady from 'awaitbox/dom/documentReady'\nimport Transformable from './Transformable'\nimport getWebGlRenderer from './WebGLRenderer'\nimport {isInstanceof} from './Utility'\n\nimport {\n    //animationFrame,\n} from './Utility'\n\nlet documentIsReady = false\nlet webGLRenderer = null\n\nclass Motor {\n    constructor() {\n        this._inFrame = false // true when inside a requested animation frame.\n        this._rAF = null // the current animation frame, or null.\n        this._animationLoopStarted = false\n        this._allRenderTasks = []\n        this._taskIterationIndex = 0\n        this._numberOfTasks = 0\n        this._nodesToBeRendered = []\n        this._modifiedScenes = []\n\n        // A set of nodes that are the root nodes of subtrees where all nodes\n        // in each subtree need to have their world matrices updated.\n        this._worldMatrixRootNodes = []\n    }\n\n    /**\n     * Starts an rAF loop and runs the render tasks in the _renderTasks stack.\n     * As long as there are tasks in the stack, the loop continues. When the\n     * stack becomes empty due to removal of tasks, the rAF stops and the app\n     * sits there doing nothing -- silence, crickets.\n     */\n    _startAnimationLoop() {\n        if (this._animationLoopStarted) return Promise.resolve()\n\n        this._animationLoopStarted = true\n\n        const logic = () => {\n            // DIRECT ANIMATION LOOP ///////////////////////////////////\n            // So now we can render after the scene is mounted.\n            const motorLoop = timestamp => {\n                this._inFrame = true\n\n                this._runRenderTasks(timestamp)\n                this._renderNodes(timestamp)\n\n                // If any tasks are left to run, continue the animation loop.\n                if (this._allRenderTasks.length)\n                    this._rAF = requestAnimationFrame(motorLoop)\n                else {\n                    this._rAF = null\n                    this._animationLoopStarted = false\n                }\n\n                this._inFrame = false\n            }\n\n            this._rAF = requestAnimationFrame(motorLoop)\n        }\n\n        if (!documentIsReady) {\n            return documentReady().then(() => {\n                documentIsReady = true\n                logic()\n            })\n        }\n\n        logic()\n        return Promise.resolve()\n    }\n    //async _startAnimationLoop() {\n        //if (this._animationLoopStarted) return\n\n        //this._animationLoopStarted = true\n\n        //if (!documentIsReady) {\n            //await documentReady()\n            //documentIsReady = true\n        //}\n\n        //// DIRECT ANIMATION LOOP ///////////////////////////////////\n        //// So now we can render after the scene is mounted.\n        //const motorLoop = timestamp => {\n            //this._inFrame = true\n\n            //this._runRenderTasks(timestamp)\n            //this._renderNodes(timestamp)\n\n            //// If any tasks are left to run, continue the animation loop.\n            //if (this._allRenderTasks.length)\n                //this._rAF = requestAnimationFrame(motorLoop)\n            //else {\n                //this._rAF = null\n                //this._animationLoopStarted = false\n            //}\n\n            //this._inFrame = false\n        //}\n\n        //this._rAF = requestAnimationFrame(motorLoop)\n\n        //// ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////\n        ////this._rAF = true\n        ////let timestamp = null\n        ////while (this._rAF) {\n            ////timestamp = await animationFrame()\n            ////this._inFrame = true\n\n            ////this._runRenderTasks(timestamp)\n            ////this._renderNodes(timestamp)\n\n            ////// If any tasks are left to run, continue the animation loop.\n            ////if (!this._allRenderTasks.length) {\n                ////this._rAF = null\n                ////this._animationLoopStarted = false\n            ////}\n\n            ////this._inFrame = false\n        ////}\n    //}\n\n    /**\n     * When a render tasks is added a new rAF loop will be started if there\n     * isn't one currently.\n     *\n     * A render task is simply a function that will be called over and over\n     * again, in the Motor's animation loop. That's all, nothing special.\n     * However, if a Node setter is used inside of a render task, then the Node\n     * will tell Motor that it needs to be re-rendered, which will happen at\n     * the end of the current frame. If a Node setter is used outside of a\n     * render task (i.e. outside of the Motor's animation loop), then the Node\n     * tells Motor to re-render the Node on the next animation loop tick.\n     * Basically, regardless of where the Node's setters are used (inside or\n     * outside of the Motor's animation loop), rendering always happens inside\n     * the loop.\n     *\n     * @param {Function} fn The render task to add.\n     * @return {Function} A reference to the render task. Useful for saving to\n     * a variable so that it can later be passed to Motor.removeRenderTask().\n     */\n    addRenderTask(fn) {\n        if (typeof fn != 'function')\n            throw new Error('Render task must be a function.')\n\n        if (this._allRenderTasks.includes(fn)) return\n\n        this._allRenderTasks.push(fn)\n        this._numberOfTasks += 1\n\n        // If the render loop isn't started, start it.\n        if (!this._animationLoopStarted)\n            this._startAnimationLoop()\n\n        return fn\n    }\n\n    removeRenderTask(fn) {\n        const taskIndex = this._allRenderTasks.indexOf(fn)\n\n        if (taskIndex == -1) return\n\n        this._allRenderTasks.splice(taskIndex, 1)\n        this._numberOfTasks -= 1\n        this._taskIterationIndex -= 1\n    }\n\n    _runRenderTasks(timestamp) {\n        for (this._taskIterationIndex = 0; this._taskIterationIndex < this._numberOfTasks; this._taskIterationIndex += 1) {\n            const task = this._allRenderTasks[this._taskIterationIndex]\n\n            if (task(timestamp) === false)\n                this.removeRenderTask(task)\n        }\n    }\n\n    _setNodeToBeRendered(node) {\n        if (this._nodesToBeRendered.includes(node)) return\n        this._nodesToBeRendered.push(node)\n        if (!this._inFrame) this._startAnimationLoop()\n    }\n\n    _renderNodes(timestamp) {\n        if (!this._nodesToBeRendered.length) return\n\n        for (let i=0, l=this._nodesToBeRendered.length; i<l; i+=1) {\n            const node = this._nodesToBeRendered[i]\n\n            node._render(timestamp)\n\n            // If the node is root of a subtree containing updated nodes and\n            // has no ancestors that were modified, then add it to the\n            // _worldMatrixRootNodes set so we can update the world matrices of\n            // all the nodes in the root node's subtree.\n            if (\n                // a node could be a Scene, which is not Transformable\n                isInstanceof(node, Transformable) &&\n\n                // and if ancestor is not instanceof Transformable, f.e.\n                // `false` if there is no ancestor to be rendered, or Sizeable\n                // if the Scene is returned.\n                !isInstanceof(node._getAncestorToBeRendered(), Transformable) &&\n\n                // and the node isn't already added.\n                !this._worldMatrixRootNodes.includes(node)\n            ) {\n                this._worldMatrixRootNodes.push(node)\n            }\n\n            // keep track of which scenes are modified so we can render webgl\n            // only for those scenes.\n            // TODO FIXME: at this point, a node should always have a scene,\n            // otherwise it should not ever be rendered here, but turns out\n            // some nodes are getting into this queue without a scene. We\n            // shouldn't need the conditional check for node._scene, and it\n            // will save CPU by not allowing the code to get here in that case.\n            if (node._scene && !this._modifiedScenes.includes(node._scene))\n                this._modifiedScenes.push(node._scene)\n        }\n\n        // Update world matrices of the subtrees.\n        const worldMatrixRootNodes = this._worldMatrixRootNodes\n        for (let i=0, l=worldMatrixRootNodes.length; i<l; i+=1) {\n            const subtreeRoot = worldMatrixRootNodes[i]\n            subtreeRoot._calculateWorldMatricesInSubtree()\n        }\n        worldMatrixRootNodes.length = 0\n\n        // render webgl of modified scenes.\n        const modifiedScenes = this._modifiedScenes\n        // TODO PERFORMANCE: store a list of webgl-enabled modified scenes, and\n        // iterate only through those so we don't iterate over non-webgl\n        // scenes.\n        for (let i=0, l=modifiedScenes.length; i<l; i+=1) {\n            const sceneElement = modifiedScenes[i].element\n            // TODO we're temporarily storing stuff on the .element, but we\n            // don't want that, we will move it to WebGLRenderer.\n            if (\n                sceneElement.webglEnabled &&\n                ( webGLRenderer || (webGLRenderer = getWebGlRenderer()) ) // only ever call getWebGlRenderer once\n            )\n                webGLRenderer.drawScene(sceneElement)\n        }\n        modifiedScenes.length = 0\n\n        const nodesToBeRendered = this._nodesToBeRendered\n        for (let i=0, l=nodesToBeRendered.length; i<l; i+=1) {\n            nodesToBeRendered[i]._willBeRendered = false\n        }\n        nodesToBeRendered.length = 0\n    }\n}\n\n// export a singleton instance rather than the class directly.\nexport default new Motor\n"],"names":[],"mappings":"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"}