'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;
exports.initImperativeBase = initImperativeBase;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _set2 = require('babel-runtime/helpers/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _ElementOperations = require('./ElementOperations');

var _ElementOperations2 = _interopRequireDefault(_ElementOperations);

var _Sizeable = require('./Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _Node = require('./Node');

var _Node2 = _interopRequireDefault(_Node);

var _Scene = require('./Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _Utility = require('./Utility');

var _three = require('three');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var threeObject3d = null;
var domPlane = null;

// We explicitly use `var` instead of `let` here because it is hoisted for the
// Node and Scene modules. This, along with the following initImperativeBase
// function, allows the circular dependency between this module and the Node and
// Scene modules to work. For details on why, see
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem.
var ImperativeBase;

// Here we wrap the definition of the ImperativeBase class with this function in
// order to solve the circular depdendency problem caused by the
// Node<->ImperativeBase and Scene<->ImperativeBase circles. The Node and Scene
// modules call initImperativeBase to ensure that the ImperativeBase declaration
// happens first, and then those modules can use the live binding in their
// declarations.
initImperativeBase();
function initImperativeBase() {
    if (ImperativeBase) {
        return;
    }

    var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

    /**
     * The ImperativeBase class is the base class for the Imperative version of the
     * API, for people who chose to take the all-JavaScript approach and who will
     * not use the HTML-based API (infamous/motor-html).
     *
     * In the future when there is an option to disable the HTML-DOM rendering (and
     * render only WebGL, for example) then the imperative API will be the only API
     * available since the HTML API will be turned off as a result of disabling
     * HTML rendering. Disabling both WebGL and HTML won't make sense, as we'll need
     * at least one of those to render with.
     */
    var ImperativeBaseMixin = function (base) {
        var ImperativeBase = function (_base) {
            (0, _inherits3.default)(ImperativeBase, _base);

            function ImperativeBase() {
                (0, _classCallCheck3.default)(this, ImperativeBase);

                return (0, _possibleConstructorReturn3.default)(this, (ImperativeBase.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase)).apply(this, arguments));
            }

            (0, _createClass3.default)(ImperativeBase, [{
                key: 'construct',
                value: function construct(options) {
                    var this$1 = this;
                    if (options === void 0) options = {};

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'construct', this).call(this, options);

                    this._lastKnownParent = null;

                    // we don't need this, keep for backward compatibility (mainly
                    // all my demos at trusktr.io).
                    this.imperativeCounterpart = this;

                    this._willBeRendered = false;

                    // Here we create the DOM HTMLElement associated with this
                    // Imperative-API Node.
                    this._elementOperations = new _ElementOperations2.default(this);

                    // For Nodes, true when this Node is added to a parent AND it
                    // has an anancestor Scene that is mounted into DOM. For
                    // Scenes, true when mounted into DOM.
                    this._mounted = false;

                    // stores a ref to this Node's root Scene when/if this Node is
                    // in a scene.
                    this._scene = null;

                    // For Nodes, a promise that resolves when this Node is
                    // attached to a tree that has a root Scene TreeNode *and* when
                    // that root Scene has been mounted into the DOM. For Scenes,
                    // resolves when mounted into DOM.
                    this._mountPromise = null;
                    this._resolveMountPromise = null;
                    this._rejectMountPromise = null;

                    this._awaitingMountPromiseToRender = false;
                    this._waitingForMountConditions = false;

                    // See Transformable/Sizeable propertychange event.
                    // TODO: defer size calculation to render task
                    this.on('propertychange', function (prop) {
                        if (prop == 'sizeMode' || prop == 'size') {
                            this$1._calcSize();
                        }

                        this$1._needsToBeRendered();
                    });

                    this.initWebGl();
                }
            }, {
                key: 'initWebGl',
                value: function initWebGl() {
                    this.threeObject3d = this.makeThreeObject3d();

                    // we don't let Three update local matrices, we provide world
                    // matrices ourselves.
                    this.threeObject3d.matrixAutoUpdate = false;
                }
            }, {
                key: 'makeThreeObject3d',
                value: function makeThreeObject3d() {
                    throw new Error('The makeThreeObject3d method should be defined by sub classes.');
                }
            }, {
                key: 'connected',
                value: function connected() {
                    this._lastKnownParent = this.parent;
                    this.parent.threeObject3d.add(this.threeObject3d);
                }
            }, {
                key: 'disconnected',
                value: function disconnected() {
                    this._lastKnownParent.threeObject3d.remove(this.threeObject3d);
                }
            }, {
                key: '_calculateWorldMatrixFromParent',
                value: function _calculateWorldMatrixFromParent() {
                    var this$1 = this;

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), '_calculateWorldMatrixFromParent', this).call(this);

                    threeObject3d = this.threeObject3d;
                    domPlane = this._threeDOMPlane;

                    // Three Matrix4#elements is in the same major order as our
                    // DOMMatrix#_matrix. If we were to use Matrix4#set here, we'd have
                    // to swap the order when passing in our DOMMatrix#_matrix.
                    // Three.js r88, Issue #12602
                    for (var i = 0; i < 16; i += 1) {
                        threeObject3d.matrixWorld.elements[i] = this$1._worldMatrix._matrix[i];
                        if (domPlane) {
                            domPlane.matrixWorld.elements[i] = this$1._worldMatrix._matrix[i];
                        }
                    }

                    // Since we're not letting Three auto update matrices, we also need
                    // to update the inverse matrix for cameras.
                    if (threeObject3d instanceof _three.Camera) {
                        threeObject3d.matrixWorldInverse.getInverse(threeObject3d.matrixWorld);
                    }
                }

                /**
                 * Subclasses are required to override this. It should return the HTML-API
                 * counterpart for this Imperative-API instance. See Node or Scene classes
                 * for example.
                 *
                 * @private
                 */

            }, {
                key: '_makeElement',
                value: function _makeElement() {
                    throw new Error('Subclasses need to override ImperativeBase#_makeElement.');
                }

                /**
                 * @readonly
                 */

            }, {
                key: '_waitForMountThenResolveMountPromise',
                value: function _waitForMountThenResolveMountPromise() {}
                // extended in Node or Scene to await for anything that mount
                // depends on.


                /**
                 * @readonly
                 */

            }, {
                key: 'add',

                /**
                 * @override
                 */
                value: function add(childNode) {
                    if (!(0, _Utility.isInstanceof)(childNode, ImperativeBase)) {
                        return;
                    }

                    // We cannot add Scenes to Nodes, for now.
                    if (childNode instanceof _Scene2.default) {
                        throw new Error("\n                        A Scene cannot be added to another Node or Scene (at\n                        least for now). To place a Scene in a Node, just mount\n                        a new Scene onto a MotorHTMLNode with Scene.mount().\n                    ");
                    }

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'add', this).call(this, childNode);

                    // Pass this parent node's Scene reference (if any, checking this cache
                    // first) to the new child and the child's children.
                    if (childNode._scene || childNode.scene) {
                        if (childNode._resolveScenePromise) {
                            childNode._resolveScenePromise(childNode._scene);
                        }
                        childNode._giveSceneRefToChildren();
                    }

                    // Calculate sizing because proportional size might depend on
                    // the new parent.
                    childNode._calcSize();
                    childNode._needsToBeRendered();

                    // child should watch the parent for size changes.
                    this.on('sizechange', childNode._onParentSizeChange);

                    this._elementOperations.connectChildElement(childNode);

                    return this;
                }
            }, {
                key: 'remove',
                value: function remove(childNode, /*private use*/leaveInDom) {
                    if (!(childNode instanceof _Node2.default)) {
                        return;
                    }

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'remove', this).call(this, childNode);

                    this.off('sizechange', childNode._onParentSizeChange);

                    childNode._resetSceneRef();

                    if (childNode._mountPromise) {
                        childNode._rejectMountPromise('mountcancel');
                    }
                    if (childNode._mounted) {
                        childNode._elementOperations.shouldNotRender();
                    }
                    childNode._resetMountPromise();

                    if (!leaveInDom) {
                        this._elementOperations.disconnectChildElement(childNode);
                    }
                }
            }, {
                key: '_resetMountPromise',
                value: function _resetMountPromise() {
                    this._mounted = false;
                    this._mountPromise = null;
                    this._resolveMountPromise = null;
                    this._rejectMountPromise = null;
                    var children = this._children;
                    for (var i = 0, l = children.length; i < l; i += 1) {
                        children[i]._resetMountPromise();
                    }
                }
            }, {
                key: '_needsToBeRendered',
                value: function _needsToBeRendered() {
                    return new Promise(function ($return, $error) {
                        if (this._awaitingMountPromiseToRender) {
                            return $return();
                        }

                        if (!this._mounted) {
                            var $Try_1_Finally = function ($Try_1_Exit) {
                                return function ($Try_1_Value) {
                                    try {
                                        this._awaitingMountPromiseToRender = false;
                                        return $Try_1_Exit && $Try_1_Exit.call(this, $Try_1_Value);
                                    } catch ($boundEx) {
                                        return $error($boundEx);
                                    }
                                }.bind(this);
                            }.bind(this);

                            var $Try_1_Post = function () {
                                try {
                                    return $If_2.call(this);
                                } catch ($boundEx) {
                                    return $error($boundEx);
                                }
                            }.bind(this);var $Try_1_Catch = function (e) {
                                try {
                                    if (e == 'mountcancel') {
                                        return $Try_1_Finally($return)();
                                    } else {
                                        throw e;
                                    }
                                    return $Try_1_Finally($Try_1_Post)();
                                } catch ($boundEx) {
                                    return $Try_1_Finally($error)($boundEx);
                                }
                            }.bind(this);
                            try {
                                this._awaitingMountPromiseToRender = true;
                                return this.mountPromise.then(function ($await_3) {
                                    try {
                                        return $Try_1_Finally($Try_1_Post)();
                                    } catch ($boundEx) {
                                        return $Try_1_Catch($boundEx);
                                    }
                                }.bind(this), $Try_1_Catch);
                            } catch (e) {
                                $Try_1_Catch(e);
                            }
                        }

                        function $If_2() {
                            this._willBeRendered = true;
                            _Motor2.default._setNodeToBeRendered(this);
                            return $return();
                        }

                        return $If_2.call(this);
                    }.bind(this));
                }

                // This method is used by Motor._renderNodes().

            }, {
                key: '_getAncestorThatShouldBeRendered',
                value: function _getAncestorThatShouldBeRendered() {
                    var parent = this._parent;

                    while (parent) {
                        if (parent._willBeRendered) {
                            return parent;
                        }
                        parent = parent._parent;
                    }

                    return false;
                }
            }, {
                key: '_render',
                value: function _render(timestamp) {
                    if ((0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), '_render', this)) {
                        (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), '_render', this).call(this);
                    }
                    // applies the transform matrix to the element's style property.
                    this._elementOperations.applyImperativeNodeProperties(this);
                }

                /**
                 * Set all properties of an ImperativeBase instance in one method.
                 *
                 * @param {Object} properties Properties object - see example.
                 *
                 * @example
                 * node.properties = {
                 *   classes: ['open', 'big'],
                 * }
                 */

            }, {
                key: 'mountPromise',
                get: function () {
                    var this$1 = this;

                    if (!this._mountPromise) {
                        this._mountPromise = new _promise2.default(function (resolve, reject) {
                            this$1._resolveMountPromise = resolve;
                            this$1._rejectMountPromise = reject;
                        });
                    }

                    if (!this._mounted) {
                        this._waitForMountThenResolveMountPromise();
                    } else if (this._mounted) {
                        this._resolveMountPromise();
                    }

                    return this._mountPromise;
                }
            }, {
                key: 'element',
                get: function () {
                    return this._elementOperations.element;
                }

                /**
                 * Get the Scene that this Node is in, null if no Scene. This is recursive
                 * at first, then cached.
                 *
                 * This traverses up the scene graph tree starting at this Node and finds
                 * the root Scene, if any. It caches the value for performance. If this
                 * Node is removed from a parent node with parent.removeChild(), then the
                 * cache is invalidated so the traversal can happen again when this Node is
                 * eventually added to a new tree. This way, if the scene is cached on a
                 * parent Node that we're adding this Node to then we can get that cached
                 * value instead of traversing the tree.
                 *
                 * @readonly
                 */

            }, {
                key: 'scene',
                get: function () {
                    // NOTE: this._scene is initally null, created in the constructor.

                    // if already cached, return it. Or if no parent, return it (it'll be null).
                    // Additionally, Scenes have this._scene already set to themselves.
                    if (this._scene || !this._parent) {
                        return this._scene;
                    }

                    // if the parent node already has a ref to the scene, use that.
                    if (this._parent._scene) {
                        this._scene = this._parent._scene;
                    } else if (this._parent instanceof _Scene2.default) {
                        this._scene = this._parent;
                    }
                    // otherwise call the scene getter on the parent, which triggers
                    // traversal up the scene graph in order to find the root scene (null
                    // if none).
                    else {
                            this._scene = this._parent.scene;
                        }

                    return this._scene;
                }
            }, {
                key: 'properties',
                set: function (properties) {
                    if (properties === void 0) properties = {};

                    (0, _set3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'properties', properties, this);

                    if (properties.classes) {
                        (ref = this._elementOperations).setClasses.apply(ref, properties.classes);
                        var ref;
                    }
                }
            }]);

            return ImperativeBase;
        }(base);

        (0, _defineProperty2.default)(ImperativeBase, _hasInstance2.default, {
            value: function (obj) {
                if (this !== ImperativeBase) {
                    return (0, _getPrototypeOf2.default)(ImperativeBase)[_hasInstance2.default].call(this, obj);
                }

                var currentProto = obj;

                while (currentProto) {
                    var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                    if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) {
                        return true;
                    }

                    currentProto = (0, _getPrototypeOf2.default)(currentProto);
                }

                return false;
            }
        });

        ImperativeBase[instanceofSymbol] = true;

        return ImperativeBase;
    };

    exports.default = ImperativeBase = ImperativeBaseMixin(_Sizeable2.default);
    ImperativeBase.mixin = ImperativeBaseMixin;
}

exports.default = ImperativeBase;