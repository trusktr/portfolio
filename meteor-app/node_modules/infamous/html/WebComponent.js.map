{"version":3,"file":"WebComponent.js","sources":["../../src/html/WebComponent.js"],"sourcesContent":["/* global customElements */\n\nimport { observeChildren } from '../core/Utility'\nimport jss from '../lib/jss'\n\n// Very very stupid hack needed for Safari in order for us to be able to extend\n// the HTMLElement class. See:\n// https://github.com/google/traceur-compiler/issues/1709\nif (typeof window.HTMLElement != 'function') {\n    const _HTMLElement = function HTMLElement(){}\n    _HTMLElement.prototype = window.HTMLElement.prototype\n    window.HTMLElement = _HTMLElement\n}\n\nconst classCache = new Map\n\nfunction classExtendsHTMLElement(constructor) {\n    if (!constructor) return false\n    if (constructor === HTMLElement) return true\n    else return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null)\n}\n\n/**\n * Creates a WebComponent base class dynamically, depending on which\n * HTMLElement class you want it to extend from. Extend from WebComponent when\n * making a new Custom Element class.\n *\n * @example\n * const WebComponent = WebComponentMixin(HTMLButtonElement)\n * class AwesomeButton extends WebComponent { ... }\n *\n * @param {Function} elementClass The class that the generated WebComponent\n * base class will extend from.\n */\nexport default\nfunction WebComponentMixin(elementClass) {\n    if (!elementClass) elementClass = HTMLElement\n\n    if (!classExtendsHTMLElement(elementClass)) {\n        throw new TypeError(\n            'The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.'\n        )\n    }\n\n    // if a base class that extends the given `elementClass` has already been\n    // created, return it.\n    if (classCache.has(elementClass))\n        return classCache.get(elementClass)\n\n    // otherwise, create it.\n    class WebComponent extends elementClass {\n\n        constructor() {\n            super()\n\n            // Throw an error if no Custom Elements v1 API exists.\n            if (!('customElements' in window)) {\n                throw new Error(`\n                    Your browser does not support the Custom Elements API. You'll\n                    need to install a polyfill. See how at http://....\n                `)\n            }\n\n            this._connected = false\n            this._initialized = false\n            this._initialAttributeChange = false\n            this._childObserver = null\n            this._style = null\n        }\n\n        // Subclasses can implement these.\n        childConnectedCallback(child) { }\n        childDisconnectedCallback(child) { }\n\n        connectedCallback() {\n            if (super.connectedCallback) super.connectedCallback()\n            this._connected = true\n\n            if (!this._initialized) {\n                this.init()\n                this._initialized = true\n            }\n        }\n\n        _createStyles() {\n            const rule = jss.createRule(this.getStyles())\n\n            rule.applyTo(this)\n\n            return rule\n        }\n\n        disconnectedCallback() {\n            if (super.disconnectedCallback) super.disconnectedCallback()\n            this._connected = false\n\n            // Deferr to the next tick before cleaning up in case the\n            // element is actually being re-attached somewhere else within this\n            // same tick (detaching and attaching is synchronous, so by\n            // deferring to the next tick we'll be able to know if the element\n            // was re-attached or not in order to clean up or not). Note that\n            // appendChild can be used to move an element to another parent\n            // element, in which case connectedCallback and disconnectedCallback\n            // both get called, and in which case we don't necessarily want to\n            // clean up. If the element gets re-attached before the next tick\n            // (for example, gets moved), then we want to preserve the\n            // stuff that would be cleaned up by an extending class' deinit\n            // method by not running the following this.deinit() call.\n            Promise.resolve().then(() => { // deferr to the next tick.\n\n                // As mentioned in the previous comment, if the element was not\n                // re-attached in the last tick (for example, it was moved to\n                // another element), then clean up.\n                if (!this._connected && this._initialized) {\n                    this.deinit()\n                }\n            })\n        }\n        //async disconnectedCallback() {\n            //if (super.disconnectedCallback) super.disconnectedCallback()\n            //this._connected = false\n\n            //// Deferr to the next tick before cleaning up in case the\n            //// element is actually being re-attached somewhere else within this\n            //// same tick (detaching and attaching is synchronous, so by\n            //// deferring to the next tick we'll be able to know if the element\n            //// was re-attached or not in order to clean up or not). Note that\n            //// appendChild can be used to move an element to another parent\n            //// element, in which case connectedCallback and disconnectedCallback\n            //// both get called, and in which case we don't necessarily want to\n            //// clean up. If the element gets re-attached before the next tick\n            //// (for example, gets moved), then we want to preserve the\n            //// stuff that would be cleaned up by an extending class' deinit\n            //// method by not running the following this.deinit() call.\n            //await Promise.resolve() // deferr to the next tick.\n\n            //// As mentioned in the previous comment, if the element was not\n            //// re-attached in the last tick (for example, it was moved to\n            //// another element), then clean up.\n            //if (!this._connected && this._initialized) {\n                //this.deinit()\n            //}\n        //}\n\n        /**\n         * This method can be overridden by extending classes, it should return\n         * JSS-compatible styling. See http://github.com/cssinjs/jss for\n         * documentation.\n         * @abstract\n         */\n        getStyles() {\n            return {}\n        }\n\n\n        /**\n         * Init is called exactly once, the first time this element is\n         * connected into the DOM. When an element is disconnected then\n         * connected right away within the same synchronous tick, init() is not\n         * fired again. However, if an element is disconnected and the current\n         * tick completes before the element is connected again, then deinit()\n         * will be called (i.e. the element was not simply moved to a new\n         * location, it was actually removed), then the next time that the\n         * element is connected back into DOM init() will be called again.\n         *\n         * This is in contrast to connectedCallback and disconnectedCallback:\n         * connectedCallback is guaranteed to always fire even if the elemet\n         * was previously disconnected in the same synchronous tick.\n         *\n         * For example, ...\n         *\n         * Subclasses should extend this to add such logic.\n         */\n        init() {\n            if (!this._style) this._style = this._createStyles()\n\n            // Handle any nodes that may have been connected before `this` node\n            // was created (f.e. child nodes that were connected before the\n            // custom elements were registered and which would therefore not be\n            // detected by the following MutationObserver).\n            if (!this._childObserver) {\n\n                const children = this.childNodes\n                if (children.length) {\n\n                    // Timeout needed in case the Custom Element classes are\n                    // registered after the elements are already defined in the\n                    // DOM but not yet upgraded. This means that the `node` arg\n                    // might be a `<motor-node>` but if it isn't upgraded then\n                    // its API won't be available to the logic inside the\n                    // childConnectedCallback. The reason this happens is\n                    // because parents are upgraded first and their\n                    // connectedCallbacks fired before their children are\n                    // upgraded.\n                    //\n                    // TODO FIXME PERFORMANCE: This causes a possibly \"buggy\" effect where\n                    // elements in a tree will appear in intervals of 5\n                    // milliseconds. We want elements to be rendered instantly,\n                    // in the first frame that they are present in the scene\n                    // graph.\n                    // How can we fix this? Maybe we can switch to a Promise microtask.\n                    setTimeout(() => {\n                        for (let l=children.length, i=0; i<l; i+=1) {\n                            this.childConnectedCallback(children[i])\n                        }\n                    }, 5)\n                }\n\n                this._childObserver = observeChildren(this, this.childConnectedCallback, this.childDisconnectedCallback)\n            }\n\n            // fire this.attributeChangedCallback in case some attributes have\n            // existed before the custom element was upgraded.\n            if (!this._initialAttributeChange && this.hasAttributes()) {\n\n                // HTMLElement#attributes is a NamedNodeMap which is not an\n                // iterable, so we use Array.from. See:\n                // https://github.com/zloirock/core-js/issues/234\n                const {attributes} = this\n                for (let l=attributes.length, i=0; i<l; i+=1)\n                    this.attributeChangedCallback(attributes[i].name, null, attributes[i].value)\n            }\n        }\n\n        static get observedAttributes() {\n            console.warn(`WebComponent: Your custom element (${ this.name }) should specify observed attributes or attributeChangedCallback won't be called`)\n        }\n\n        attributeChangedCallback(...args) {\n            //console.log(' --- attributeChangedCallback', typeof args[2])\n            if (super.attributeChangedCallback) super.attributeChangedCallback(...args)\n            this._initialAttributeChange = true\n        }\n\n        /**\n         * This is the reciprocal of init(). It will be called when an element\n         * has been disconnected but not re-connected within the same tick.\n         *\n         * The reason that init() and deinit() exist is so that if an element is\n         * moved from one place to another within the same synchronous tick,\n         * that deinit and init logic will not fire unnecessarily. If logic is\n         * needed in that case, then connectedCallback and disconnectedCallback\n         * can be used directly instead.\n         */\n        deinit() {\n            // Nothing much at the moment, but extending classes can extend\n            // this to add deintialization logic.\n\n            this._initialized = false\n        }\n    }\n\n    classCache.set(elementClass, WebComponent)\n    return WebComponent\n}\n"],"names":[],"mappings":"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"}