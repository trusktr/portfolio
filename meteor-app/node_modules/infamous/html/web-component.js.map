{"version":3,"file":"web-component.js","sources":["../../src/html/web-component.js"],"sourcesContent":["/* global customElements */\n\nimport { observeChildren } from '../core/Utility'\nimport jss from '../lib/jss'\n\n// Very very stupid hack needed for Safari in order for us to be able to extend\n// the HTMLElement class. See:\n// https://github.com/google/traceur-compiler/issues/1709\nif (typeof window.HTMLElement != 'function') {\n    const _HTMLElement = function HTMLElement(){}\n    _HTMLElement.prototype = window.HTMLElement.prototype\n    window.HTMLElement = _HTMLElement\n}\n\nconst classCache = new Map\n\nfunction classExtendsHTMLElement(constructor) {\n    if (!constructor) return false\n    if (constructor === HTMLElement) return true\n    else return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null)\n}\n\n/**\n * Creates a WebComponent base class dynamically, depending on which\n * HTMLElement class you want it to extend from. Extend from WebComponent when\n * making a new Custom Element class.\n *\n * @example\n * const WebComponent = WebComponentMixin(HTMLButtonElement)\n * class AwesomeButton extends WebComponent { ... }\n *\n * @param {Function} elementClass The class that the generated WebComponent\n * base class will extend from.\n */\nexport default\nfunction WebComponentMixin(elementClass) {\n    if (!elementClass) elementClass = HTMLElement\n\n    if (!classExtendsHTMLElement(elementClass)) {\n        throw new TypeError(\n            'The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.'\n        )\n    }\n\n    // if a base class that extends the given `elementClass` has already been\n    // created, return it.\n    if (classCache.has(elementClass))\n        return classCache.get(elementClass)\n\n    // otherwise, create it.\n    class WebComponent extends elementClass {\n\n        // constructor() is used in v1 Custom Elements instead of\n        // createdCallback() as in v0.\n        constructor() {\n            super()\n\n            // If the following is true, then we know the user should be using\n            // `document.registerElement()` to define an element from this class.\n            // `document.registerElement()` creates a new constructor, so if the\n            // constructor here is being called then that means the user is not\n            // instantiating a DOM HTMLElement as expected because it is required\n            // that the constructor returned from `document.registerElement` be used\n            // instead (this is a flaw of Custom Elements v0 which is fixed in v1\n            // where class constructors can be used directly).\n            if ('registerElement' in document && !('customElements' in window)) {\n                throw new Error(`\n                    You cannot instantiate this class directly without first registering it\n                    with \\`document.registerElement(...)\\`. See an example at http://....\n                `)\n            }\n\n            // Throw an error if no Custom Elements API exists.\n            if (!('registerElement' in document) && !('customElements' in window)) {\n                throw new Error(`\n                    Your browser does not support the Custom Elements API. You'll\n                    need to install a polyfill. See how at http://....\n                `)\n            }\n\n            // otherwise the V1 API exists, so call the createdCallback, which\n            // is what Custom Elements v0 would call by default. Subclasses of\n            // WebComponent should put instantiation logic in createdCallback\n            // instead of in a custom constructor if backwards compatibility is\n            // to be maintained.\n            this.createdCallback()\n        }\n\n        createdCallback() {\n            this._attached = false\n            this._initialized = false\n            this._initialAttributeChange = false\n            this._childObserver = null\n            this._style = null\n        }\n\n        // Subclasses can implement these.\n        childConnectedCallback(child) {}\n        childDisconnectedCallback(child) {}\n\n        connectedCallback() {\n            if (super.connectedCallback) super.connectedCallback()\n            this._attached = true\n\n            if (!this._initialized) {\n                this.init()\n                this._initialized = true\n            }\n        }\n        attachedCallback() { this.connectedCallback() } // back-compat\n\n        _createStyles() {\n            const rule = jss.createRule(this.getStyles())\n\n            rule.applyTo(this)\n\n            return rule\n        }\n\n        disconnectedCallback() {\n            if (super.disconnectedCallback) super.disconnectedCallback()\n            this._attached = false\n\n            // Deferr to the next tick before cleaning up in case the\n            // element is actually being re-attached somewhere else within this\n            // same tick (detaching and attaching is synchronous, so by\n            // deferring to the next tick we'll be able to know if the element\n            // was re-attached or not in order to clean up or not). Note that\n            // appendChild can be used to move an element to another parent\n            // element, in which case connectedCallback and disconnectedCallback\n            // both get called, and in which case we don't necessarily want to\n            // clean up. If the element gets re-attached before the next tick\n            // (for example, gets moved), then we want to preserve the\n            // stuff that would be cleaned up by an extending class' deinit\n            // method by not running the following this.deinit() call.\n            Promise.resolve().then(() => { // deferr to the next tick.\n\n                // As mentioned in the previous comment, if the element was not\n                // re-attached in the last tick (for example, it was moved to\n                // another element), then clean up.\n                if (!this._attached && this._initialized) {\n                    this.deinit()\n                }\n            })\n        }\n        //async disconnectedCallback() {\n            //if (super.disconnectedCallback) super.disconnectedCallback()\n            //this._attached = false\n\n            //// Deferr to the next tick before cleaning up in case the\n            //// element is actually being re-attached somewhere else within this\n            //// same tick (detaching and attaching is synchronous, so by\n            //// deferring to the next tick we'll be able to know if the element\n            //// was re-attached or not in order to clean up or not). Note that\n            //// appendChild can be used to move an element to another parent\n            //// element, in which case connectedCallback and disconnectedCallback\n            //// both get called, and in which case we don't necessarily want to\n            //// clean up. If the element gets re-attached before the next tick\n            //// (for example, gets moved), then we want to preserve the\n            //// stuff that would be cleaned up by an extending class' deinit\n            //// method by not running the following this.deinit() call.\n            //await Promise.resolve() // deferr to the next tick.\n\n            //// As mentioned in the previous comment, if the element was not\n            //// re-attached in the last tick (for example, it was moved to\n            //// another element), then clean up.\n            //if (!this._attached && this._initialized) {\n                //this.deinit()\n            //}\n        //}\n        detachedCallback() { this.disconnectedCallback() } // back-compat\n\n        /**\n         * This method can be overridden by extending classes, it should return\n         * JSS-compatible styling. See http://github.com/cssinjs/jss for\n         * documentation.\n         * @abstract\n         */\n        getStyles() {\n            return {}\n        }\n\n\n        /**\n         * Init is called exactly once, the first time this element is\n         * connected into the DOM. When an element is disconnected then\n         * connected right away within the same synchronous tick, init() is not\n         * fired again. However, if an element is disconnected and the current\n         * tick completes before the element is connected again, then deinit()\n         * will be called (i.e. the element was not simply moved to a new\n         * location, it was actually removed), then the next time that the\n         * element is connected back into DOM init() will be called again.\n         *\n         * This is in contrast to connectedCallback and disconnectedCallback:\n         * connectedCallback is guaranteed to always fire even if the elemet\n         * was previously disconnected in the same synchronous tick.\n         *\n         * For example, ...\n         *\n         * Subclasses should extend this to add such logic.\n         */\n        init() {\n            if (!this._style) this._style = this._createStyles()\n\n            // Handle any nodes that may have been connected before `this` node\n            // was created (f.e. child nodes that were connected before the\n            // custom elements were registered and which would therefore not be\n            // detected by the following MutationObserver).\n            if (!this._childObserver) {\n\n                const children = this.childNodes\n                if (children.length) {\n\n                    // Timeout needed in case the Custom Element classes are\n                    // registered after the elements are already defined in the\n                    // DOM but not yet upgraded. This means that the `node` arg\n                    // might be a `<motor-node>` but if it isn't upgraded then\n                    // its API won't be available to the logic inside the\n                    // childConnectedCallback. The reason this happens is\n                    // because parents are upgraded first and their\n                    // connectedCallbacks fired before their children are\n                    // upgraded.\n                    //\n                    // TODO FIXME PERFORMANCE: This causes a possibly \"buggy\" effect where\n                    // elements in a tree will appear in intervals of 5\n                    // milliseconds. We want elements to be rendered instantly,\n                    // in the first frame that they are present in the scene\n                    // graph.\n                    // How can we fix this? Maybe we can switch to a Promise microtask.\n                    setTimeout(() => {\n                        for (let l=children.length, i=0; i<l; i+=1) {\n                            this.childConnectedCallback(children[i])\n                        }\n                    }, 5)\n                }\n\n                this._childObserver = observeChildren(this, this.childConnectedCallback, this.childDisconnectedCallback)\n            }\n\n            // fire this.attributeChangedCallback in case some attributes have\n            // existed before the custom element was upgraded.\n            if (!this._initialAttributeChange && this.hasAttributes()) {\n\n                // HTMLElement#attributes is a NamedNodeMap which is not an\n                // iterable, so we use Array.from. See:\n                // https://github.com/zloirock/core-js/issues/234\n                const {attributes} = this\n                for (let l=attributes.length, i=0; i<l; i+=1)\n                    this.attributeChangedCallback(attributes[i].name, null, attributes[i].value)\n            }\n        }\n\n        attributeChangedCallback(...args) {\n            //console.log(' --- attributeChangedCallback', typeof args[2])\n            if (super.attributeChangedCallback) super.attributeChangedCallback(...args)\n            this._initialAttributeChange = true\n        }\n\n        /**\n         * This is the reciprocal of init(). It will be called when an element\n         * has been disconnected but not re-connected within the same tick.\n         *\n         * The reason that init() and deinit() exist is so that if an element is\n         * moved from one place to another within the same synchronous tick,\n         * that deinit and init logic will not fire unnecessarily. If logic is\n         * needed in that case, then connectedCallback and disconnectedCallback\n         * can be used directly instead.\n         */\n        deinit() {\n            // Nothing much at the moment, but extending classes can extend\n            // this to add deintialization logic.\n\n            this._initialized = false\n        }\n    }\n\n    classCache.set(elementClass, WebComponent)\n    return WebComponent\n}\n"],"names":["super","this"],"mappings":"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"}