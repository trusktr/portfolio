'use strict';

var _construct = require('babel-runtime/core-js/reflect/construct');

var _construct2 = _interopRequireDefault(_construct);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

require('custom-attributes/attr.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _fixBabelExtend = function (O) {
    var gOPD = O.getOwnPropertyDescriptor,
        gPO = O.getPrototypeOf || function (o) {
        return o.__proto__;
    },
        sPO = O.setPrototypeOf || function (o, p) {
        o.__proto__ = p;
        return o;
    },
        construct = typeof Reflect === 'object' ? _construct2.default : function (Parent, args, Class) {
        var Constructor,
            a = [null];
        a.push.apply(a, args);
        Constructor = Parent.bind.apply(Parent, a);
        return sPO(new Constructor(), Class.prototype);
    };

    return function fixBabelExtend(Class) {
        var Parent = gPO(Class);
        return sPO(Class, sPO(function Super() {
            return construct(Parent, arguments, gPO(this).constructor);
        }, Parent));
    };
}(Object);

var BehaviorRegistry = function () {
    function BehaviorRegistry() {
        (0, _classCallCheck3.default)(this, BehaviorRegistry);

        this._definedBehaviors = new _map2.default();
    }

    (0, _createClass3.default)(BehaviorRegistry, [{
        key: 'define',
        value: function define(name, Behavior) {
            if (!this._definedBehaviors.has(name)) {
                this._definedBehaviors.set(name, Behavior);
            } else {
                throw new Error("Behavior " + name + " is already defined.");
            }
        }
    }, {
        key: 'get',
        value: function get(name) {
            return this._definedBehaviors.get(name);
        }
    }, {
        key: 'has',
        value: function has(name) {
            return this._definedBehaviors.has(name);
        }
    }]);

    return BehaviorRegistry;
}();

window.elementBehaviors = new BehaviorRegistry();

// for semantic purpose

var BehaviorMap = _fixBabelExtend(function (_Map2) {
    (0, _inherits3.default)(BehaviorMap, _Map2);

    function BehaviorMap() {
        (0, _classCallCheck3.default)(this, BehaviorMap);

        return (0, _possibleConstructorReturn3.default)(this, (BehaviorMap.__proto__ || (0, _getPrototypeOf2.default)(BehaviorMap)).apply(this, arguments));
    }

    return BehaviorMap;
}(_map2.default));

// stores the behaviors associated to each element.


var behaviorMaps = new _weakMap2.default();

// All elements have a `behaviors` property. If null, it the element has no
// behaviors, otherwise the property is a map of behavior names to behavior
// instances.
Object.defineProperty(Element.prototype, 'behaviors', {
    get: function get() {
        var thisBehaviors = null;

        if (!behaviorMaps.has(this)) {
            behaviorMaps.set(this, thisBehaviors = new BehaviorMap());
        } else {
            thisBehaviors = behaviorMaps.get(this);
        }

        return thisBehaviors;
    }
});

// One instance of is instantiated per element with has="" attribute.

var HasAttribute = function () {
    function HasAttribute() {
        (0, _classCallCheck3.default)(this, HasAttribute);

        // TODO constructor confusing because this.ownerElement doesn't exist. Report to custom-attributes

        this.observers = new _map2.default();
    }

    (0, _createClass3.default)(HasAttribute, [{
        key: 'connectedCallback',
        value: function connectedCallback() {
            this.behaviors = this.ownerElement.behaviors;
            this.changedCallback('', this.value);
        }
    }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
            this.changedCallback(this.value, '');
            delete this.behaviors;
        }
    }, {
        key: 'changedCallback',
        value: function changedCallback(oldVal, newVal) {
            var newBehaviors = this.getBehaviorNames(newVal);
            var previousBehaviors = (0, _from2.default)(this.behaviors.keys());

            // small optimization: if no previous or new behaviors, just quit
            // early. It would still function the same without this.
            if (newBehaviors.length == 0 && previousBehaviors.length == 0) {
                return;
            }

            var ref = this.getDiff(previousBehaviors, newBehaviors);
            var removed = ref.removed;
            var added = ref.added;
            this.handleDiff(removed, added);
        }
    }, {
        key: 'getBehaviorNames',
        value: function getBehaviorNames(string) {
            if (string.trim() == '') {
                return [];
            } else {
                return string.split(/\s+/);
            }
        }
    }, {
        key: 'getDiff',
        value: function getDiff(previousBehaviors, newBehaviors) {
            var diff = {
                removed: [],
                added: newBehaviors
            };

            for (var i = 0, l = previousBehaviors.length; i < l; i += 1) {
                var oldBehavior = previousBehaviors[i];

                // if it exists in the previousBehaviors but not the newBehaviors, then
                // the node was removed.
                if (!(diff.added.indexOf(oldBehavior) !== -1)) {
                    diff.removed.push(oldBehavior);
                }

                // otherwise the old value also exists in the set of new values, so
                // therefore it wasn't added or removed, so let's remove it so we
                // don't count it as added
                else {
                        diff.added.splice(diff.added.indexOf(oldBehavior), 1);
                    }
            }

            return diff;
        }
    }, {
        key: 'handleDiff',
        value: function handleDiff(removed, added) {
            var this$1 = this;

            for (var i = 0, list = removed; i < list.length; i += 1) {
                var name = list[i];

                if (!elementBehaviors.has(name)) {
                    continue;
                }

                var behavior = this$1.behaviors.get(name);

                // TODO fire this disconnectedCallback only if the element is in a
                // document, not if it merely has a parent (the naive easy way for
                // now).
                if (this$1.ownerElement.parentNode) {
                    behavior.disconnectedCallback(this$1.ownerElement);
                }

                // We can't rely on checking observedAttributes here because that
                // could change after the fact, we only ever check it when we add
                // the behavior. If it had observedAttributes, then it will have an
                // observer.
                if (this$1.observers.has(behavior)) {
                    this$1.destroyAttributeObserver(behavior);
                }

                this$1.behaviors.delete(name);
            }

            for (var i$1 = 0, list$1 = added; i$1 < list$1.length; i$1 += 1) {
                var name$1 = list$1[i$1];

                if (!elementBehaviors.has(name$1)) {
                    continue;
                }

                var Behavior = elementBehaviors.get(name$1);
                var behavior$1 = new Behavior(this$1.ownerElement);
                this$1.behaviors.set(name$1, behavior$1);

                // TODO fire this connectedCallback only if the element is in a
                // document, not if it merely has a parent (the naive easy way for
                // now).
                if (this$1.ownerElement.parentNode) {
                    behavior$1.connectedCallback(this$1.ownerElement);
                }

                if (Array.isArray(behavior$1.constructor.observedAttributes)) {
                    this$1.fireInitialAttributeChangedCallbacks(behavior$1);
                    this$1.createAttributeObserver(behavior$1);
                }
            }
        }
    }, {
        key: 'destroyAttributeObserver',
        value: function destroyAttributeObserver(behavior) {
            this.observers.get(behavior).disconnect();
            this.observers.delete(behavior);
        }

        // Behaviors observe attribute changes, implemented with MutationObserver
        //
        // We have to create one observer per behavior because otherwise
        // MutationObserver doesn't have an API for disconnecting from a single
        // element, only for disconnecting from all elements.

    }, {
        key: 'createAttributeObserver',
        value: function createAttributeObserver(behavior) {
            var this$1 = this;

            var observer = new MutationObserver(function (records) {

                for (var i = 0, list = records; i < list.length; i += 1) {
                    var record = list[i];

                    behavior.attributeChangedCallback(this$1.ownerElement, record.attributeName, record.oldValue, this$1.ownerElement.getAttribute(record.attributeName));
                }
            });

            observer.observe(this.ownerElement, {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: behavior.constructor.observedAttributes
            });

            this.observers.set(behavior, observer);
        }
    }, {
        key: 'fireInitialAttributeChangedCallbacks',
        value: function fireInitialAttributeChangedCallbacks(behavior) {
            var this$1 = this;

            if (!Array.isArray(behavior.constructor.observedAttributes)) {
                return;
            }

            for (var i = 0, list = (0, _from2.default)(this$1.ownerElement.attributes); i < list.length; i += 1) {
                var attr = list[i];

                if (!(behavior.constructor.observedAttributes.indexOf(attr.name) !== -1)) {
                    continue;
                }
                if (behavior.attributeChangedCallback) {
                    behavior.attributeChangedCallback(this$1.ownerElement, attr.name, undefined, attr.value);
                }
            }
        }
    }]);

    return HasAttribute;
}();

customAttributes.define('has', HasAttribute);