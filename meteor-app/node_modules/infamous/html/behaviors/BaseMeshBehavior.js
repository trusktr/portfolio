'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _three = require('three');

var _Mesh = require('../../core/Mesh');

var _Mesh2 = _interopRequireDefault(_Mesh);

var _ValueProcessor2 = require('../../core/ValueProcessor');

var _ValueProcessor3 = _interopRequireDefault(_ValueProcessor2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// base class for Geometry and Material behaviors, not to be used directly

var BaseMeshBehavior = function (_ValueProcessor) {
    (0, _inherits3.default)(BaseMeshBehavior, _ValueProcessor);

    function BaseMeshBehavior(element) {
        (0, _classCallCheck3.default)(this, BaseMeshBehavior);

        var _this = (0, _possibleConstructorReturn3.default)(this, (BaseMeshBehavior.__proto__ || (0, _getPrototypeOf2.default)(BaseMeshBehavior)).call(this));

        _this.checkedElementIsMesh = false;
        _this.elementIsMesh = false;

        // records the initial size of the geometry, so that we have a
        // reference for how much scale to apply when accepting new sizes from
        // the user.
        _this.initialSize = null;

        _this.isMeshPromise = null;
        var resolveIsMeshPromise = null;
        // TODO cancellable promise, or it may leak

        if (element.nodeName.indexOf('-') !== -1) {
            _this.isMeshPromise = new _promise2.default(function (r) {
                return resolveIsMeshPromise = r;
            });
            customElements.whenDefined(element.nodeName.toLowerCase()).then(function () {
                if (element instanceof _Mesh2.default) {
                    resolveIsMeshPromise(true);
                } else {
                    resolveIsMeshPromise(false);
                }
            });
        } else {
            _this.isMeshPromise = _promise2.default.resolve(false);
        }
        return _this;
    }

    (0, _createClass3.default)(BaseMeshBehavior, [{
        key: 'connectedCallback',
        value: function connectedCallback(element) {
            return new Promise(function ($return, $error) {
                if (!this.checkedElementIsMesh) {
                    return this.checkElementIsMesh(element).then(function ($await_4) {
                        try {
                            return $If_1.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }

                function $If_1() {
                    if (!this.elementIsMesh) {
                        return $return(false);
                    }

                    // TODO might have to defer so that calculatedSize is already calculated
                    this.setMeshComponent(element, this.constructor.type, this.createComponent(element));
                    element._needsToBeRendered();

                    return $return(true);
                }

                return $If_1.call(this);
            }.bind(this));
        }
    }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback(element) {
            return new Promise(function ($return, $error) {
                if (!this.checkedElementIsMesh) {
                    return this.checkElementIsMesh(element).then(function ($await_5) {
                        try {
                            return $If_2.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }

                function $If_2() {
                    if (!this.elementIsMesh) {
                        return $return(false);
                    }

                    this.setDefaultComponent(element, this.constructor.type);
                    element._needsToBeRendered();

                    return $return(true);
                }

                return $If_2.call(this);
            }.bind(this));
        }
    }, {
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(element, attr, oldValue, newValue) {
            return new Promise(function ($return, $error) {
                if (!this.checkedElementIsMesh) {
                    return this.checkElementIsMesh(element).then(function ($await_6) {
                        try {
                            return $If_3.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }

                function $If_3() {
                    if (!this.elementIsMesh) {
                        return $return(false);
                    }
                    return $return(true);
                }

                return $If_3.call(this);
            }.bind(this));
        }
    }, {
        key: 'createComponent',
        value: function createComponent() {
            throw new Error('`createComponent()` is not implemented by subclass.');
        }
    }, {
        key: 'checkElementIsMesh',
        value: function checkElementIsMesh(element) {
            return new Promise(function ($return, $error) {
                return this.isMeshPromise.then(function ($await_7) {
                    try {
                        this.elementIsMesh = $await_7;
                        this.checkedElementIsMesh = true;

                        if (!this.elementIsMesh) {
                            console.warn(this.constructor.name + " is only for use on elements of type Mesh, otherwise it won't do anything. You element was:", element);
                        }
                        return $return();
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }.bind(this), $error);
            }.bind(this));
        }
    }, {
        key: 'setMeshComponent',
        value: function setMeshComponent(element, name, newComponent) {
            if (element.threeObject3d[name]) {
                element.threeObject3d[name].dispose();
            }

            element.threeObject3d[name] = newComponent;
        }
    }, {
        key: 'setDefaultComponent',
        value: function setDefaultComponent(element, name) {
            this.setMeshComponent(element, name, this.makeDefaultComponent(element, name));
        }
    }, {
        key: 'makeDefaultComponent',
        value: function makeDefaultComponent(element, name) {
            if (name == 'geometry') {
                return new _three.BoxGeometry(element.calculatedSize.x, element.calculatedSize.y, element.calculatedSize.z);
            } else if (name == 'material') {
                return new _three.MeshPhongMaterial({ color: 0xff6600 });
            }
        }
    }]);

    return BaseMeshBehavior;
}((0, _ValueProcessor3.default)());

exports.default = BaseMeshBehavior;