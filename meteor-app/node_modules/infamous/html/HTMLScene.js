'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _HTMLScene = require('./HTMLScene.style');

var _HTMLScene2 = _interopRequireDefault(_HTMLScene);

var _Motor = require('../core/Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _Observable = require('../core/Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _Sizeable = require('../core/Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _DeclarativeBase2 = require('./DeclarativeBase');

var _DeclarativeBase3 = _interopRequireDefault(_DeclarativeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _DeclarativeBase2.initDeclarativeBase)();

var HTMLScene = function (_DeclarativeBase) {
    (0, _inherits3.default)(HTMLScene, _DeclarativeBase);

    function HTMLScene() {
        (0, _classCallCheck3.default)(this, HTMLScene);

        return (0, _possibleConstructorReturn3.default)(this, (HTMLScene.__proto__ || (0, _getPrototypeOf2.default)(HTMLScene)).apply(this, arguments));
    }

    (0, _createClass3.default)(HTMLScene, [{
        key: 'construct',
        value: function construct() {
            var this$1 = this;

            (0, _get3.default)(HTMLScene.prototype.__proto__ || (0, _getPrototypeOf2.default)(HTMLScene.prototype), 'construct', this).call(this);

            this._sizePollTask = null;
            this._parentSize = { x: 0, y: 0, z: 0

                // If the scene is already in the DOM, make it be "mounted".
            };if (!this._mounted && this.parentNode) {

                // defer so that the construct() call stack can finish
                //
                // TODO: clean up the code so that this isn't required. It's
                // just that combining the imperative/declarative classes
                // into a single class has introduced a small difference in
                // logic order.
                _promise2.default.resolve().then(function () {
                    return this$1.mount(this$1.parentNode);
                });
            }

            this._root = this.attachShadow({ mode: 'open' });
            this._root.innerHTML = "\n            <style>\n                .i-scene-CSS3DLayer,\n                .i-scene-WebGLLayer,\n                .i-scene-WebGLLayer > canvas  {\n                    margin: 0; padding: 0;\n                    width: 100%; height: 100%;\n                    display: block;\n                }\n                .i-scene-CSS3DLayer, .i-scene-WebGLLayer {\n                    position: absolute; top: 0; left: 0;\n                }\n                .i-scene-CSS3DLayer {\n                    transform-style: preserve-3d;\n                }\n                .i-scene-WebGLLayer {\n                    pointer-events: none;\n                }\n            </style>\n            <div class=\"i-scene-CSS3DLayer\">\n                <slot></slot>\n            </div>\n            <div class=\"i-scene-WebGLLayer\"></div>\n        ";
            this._canvasContainer = this._root.querySelector('.i-scene-WebGLLayer');
        }
    }, {
        key: '_startOrStopSizePolling',
        value: function _startOrStopSizePolling() {
            if (this._mounted && (this._properties.sizeMode.x == 'proportional' || this._properties.sizeMode.y == 'proportional' || this._properties.sizeMode.z == 'proportional')) {
                this._startSizePolling();
            } else {
                this._stopSizePolling();
            }
        }

        // observe size changes on the scene element.
        // HTML

    }, {
        key: '_startSizePolling',
        value: function _startSizePolling() {
            // NOTE Polling is currently required because there's no other way to do this
            // reliably, not even with MutationObserver. ResizeObserver hasn't
            // landed in browsers yet.
            if (!this._sizePollTask) {
                this._sizePollTask = _Motor2.default.addRenderTask(this._checkSize.bind(this));
            }
            this.on('parentsizechange', this._onElementParentSizeChange);
        }

        // Don't observe size changes on the scene element.
        // HTML

    }, {
        key: '_stopSizePolling',
        value: function _stopSizePolling() {
            this.off('parentsizechange', this._onElementParentSizeChange);
            _Motor2.default.removeRenderTask(this._sizePollTask);
            this._sizePollTask = null;
        }

        // NOTE, the Z dimension of a scene doesn't matter, it's a flat plane, so
        // we haven't taken that into consideration here.
        // HTML

    }, {
        key: '_checkSize',
        value: function _checkSize() {
            var parent = this.parentNode;
            var parentSize = this._parentSize;
            var style = getComputedStyle(parent);
            var width = parseFloat(style.width);
            var height = parseFloat(style.height);

            // if we have a size change, trigger parentsizechange
            if (parentSize.x != width || parentSize.y != height) {
                parentSize.x = width;
                parentSize.y = height;

                this.trigger('parentsizechange', (0, _assign2.default)({}, parentSize));
            }
        }

        /** @override */

    }, {
        key: 'getStyles',
        value: function getStyles() {
            return _HTMLScene2.default;
        }
    }, {
        key: 'deinit',
        value: function deinit() {
            (0, _get3.default)(HTMLScene.prototype.__proto__ || (0, _getPrototypeOf2.default)(HTMLScene.prototype), 'deinit', this).call(this);

            this.unmount();
        }
    }, {
        key: 'connectedCallback',
        value: function connectedCallback() {
            (0, _get3.default)(HTMLScene.prototype.__proto__ || (0, _getPrototypeOf2.default)(HTMLScene.prototype), 'connectedCallback', this).call(this);

            // When the HTMLScene gets addded to the DOM, make it be "mounted".
            if (!this._mounted) {
                this.mount(this.parentNode);
            }
        }
    }]);

    return HTMLScene;
}(_DeclarativeBase3.default);

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.


(0, _DeclarativeBase2.proxyGettersSetters)(_Sizeable2.default, HTMLScene);

exports.default = HTMLScene;