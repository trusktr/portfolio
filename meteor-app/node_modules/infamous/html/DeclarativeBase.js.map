{"version":3,"file":"DeclarativeBase.js","sources":["../../src/html/DeclarativeBase.js"],"sourcesContent":["/* global HTMLSlotElement */\n\nimport WebComponent from './WebComponent'\nimport HTMLNode from './HTMLNode'\nimport { observeChildren, /*getShadowRootVersion,*/ hasShadowDomV0,\n    hasShadowDomV1, getAncestorShadowRoot } from '../core/Utility'\n\nvar DeclarativeBase\n\n// We use this to Override HTMLElement.prototype.attachShadow in v1, and\n// HTMLElement.prototype.createShadowRoot in v0, so that we can make the\n// connection between parent and child on the iperative side when the HTML side\n// is using shadow roots.\nconst observers = new WeakMap\nfunction hijack(original) {\n    return function(...args) {\n        // In v0, shadow roots can be replaced, but in v1 calling attachShadow\n        // on an element that already has a root throws. So, we can set this to\n        // true, and if the try-catch passes then we know we have a v0 root and\n        // that the root was just replaced.\n        const oldRoot = this.shadowRoot\n        let root = null\n        try {\n            root = original.call(this, ...args)\n        }\n        catch (e) { throw e }\n        if (this instanceof DeclarativeBase) {\n            this._hasShadowRoot = true\n            if (oldRoot) {\n                onV0ShadowRootReplaced.call(this, oldRoot)\n            }\n            const observer = observeChildren(root, shadowRootChildAdded.bind(this), shadowRootChildRemoved.bind(this))\n            observers.set(root, observer)\n\n            const {children} = this\n            for (let l=children.length, i=0; i<l; i+=1) {\n                if (!(children[i] instanceof DeclarativeBase)) continue\n                children[i]._isPossiblyDistributed = true\n            }\n        }\n        return root\n    }\n}\n\nfunction shadowRootChildAdded(child) {\n\n    // NOTE Logic here is similar to childConnectedCallback\n\n    if (child instanceof DeclarativeBase) {\n        this.imperativeCounterpart.addChild(child.imperativeCounterpart)\n    }\n    else if (\n        hasShadowDomV0\n        && child instanceof HTMLContentElement\n    ) {\n        // observe <content> elements.\n    }\n    else if (\n        hasShadowDomV1\n        && child instanceof HTMLSlotElement\n    ) {\n        child.addEventListener('slotchange', this)\n        this._handleDistributedChildren(child)\n    }\n}\n\nfunction shadowRootChildRemoved(child) {\n\n    // NOTE Logic here is similar to childDisconnectedCallback\n\n    if (child instanceof DeclarativeBase) {\n        this.imperativeCounterpart.removeChild(child.imperativeCounterpart)\n    }\n    else if (\n        hasShadowDomV0\n        && child instanceof HTMLContentElement\n    ) {\n        // unobserve <content> element\n    }\n    else if (\n        hasShadowDomV1\n        && child instanceof HTMLSlotElement\n    ) {\n        child.removeEventListener('slotchange', this)\n        this._handleDistributedChildren(child)\n        this._slotElementsAssignedNodes.delete(child)\n    }\n}\n\nfunction onV0ShadowRootReplaced(oldRoot) {\n    observers.get(oldRoot).disconnect()\n    observers.delete(oldRoot)\n    const {childNodes} = oldRoot\n    for (let l=childNodes.length, i=0; i<l; i+=1) {\n        const child = childNodes[i]\n\n        if (!(child instanceof DeclarativeBase)) continue\n\n        // We should disconnect the imperative connection (f.e. so it is not\n        // rendered in WebGL)\n        this.imperativeCounterpart.removeChild(child.imperativeCounterpart, true)\n    }\n}\n\nif (HTMLElement.prototype.createShadowRoot instanceof Function)\n    HTMLElement.prototype.createShadowRoot = hijack(HTMLElement.prototype.createShadowRoot)\nif (HTMLElement.prototype.attachShadow instanceof Function)\n    HTMLElement.prototype.attachShadow = hijack(HTMLElement.prototype.attachShadow)\n\ninitDeclarativeBase()\nexport function initDeclarativeBase() {\n    if (DeclarativeBase) return\n\n    /**\n     * @implements {EventListener}\n     */\n    DeclarativeBase = class DeclarativeBase extends WebComponent(window.HTMLElement) {\n        constructor() {\n            super()\n\n            this.imperativeCounterpart = null // to hold the imperative API Node instance.\n\n            // true if this node has a shadow root (even if it is \"closed\", see\n            // hijack function above). Once true always true because shadow\n            // roots cannot be removed.\n            this._hasShadowRoot = false\n\n            // True when this node has a parent that has a shadow root. When\n            // using the HTML API, Imperative API can look at this to determine\n            // whether to render this node or not, in the case of WebGL.\n            this._isPossiblyDistributed = false\n\n            // A map of the slot elements that are children of this node and\n            // their last-known assigned nodes. When a slotchange happens while\n            // this node is in a shadow root and has a slot child, we can\n            // detect what the difference is between the last known and the new\n            // assignments, and notate the new distribution of child nodes. See\n            // issue #40 for background on why we do this.\n            this._slotElementsAssignedNodes = new WeakMap\n\n            // If this node is distributed into a shadow tree, this will\n            // reference the parent of the <slot> or <content> element.\n            // Basically, this node will render as a child of that parent node\n            // in the flat tree.\n            this._shadowParent = null\n\n            // If this element has a child <slot> or <content> element while in\n            // a shadow root, then this will be a Set of the nodes distributed\n            // into the <slot> or <content>, and those nodes render relatively\n            // to this node in the flat tree. We instantiate this later, only\n            // when/if needed.\n            this._shadowChildren = null\n\n            // We use Promise.resolve here to defer to the next microtask.\n            // While we support Custom Elements v0, this is necessary because\n            // the imperative Node counterpart will have already called the\n            // `_associateImperativeNode` method on this element, causing the\n            // next microtask's call to be a no-op. When this MotorHTML element\n            // API is used instead of the Imperative counterpart, then the next\n            // microtask's `_associateImperativeNode` call will not be a no-op.\n            // When we drop support for v0 Custom Elements at some point, we\n            // can rely on passing a constructor argument similarly to how we\n            // do with motor/Node in order to detect that the constructor is\n            // being called from the reciprocal API. See the constructor in\n            // motor/Node.js to get see the idea.\n            // TODO: renewable promise after unmount.\n            this._imperativeCounterpartPromise = Promise.resolve()\n                .then(() => this._associateImperativeNode())\n            this.mountPromise = this._imperativeCounterpartPromise\n                .then(() => this.imperativeCounterpart.mountPromise)\n        }\n\n        /**\n         * This method creates the association between this HTMLNode instance\n         * and the imperative Node instance.\n         *\n         * This method may get called by this.init, but can also be called by\n         * the Node class if Node is used imperatively. See Node#constructor.\n         *\n         * @private\n         *\n         * @param {Object} imperativeCounterpart The imperative counterpart to\n         * associate with this MotorHTML element. This parameter is only used in the\n         * imperative API constructors, and this happens when using the imperative\n         * form of infamous instead of the HTML interface to infamous. When the HTML\n         * interface is used, this gets called first without an\n         * imperativeCounterpart argument and the call to this in an imperative\n         * constructor will be a noop. Basically, either this gets called first by a\n         * MotorHTML element, or first by an imperative instance, depending on which\n         * API is used first.\n         */\n        _associateImperativeNode(imperativeCounterpart) {\n            // if the association is made already, noop\n            if (this.imperativeCounterpart) return\n\n            // if called from an imperative-side class' constructor, associate\n            // the passed instance.\n            if (imperativeCounterpart) this.imperativeCounterpart = imperativeCounterpart\n\n            // otherwise if called from a MotorHTML class without an argument\n            else this.imperativeCounterpart = this._makeImperativeCounterpart()\n        }\n\n        /**\n         * This method should be overriden by child classes. It should return the\n         * imperative-side instance that the HTML-side class (this) corresponds to.\n         * @abstract\n         */\n        _makeImperativeCounterpart() {\n            throw new TypeError('This method should be implemented by classes extending DeclarativeBase.')\n        }\n\n        childConnectedCallback(child) {\n\n            // mirror the DOM connections in the imperative API's virtual scene graph.\n            if (child instanceof HTMLNode) {\n                if (this._hasShadowRoot) child._isPossiblyDistributed = true\n\n                // If ImperativeBase#addChild was called first, child's\n                // _parent will already be set, so prevent recursion.\n                if (child.imperativeCounterpart._parent) return\n\n                this.imperativeCounterpart.addChild(child.imperativeCounterpart)\n            }\n            else if (\n                hasShadowDomV0\n                && child instanceof HTMLContentElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v0'\n            ) {\n                // observe <content> elements.\n            }\n            else if (\n                hasShadowDomV1\n                && child instanceof HTMLSlotElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v1'\n            ) {\n                child.addEventListener('slotchange', this)\n                this._handleDistributedChildren(child)\n            }\n        }\n\n        // This method is part of the EventListener interface.\n        handleEvent(event) {\n            if (event.type == 'slotchange') {\n                const slot = event.target\n                this._handleDistributedChildren(slot)\n            }\n        }\n\n        _handleDistributedChildren(slot) {\n            const diff = this._getDistributedChildDifference(slot)\n\n            const {added} = diff\n            for (let l=added.length, i=0; i<l; i+=1) {\n                const addedNode = added[i]\n\n                if (!(addedNode instanceof DeclarativeBase)) continue\n\n                // We do this because if the given slot is assigned to another\n                // slot, then this logic will run again for the next slot on\n                // that next slot's slotchange, so we remove the distributed\n                // node from the previous shadowParent and add it to the next\n                // one. If we don't do this, then the distributed node will\n                // exist in multiple shadowChildren lists when there is a\n                // chain of assigned slots. For more info, see\n                // https://github.com/w3c/webcomponents/issues/611\n                const shadowParent = addedNode._shadowParent\n                if (shadowParent && shadowParent._shadowChildren) {\n                    const shadowChildren = shadowParent._shadowChildren\n                    shadowChildren.splice(shadowChildren.indexOf(addedNode), 1)\n                    if (!shadowChildren.length)\n                        shadowParent._shadowChildren = null\n                }\n\n                addedNode._shadowParent = this\n                if (!this._shadowChildren) this._shadowChildren = []\n                this._shadowChildren.add(addedNode)\n            }\n\n            const {removed} = diff\n            for (let l=removed.length, i=0; i<l; i+=1) {\n                const removedNode = removed[i]\n\n                if (!(removedNode instanceof DeclarativeBase)) continue\n\n                removedNode._shadowParent = null\n                this._shadowChildren.delete(removedNode)\n                if (!this._shadowChildren.size) this._shadowChildren = null\n            }\n        }\n\n        _getDistributedChildDifference(slot) {\n            let previousNodes\n\n            if (this._slotElementsAssignedNodes.has(slot))\n                previousNodes = this._slotElementsAssignedNodes.get(slot)\n            else\n                previousNodes = []\n\n            const newNodes = slot.assignedNodes({flatten: true})\n\n            // save the newNodes to be used as the previousNodes for next time.\n            this._slotElementsAssignedNodes.set(slot, newNodes)\n\n            const diff = {\n                removed: [],\n            }\n\n            for (let i=0, l=previousNodes.length; i<l; i+=1) {\n                const oldNode = previousNodes[i]\n                const newIndex = newNodes.indexOf(oldNode)\n\n                // if it exists in the previousNodes but not the newNodes, then\n                // the node was removed.\n                if (!(newIndex >= 0)) {\n                    diff.removed.push(oldNode)\n                }\n\n                // otherwise the node wasn't added or removed.\n                else {\n                    newNodes.splice(i, 1)\n                }\n            }\n\n            // Remaining nodes in newNodes must have been added.\n            diff.added = newNodes\n\n            return diff\n        }\n\n        childDisconnectedCallback(child) {\n            // mirror the connection in the imperative API's virtual scene graph.\n            if (child instanceof HTMLNode) {\n                child._isPossiblyDistributed = false\n\n                // If ImperativeBase#removeChild was called first, child's\n                // _parent will already be null, so prevent recursion.\n                if (!child.imperativeCounterpart._parent) return\n\n                this.imperativeCounterpart.removeChild(child.imperativeCounterpart)\n            }\n            else if (\n                hasShadowDomV0\n                && child instanceof HTMLContentElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v0'\n            ) {\n                // unobserve <content> element\n            }\n            else if (\n                hasShadowDomV1\n                && child instanceof HTMLSlotElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v1'\n            ) {\n                child.removeEventListener('slotchange', this)\n                this._handleDistributedChildren(child)\n                this._slotElementsAssignedNodes.delete(child)\n            }\n        }\n\n        setAttribute(attr, value) {\n            //if (this.tagName.toLowerCase() == 'motor-scene')\n                //console.log('setting attribute', arguments[1])\n            super.setAttribute(attr, value)\n        }\n    }\n}\n\n// Creates setters/getters on the TargetClass which proxy to the\n// setters/getters on SourceClass.\nexport function proxyGettersSetters(SourceClass, TargetClass) {\n\n    // Node methods not to proxy (private underscored methods are also detected and\n    // ignored).\n    const methodProxyBlacklist = [\n        'constructor',\n        'parent',\n        'children', // proxying this one would really break stuff (f.e. React)\n        'element',\n        'scene',\n        'addChild',\n        'addChildren',\n        'removeChild',\n        'removeChildren',\n    ]\n\n    const props = Object.getOwnPropertyNames(SourceClass.prototype)\n\n    for (let l=props.length, i=0; i<l; i+=1) {\n        const prop = props[i]\n        if (\n            // skip the blacklisted properties\n            methodProxyBlacklist.indexOf(prop) >= 0\n\n            // skip the private underscored properties\n            || prop.indexOf('_') == 0\n\n            // skip properties that are already defined.\n            || TargetClass.prototype.hasOwnProperty(prop)\n        ) continue\n\n        const targetDescriptor = {}\n        const sourceDescriptor = Object.getOwnPropertyDescriptor(SourceClass.prototype, prop)\n\n        // if the property has a setter\n        if (sourceDescriptor.set) {\n            Object.assign(targetDescriptor, {\n                set(value) {\n                    this.imperativeCounterpart[prop] = value\n                }\n            })\n        }\n\n        // if the property has a getter\n        if (sourceDescriptor.get) {\n            Object.assign(targetDescriptor, {\n                get() {\n                    return this.imperativeCounterpart[prop]\n                }\n            })\n        }\n\n        Object.defineProperty(TargetClass.prototype, prop, targetDescriptor)\n    }\n}\n\nexport {DeclarativeBase as default}\n"],"names":[],"mappings":"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"}