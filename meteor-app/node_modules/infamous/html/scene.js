'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _sceneStyle = require('./scene-style');

var _sceneStyle2 = _interopRequireDefault(_sceneStyle);

var _Motor = require('../core/Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _Scene = require('../core/Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _Observable = require('../core/Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _Sizeable = require('../core/Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _WebGLRenderer = require('../core/WebGLRenderer');

var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _sleep = require('awaitbox/timers/sleep');

var _sleep2 = _interopRequireDefault(_sleep);

var _two = require('two.js/build/two');

var _two2 = _interopRequireDefault(_two);

require('document-register-element');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _base.initMotorHTMLBase)();

//import * as PIXI from 'pixi.js' // also sets the PIXI global.
//import SVG from 'pixi-svg' // uses the PIXI global, won't work if you don't import the main `pixi.js module`.


const privates = new WeakMap();
const _ = function (instance) {
    if (!privates.get(instance)) {
        privates.set(instance, {});
    }
    return privates.get(instance);
};

var MotorHTMLScene = function (superclass) {
    function MotorHTMLScene() {
        superclass.apply(this, arguments);
    }

    if (superclass) MotorHTMLScene.__proto__ = superclass;
    MotorHTMLScene.prototype = Object.create(superclass && superclass.prototype);
    MotorHTMLScene.prototype.constructor = MotorHTMLScene;

    MotorHTMLScene.prototype.createdCallback = function createdCallback() {
        var this$1 = this;

        superclass.prototype.createdCallback.call(this);

        this._sizePollTask = null;
        this._parentSize = { x: 0, y: 0, z: 0

            // After the imperativeCounterpart is available it needs to register
            // mount into DOM. This is only for MotorHTMLScenes because their
            // imperativeCounterparts are not added to a parent Node.
            // MotorHTMLNodes get their parent connection from their parent in
            // childConnectedCallback.
        };this._imperativeCounterpartPromise.then(function () {

            if (this$1.imperativeCounterpart._mounted) {
                return;
            }

            if (this$1.parentNode) {
                this$1.imperativeCounterpart.mount(this$1.parentNode);
            }
        });

        // For now, use the same program (with shaders) for all objects.
        // Basically it has position, frag colors, point light, directional
        // light, and ambient light.
        // TODO: maybe call this in `init()`, and destroy webgl stuff in
        // `deinit()`.
        // TODO: The user might enable this by setting the attribute later, so
        // we can't simply rely on having it in createdCallback, we need a
        // getter/setter like node properties.
        this.initWebGl();
    };

    // TODO: we need to deinit webgl too.
    MotorHTMLScene.prototype.initWebGl = function initWebGl() {
        var this$1 = this;

        // TODO: this needs to be cancelable too, search other codes for
        // "mountcancel" to see.
        this.mountPromise.then(function () {
            this$1.webglEnabled = !!this$1.getAttribute('webglenabled');
            if (!this$1.webglEnabled) {
                return;
            }
            this$1.webGlRendererState = {};
            (0, _WebGLRenderer2.default)().initGl(this$1);
        });
    };
    //async initWebGl() {
    //// TODO: this needs to be cancelable too, search other codes for
    //// "mountcancel" to see.
    //await this.mountPromise
    //this.webglEnabled = !!this.getAttribute('webglenabled')
    //if (!this.webglEnabled) return
    //this.webGlRendererState = {}
    //getWebGlRenderer().initGl(this)
    //}

    MotorHTMLScene.prototype._startSizePolling = function _startSizePolling() {
        // NOTE Polling is currently required because there's no other way to do this
        // reliably, not even with MutationObserver. ResizeObserver hasn't
        // landed in browsers yet.
        if (!this._sizePollTask) {
            this._sizePollTask = _Motor2.default.addRenderTask(this._checkSize.bind(this));
        }
    };

    // NOTE, the Z dimension of a scene doesn't matter, it's a flat plane, so
    // we haven't taken that into consideration here.
    MotorHTMLScene.prototype._checkSize = function _checkSize() {

        // The scene has a parent by the time this is called (see
        // src/core/Scene#mount where _startSizePolling is called)
        const parent = this.parentNode;
        const parentSize = this._parentSize;
        const style = getComputedStyle(parent);
        const width = parseFloat(style.width);
        const height = parseFloat(style.height);

        // if we have a size change, trigger parentsizechange
        if (parentSize.x != width || parentSize.y != height) {
            parentSize.x = width;
            parentSize.y = height;

            this.triggerEvent('parentsizechange', Object.assign({}, parentSize));
        }
    };

    MotorHTMLScene.prototype._makeImperativeCounterpart = function _makeImperativeCounterpart() {
        return new _Scene2.default({
            _motorHtmlCounterpart: this
        });
    };

    /** @override */
    MotorHTMLScene.prototype.getStyles = function getStyles() {
        return _sceneStyle2.default;
    };

    MotorHTMLScene.prototype.deinit = function deinit() {
        superclass.prototype.deinit.call(this);

        this.imperativeCounterpart.unmount();
    };

    MotorHTMLScene.prototype._stopSizePolling = function _stopSizePolling() {
        _Motor2.default.removeRenderTask(this._sizePollTask);
        this._sizePollTask = null;
    };

    return MotorHTMLScene;
}(_Observable2.default.mixin(_base2.default));

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.
(0, _base.proxyGettersSetters)(_Sizeable2.default, MotorHTMLScene);

exports.default = MotorHTMLScene = document.registerElement('motor-scene', MotorHTMLScene);

exports.default = MotorHTMLScene;
//# sourceMappingURL=scene.js.map