'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _nodeStyle = require('./node-style');

var _nodeStyle2 = _interopRequireDefault(_nodeStyle);

var _Node = require('../core/Node');

var _Node2 = _interopRequireDefault(_Node);

var _Transformable = require('../core/Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _Sizeable = require('../core/Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

require('document-register-element');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _base.initMotorHTMLBase)();

var MotorHTMLNode = function (MotorHTMLBase) {
    function MotorHTMLNode() {
        MotorHTMLBase.apply(this, arguments);
    }

    if (MotorHTMLBase) MotorHTMLNode.__proto__ = MotorHTMLBase;
    MotorHTMLNode.prototype = Object.create(MotorHTMLBase && MotorHTMLBase.prototype);
    MotorHTMLNode.prototype.constructor = MotorHTMLNode;

    MotorHTMLNode.prototype.getStyles = function getStyles() {
        return _nodeStyle2.default;
    };

    // this is called by DeclarativeBase#init, which is called by
    // WebComponent#connectedCallback, at which point this element has a
    // parentNode.
    // @override
    MotorHTMLNode.prototype._makeImperativeCounterpart = function _makeImperativeCounterpart() {
        return new _Node2.default({
            _motorHtmlCounterpart: this
        });
    };

    MotorHTMLNode.prototype.attributeChangedCallback = function attributeChangedCallback() {
        var this$1 = this;
        var args = [],
            len = arguments.length;
        while (len--) args[len] = arguments[len];

        MotorHTMLBase.prototype.attributeChangedCallback.apply(this, args);

        // TODO PERFORMANCE: we could possibly not stack a promise every
        // attribute change, and just cache the latest value to set it when the
        // imperativeCounterpart is ready.
        this._imperativeCounterpartPromise.then(function () {
            (ref = this$1)._updateNodeProperty.apply(ref, args);
            var ref;
        });
    };
    //async attributeChangedCallback(...args) {
    //super.attributeChangedCallback(...args)

    //// TODO PERFORMANCE: we could possibly not stack a promise every
    //// attribute change, and just cache the latest value to set it when the
    //// imperativeCounterpart is ready.
    //await this._imperativeCounterpartPromise
    //this._updateNodeProperty(...args)
    //}

    MotorHTMLNode.prototype._updateNodeProperty = function _updateNodeProperty(attribute, oldValue, newValue) {
        // attributes on our HTML elements are the same name as those on
        // the Node class (the setters).
        if (newValue !== oldValue) {
            if (attribute.match(/opacity/i)) {
                this.imperativeCounterpart[attribute] = window.parseFloat(newValue);
            } else if (attribute.match(/sizeMode/i)) {
                this.imperativeCounterpart[attribute] = parseStringArray(newValue);
            } else if (attribute.match(/rotation/i) || attribute.match(/scale/i) || attribute.match(/position/i) || attribute.match(/absoluteSize/i) || attribute.match(/proportionalSize/i) || attribute.match(/align/i) || attribute.match(/mountPoint/i) || attribute.match(/origin/i) || attribute.match(/skew/i)) {
                this.imperativeCounterpart[attribute] = parseNumberArray(newValue);
            } else {
                /* nothing, ignore other attributes */
            }
        }
    };

    return MotorHTMLNode;
}(_base2.default);

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.
(0, _base.proxyGettersSetters)(_Transformable2.default, MotorHTMLNode);
(0, _base.proxyGettersSetters)(_Sizeable2.default, MotorHTMLNode);

function parseNumberArray(str) {
    checkIsNumberArrayString(str);
    const numbers = str.trim().split(/(?:\s*,\s*)|(?:\s+)/g);
    const length = numbers.length;
    if (length > 0) {
        numbers[0] = window.parseFloat(numbers[0]);
    }
    if (length > 1) {
        numbers[1] = window.parseFloat(numbers[1]);
    }
    if (length > 2) {
        numbers[2] = window.parseFloat(numbers[2]);
    }
    return numbers;
}

function parseStringArray(str) {
    checkIsSizeArrayString(str);
    const strings = str.trim().toLowerCase().split(/(?:\s*,\s*)|(?:\s+)/g);
    const length = strings.length;
    if (length > 0) {
        strings[0] = strings[0];
    }
    if (length > 1) {
        strings[1] = strings[1];
    }
    if (length > 2) {
        strings[2] = strings[2];
    }
    return strings;
}

function checkIsNumberArrayString(str) {
    if (!str.match(/^\s*(((\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))\s*,){0,2}(\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))))|((\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+)))\s){0,2}(\s*(-|\+)?((\.\d+)|(\d+\.\d+)|(\d+)|(\d+(\.\d+)?e(-|\+)?(\d+))))))\s*$/g)) {
        throw new Error("Attribute must be a comma- or space-separated sequence of up to three numbers, for example \"1 2.5 3\". Yours was \"" + str + "\".");
    }
}

function checkIsSizeArrayString(str) {
    if (!str.match(/^\s*(((\s*([a-zA-Z]+)\s*,){0,2}(\s*([a-zA-Z]+)))|((\s*([a-zA-Z]+)\s*){1,3}))\s*$/g)) {
        throw new Error("Attribute must be a comma- or space-separated sequence of up to three strings, for example \"absolute absolute\". Yours was \"" + str + "\".");
    }
}

exports.default = MotorHTMLNode = document.registerElement('motor-node', MotorHTMLNode);

exports.default = MotorHTMLNode;
//# sourceMappingURL=node.js.map