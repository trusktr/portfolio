'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = WebComponentMixin;

var _construct = require('babel-runtime/core-js/reflect/construct');

var _construct2 = _interopRequireDefault(_construct);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _Utility = require('../core/Utility');

var _jss = require('../lib/jss');

var _jss2 = _interopRequireDefault(_jss);

var _documentReady = require('@awaitbox/document-ready');

var _documentReady2 = _interopRequireDefault(_documentReady);

var _DefaultBehaviors = require('./behaviors/DefaultBehaviors');

var _DefaultBehaviors2 = _interopRequireDefault(_DefaultBehaviors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _fixBabelExtend = function (O) {
    var gOPD = O.getOwnPropertyDescriptor,
        gPO = O.getPrototypeOf || function (o) {
        return o.__proto__;
    },
        sPO = O.setPrototypeOf || function (o, p) {
        o.__proto__ = p;
        return o;
    },
        construct = typeof Reflect === 'object' ? _construct2.default : function (Parent, args, Class) {
        var Constructor,
            a = [null];
        a.push.apply(a, args);
        Constructor = Parent.bind.apply(Parent, a);
        return sPO(new Constructor(), Class.prototype);
    };

    return function fixBabelExtend(Class) {
        var Parent = gPO(Class);
        return sPO(Class, sPO(function Super() {
            return construct(Parent, arguments, gPO(this).constructor);
        }, Parent));
    };
}(Object);

/* global customElements */

// Very very stupid hack needed for Safari in order for us to be able to extend
// the HTMLElement class. See:
// https://github.com/google/traceur-compiler/issues/1709
if (typeof window.HTMLElement != 'function') {
    var _HTMLElement = function HTMLElement() {};
    _HTMLElement.prototype = window.HTMLElement.prototype;
    window.HTMLElement = _HTMLElement;
}

var classCache = new _map2.default();

function classExtendsHTMLElement(constructor) {
    if (!constructor) {
        return false;
    }
    if (constructor === HTMLElement) {
        return true;
    } else {
        return classExtendsHTMLElement(constructor.__proto__);
    }
}

/**
 * Creates a WebComponent base class dynamically, depending on which
 * HTMLElement class you want it to extend from. Extend from WebComponent when
 * making a new Custom Element class.
 *
 * @example
 * const WebComponent = WebComponentMixin(HTMLButtonElement)
 * class AwesomeButton extends WebComponent { ... }
 *
 * @param {Function} elementClass The class that the generated WebComponent
 * base class will extend from.
 */
function WebComponentMixin(elementClass) {
    // the extra `class extends` is necessary here so that
    // babel-plugin-transform-builtin-classes can work properly.
    if (!elementClass) {
        elementClass = _fixBabelExtend(function (_HTMLElement2) {
            (0, _inherits3.default)(_class, _HTMLElement2);

            function _class() {
                (0, _classCallCheck3.default)(this, _class);

                return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).apply(this, arguments));
            }

            return _class;
        }(HTMLElement));
    }

    // XXX: In the future, possibly check for Element if other things besides
    // HTML are supported (f.e. SVGElements)
    if (!classExtendsHTMLElement(elementClass)) {
        throw new TypeError('The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.');
    }

    // if a base class that extends the given `elementClass` has already been
    // created, return it.
    if (classCache.has(elementClass)) {
        return classCache.get(elementClass);
    }

    // otherwise, create it.

    var WebComponent = function (_DefaultBehaviorsMixi) {
        (0, _inherits3.default)(WebComponent, _DefaultBehaviorsMixi);

        function WebComponent() {
            var args = [],
                len = arguments.length;
            while (len--) args[len] = arguments[len];

            (0, _classCallCheck3.default)(this, WebComponent);

            // Throw an error if no Custom Elements v1 API exists.
            if (!('customElements' in window)) {

                // TODO: provide a link to the Docs.
                throw new Error("\n                    Your browser does not support the Custom Elements API. You'll\n                    need to install a polyfill. See how at http://....\n                ");
            }

            // we are using `construct` because we were previously using the
            // document-register-element Custom Elements v1 polyfill.

            var _this2 = (0, _possibleConstructorReturn3.default)(this, (ref = WebComponent.__proto__ || (0, _getPrototypeOf2.default)(WebComponent)).call.apply(ref, [this].concat(args)));

            _this2.construct.apply(_this2, args);
            return _this2;
            var ref;
        }

        // subclasses extend this, and they should not use `constructor`
        // directly.


        (0, _createClass3.default)(WebComponent, [{
            key: 'construct',
            value: function construct() {
                (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'construct', this).call(this);
                this._connected = false;
                this._initialized = false;
                this._initialAttributeChange = false;
                this._childObserver = null;
                this._style = null;
            }

            // Subclasses can implement these.

        }, {
            key: 'childConnectedCallback',
            value: function childConnectedCallback(child) {}
        }, {
            key: 'childDisconnectedCallback',
            value: function childDisconnectedCallback(child) {}
        }, {
            key: 'connectedCallback',
            value: function connectedCallback() {
                if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'connectedCallback', this)) {
                    (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'connectedCallback', this).call(this);
                }
                this._connected = true;

                if (!this._initialized) {
                    this.init();
                    this._initialized = true;
                }
            }
        }, {
            key: '_createStyles',
            value: function _createStyles() {
                var rule = _jss2.default.createRule(this.getStyles());

                rule.applyTo(this);

                return rule;
            }
        }, {
            key: 'disconnectedCallback',
            value: function disconnectedCallback() {
                return new Promise(function ($return, $error) {
                    if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'disconnectedCallback', this)) {
                        (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'disconnectedCallback', this).call(this);
                    }
                    this._connected = false;

                    // Deferr to the next tick before cleaning up in case the
                    // element is actually being re-attached somewhere else within this
                    // same tick (detaching and attaching is synchronous, so by
                    // deferring to the next tick we'll be able to know if the element
                    // was re-attached or not in order to clean up or not). Note that
                    // appendChild can be used to move an element to another parent
                    // element, in which case connectedCallback and disconnectedCallback
                    // both get called, and in which case we don't necessarily want to
                    // clean up. If the element gets re-attached before the next tick
                    // (for example, gets moved), then we want to preserve the
                    // stuff that would be cleaned up by an extending class' deinit
                    // method by not running the following this.deinit() call.
                    return _promise2.default.resolve().then(function ($await_1) {
                        try {
                            // deferr to the next tick.

                            // As mentioned in the previous comment, if the element was not
                            // re-attached in the last tick (for example, it was moved to
                            // another element), then clean up.
                            if (!this._connected && this._initialized) {
                                this.deinit();
                            }
                            return $return();
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }.bind(this), $error);
                }.bind(this));
            }

            /**
             * This method can be overridden by extending classes, it should return
             * JSS-compatible styling. See http://github.com/cssinjs/jss for
             * documentation.
             * @abstract
             */

        }, {
            key: 'getStyles',
            value: function getStyles() {
                return {};
            }

            /**
             * Init is called exactly once, the first time this element is
             * connected into the DOM. When an element is disconnected then
             * connected right away within the same synchronous tick, init() is not
             * fired again. However, if an element is disconnected and the current
             * tick completes before the element is connected again, then deinit()
             * will be called (i.e. the element was not simply moved to a new
             * location, it was actually removed), then the next time that the
             * element is connected back into DOM init() will be called again.
             *
             * This is in contrast to connectedCallback and disconnectedCallback:
             * connectedCallback is guaranteed to always fire even if the elemet
             * was previously disconnected in the same synchronous tick.
             *
             * For example, ...
             *
             * Subclasses should extend this to add such logic.
             */

        }, {
            key: 'init',
            value: function init() {
                var this$1 = this;

                if (!this._style) {
                    this._style = this._createStyles();
                }

                // Timeout needed in case the Custom Element classes are
                // registered after the elements are already defined in the
                // DOM but not yet upgraded. This means that the `node` arg
                // might be a `<motor-node>` but if it isn't upgraded then
                // its API won't be available to the logic inside the
                // childConnectedCallback. The reason this happens is
                // because parents are upgraded first and their
                // connectedCallbacks fired before their children are
                // upgraded.
                //
                //setTimeout(() => {
                //Promise.resolve().then(() => {
                (0, _documentReady2.default)().then(function () {

                    // Handle any nodes that may have been connected before `this` node
                    // was created (f.e. child nodes that were connected before the
                    // custom elements were registered and which would therefore not be
                    // detected by the following MutationObserver).
                    if (!this$1._childObserver) {

                        var children = this$1.childNodes;
                        for (var l = children.length, i = 0; i < l; i += 1) {
                            this$1.childConnectedCallback(children[i]);
                        }

                        this$1._childObserver = (0, _Utility.observeChildren)(this$1, this$1.childConnectedCallback, this$1.childDisconnectedCallback);
                    }
                });
                //}, 0)

                // fire this.attributeChangedCallback in case some attributes have
                // existed before the custom element was upgraded.
                if (!this._initialAttributeChange && this.hasAttributes()) {

                    // HTMLElement#attributes is a NamedNodeMap which is not an
                    // iterable, so we use Array.from. See:
                    // https://github.com/zloirock/core-js/issues/234
                    var ref = this;
                    var attributes = ref.attributes;
                    for (var l = attributes.length, i = 0; i < l; i += 1) {
                        this$1.attributeChangedCallback(attributes[i].name, null, attributes[i].value);
                    }
                }
            }
        }, {
            key: 'attributeChangedCallback',

            // TODO: when we make setAttribute accept non-strings, we need to move
            // logic from attributeChangedCallback
            value: function attributeChangedCallback() {
                var args = [],
                    len = arguments.length;
                while (len--) args[len] = arguments[len];

                if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'attributeChangedCallback', this)) {
                    (ref = (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'attributeChangedCallback', this)).call.apply(ref, [this].concat(args));
                }
                this._initialAttributeChange = true;
                var ref;
            }

            /**
             * This is the reciprocal of init(). It will be called when an element
             * has been disconnected but not re-connected within the same tick.
             *
             * The reason that init() and deinit() exist is so that if an element is
             * moved from one place to another within the same synchronous tick,
             * that deinit and init logic will not fire unnecessarily. If logic is
             * needed in that case, then connectedCallback and disconnectedCallback
             * can be used directly instead.
             */

        }, {
            key: 'deinit',
            value: function deinit() {
                // Nothing much at the moment, but extending classes can extend
                // this to add deintialization logic.

                this._initialized = false;
            }
        }], [{
            key: 'observedAttributes',
            get: function () {
                console.warn("WebComponent: Your custom element (" + this.name + ") should specify observed attributes or attributeChangedCallback won't be called");
            }
        }]);

        return WebComponent;
    }((0, _DefaultBehaviors2.default)(elementClass));

    classCache.set(elementClass, WebComponent);
    return WebComponent;
}