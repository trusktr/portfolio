'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Cube = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _forLength = require('army-knife/forLength');

var _forLength2 = _interopRequireDefault(_forLength);

var _Node2 = require('../core/Node');

var _Node3 = _interopRequireDefault(_Node2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A scenegraph tree that lays things out in a cube form.
 *
 * TODO: extend from i-mesh, using a Cube geometry? Or perhaps this is a
 * CubeLayout, not necessarily a Cube mesh.
 *
 * TODO: this is written imperatively. How would it be declaratively?
 *
 * @class Cube
 * @extends Node
 */

/*
 * LICENSE
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 */
var Cube = exports.Cube = function (_Node) {
    (0, _inherits3.default)(Cube, _Node);

    function Cube() {
        (0, _classCallCheck3.default)(this, Cube);

        return (0, _possibleConstructorReturn3.default)(this, (Cube.__proto__ || (0, _getPrototypeOf2.default)(Cube)).apply(this, arguments));
    }

    (0, _createClass3.default)(Cube, [{
        key: 'construct',

        /**
         * Create a new Cube.
         *
         * @constructor
         * @param {Number} size The integer width of the cube.
         */
        value: function construct(size, options) {
            var this$1 = this;

            // cubes, the same size on all sides
            (0, _get3.default)(Cube.prototype.__proto__ || (0, _getPrototypeOf2.default)(Cube.prototype), 'construct', this).call(this, (0, _extends3.default)({ size: [size, size, size] }, options));

            //GenericSync.register({
            //mouse: MouseSync,
            //touch: TouchSync
            //});

            this.size = size;
            this.sides = [];

            (0, _forLength2.default)(6, function (n) {
                return this$1._createCubeSide(n);
            });
        }

        /**
         * Creates the 6 sides of the cube (the leafnodes of the scenegraph).
         *
         * @private
         * @param {Number} index The index (a integer between 0 and 5) that specifies which side to create.
         */

    }, {
        key: '_createCubeSide',
        value: function _createCubeSide(index) {
            var rotator = new _Node3.default({
                align: [0.5, 0.5],
                mountPoint: [0.5, 0.5]
            });

            var side = new _Node3.default({
                align: [0.5, 0.5],
                mountPoint: [0.5, 0.5],
                size: [this.size, this.size]
            });

            this.sides.push(side);

            rotator.add(side);

            // TODO: make a new GenericSync-like thing based on Famous?
            //const sync = new GenericSync(['mouse','touch']);
            //side.pipe(sync);
            //sync.pipe(this.options.handler);

            // rotate and place each side.
            if (index < 4) // 4 sides
                {
                    rotator.rotation.y = 90 * index;
                } else // top/bottom
                {
                    rotator.rotation.x = 90 * (index % 2 ? -1 : 1);
                }

            side.position.z = this.size / 2;

            this.add(rotator);
        }

        /**
         * Set the content for the sides of the cube.
         *
         * @param {Array} content An array containing [Node](#infamous/motor/Node)
         * instances to place in the cube sides. Only the first 6 items are used,
         * the rest are ignored.
         */

    }, {
        key: 'setContent',
        value: function setContent(content) {
            var this$1 = this;

            (0, _forLength2.default)(6, function (index) {
                //this.cubeSideNodes[index].set(null); // TODO: how do we erase previous content?
                this$1.sides[index].add(content[index]);
            });
            return this;
        }
    }]);

    return Cube;
}(_Node3.default);
exports.default = Cube;