import Node from './Node'
import Motor from './Motor'

/**
 * Manages a DOM element. Exposes a set of recommended APIs for working with
 * DOM efficiently. Currently doesn't do much yet...
 */
var ElementManager = function ElementManager(element) {
    this.element = element
};

/**
 * @param {Array.string} classes An array of class names to add to the
 * managed element.
 *
 * Note: updating class names with `el.classList.add()` won't thrash the
 * layout. See: http://www.html5rocks.com/en/tutorials/speed/animations
 */
ElementManager.prototype.setClasses = function setClasses () {
        var classes = [], len = arguments.length;
        while ( len-- ) classes[ len ] = arguments[ len ];

    if (classes.length) { (ref = this.element.classList).add.apply(ref, classes) }
    return this
        var ref;
};

/**
 * Apply a style property to the element.
 *
 * @private
 * @param  {string} property The CSS property we will a apply.
 * @param  {string} valueThe value the CSS property wil have.
 */
ElementManager.prototype.applyStyle = function applyStyle (property, value) {
    this.element.style[property] = value
};

ElementManager.prototype.addChild = function addChild (childElementManager) {
    this.element.appendChild(childElementManager.element)
};

ElementManager.prototype.removeChild = function removeChild (childElementManager) {
    // This conditional check is needed incase the element was already
    // removed from the HTML-API side.
    if (childElementManager.element.parentNode === this.element)
        { this.element.removeChild(childElementManager.element) }
};

ElementManager.prototype.connectChildElement = function connectChildElement (childImperativeNode) {
    if (

        // When using the imperative API, this statement is
        // true, so the DOM elements need to be connected.
        !childImperativeNode._elementManager.element.parentNode

        // This condition is irrelevant when strictly using the
        // imperative API. However, it is possible that when
        // using the HTML API that the HTML-API node can be placed
        // somewhere that isn't another HTML-API node, and the
        // imperative Node can be gotten and used to add the
        // node to another imperative Node. In this case, the
        // HTML-API node will be added to the proper HTMLparent.
        || (childImperativeNode._elementManager.element.parentElement &&
            childImperativeNode._elementManager.element.parentElement !== this.element)

        // When an HTML-API node is already child of the
        // relevant parent, or it is child of a shadow root of
        // the relevant parent, there there's nothing to do,
        // everything is already as expected, so the following
        // conditional body is skipped.
    ) {
        this.addChild(childImperativeNode._elementManager)
    }
};

ElementManager.prototype.disconnectChildElement = function disconnectChildElement (childImperativeNode) {
    // If DeclarativeBase#removeChild was called first, we don't need to
    // call this again.
    if (!childImperativeNode._elementManager.element.parentNode) { return }

    this.removeChild(childImperativeNode._elementManager)
};

/**
 * Apply the DOMMatrix value to the style of this Node's element.
 */
ElementManager.prototype.applyTransform = function applyTransform (domMatrix) {
    var cssMatrixString = "matrix3d(\n            " + (domMatrix.m11) + ",\n            " + (domMatrix.m12) + ",\n            " + (domMatrix.m13) + ",\n            " + (domMatrix.m14) + ",\n            " + (domMatrix.m21) + ",\n            " + (domMatrix.m22) + ",\n            " + (domMatrix.m23) + ",\n            " + (domMatrix.m24) + ",\n            " + (domMatrix.m31) + ",\n            " + (domMatrix.m32) + ",\n            " + (domMatrix.m33) + ",\n            " + (domMatrix.m34) + ",\n            " + (domMatrix.m41) + ",\n            " + (domMatrix.m42) + ",\n            " + (domMatrix.m43) + ",\n            " + (domMatrix.m44) + "\n        )";

    this.applyStyle('transform', cssMatrixString)
};

/**
 * [applySize description]
 */
ElementManager.prototype.applySize = function applySize (size) {
    var x = size.x;
        var y = size.y;

    this.applyStyle('width', (x + "px"))
    this.applyStyle('height', (y + "px"))

    // NOTE: we ignore the Z axis on elements, since they are flat.
};

ElementManager.prototype.applyOpacity = function applyOpacity (opacity) {
    this.applyStyle('opacity', opacity)
};

ElementManager.prototype.applyImperativeNodeProperties = function applyImperativeNodeProperties (node) {

    // Only Node is Transformable
    if (node instanceof Node) {
        this.applyOpacity(node._properties.opacity)
        this.applyTransform(node._properties.transform)
    }

    // But both Node and Scene are Sizeable
    this.applySize(node._calculatedSize)
};

ElementManager.prototype.shouldRender = function shouldRender () {
        var this$1 = this;

    const task = Motor.addRenderTask(function () {
        this$1.applyStyle('display', 'block')
        Motor.removeRenderTask(task)
    })
};

ElementManager.prototype.shouldNotRender = function shouldNotRender () {
        var this$1 = this;

    const task = Motor.addRenderTask(function () {
        this$1.applyStyle('display', 'none')
        Motor.removeRenderTask(task)
    })
};

export {ElementManager as default}
