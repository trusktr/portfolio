{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../lume+custom-attributes/pkg/dist-umd/index.js","webpack:///./src/index.js"],"names":["BehaviorRegistry","constructor","_definedBehaviors","Map","define","name","Behavior","has","set","Error","get","window","elementBehaviors","BehaviorMap","behaviorMaps","WeakMap","Object","defineProperty","Element","prototype","thisBehaviors","HasAttribute","observers","connectedCallback","behaviors","ownerElement","changedCallback","value","disconnectedCallback","oldVal","newVal","newBehaviors","getBehaviorNames","previousBehaviors","Array","from","keys","length","removed","added","getDiff","handleDiff","string","trim","split","diff","i","l","oldBehavior","includes","push","splice","indexOf","behavior","parentNode","destroyAttributeObserver","delete","observedAttributes","isArray","fireInitialAttributeChangedCallbacks","createAttributeObserver","disconnect","observer","MutationObserver","records","record","attributeChangedCallback","attributeName","oldValue","getAttribute","observe","attributes","attributeOldValue","attributeFilter","attr","customAttributes","attachShadow","_attachShadow","args","root","call","CustomAttributeRegistry","version"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA;AACA,EAAE,KAA4D;AAC9D,EAAE,SACgE;AAClE,CAAC,2BAA2B;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,sEAAsE;;AAEtE;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA,gDAAgD,cAAc;;AAE9D,CAAC;;;;;;;;AChMD;AAAA;AAAA;AAAA;CAEA;AACA;AACA;;AAEA,MAAMA,gBAAN,CAAuB;AACnBC,gBAAc;AACV,SAAKC,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;AACH;;AAEDC,SAAOC,IAAP,EAAaC,QAAb,EAAuB;AACnB,QAAI,CAAC,KAAKJ,iBAAL,CAAuBK,GAAvB,CAA2BF,IAA3B,CAAL,EAAuC;AACnC,WAAKH,iBAAL,CAAuBM,GAAvB,CAA2BH,IAA3B,EAAiCC,QAAjC;AACH,KAFD,MAEO;AACH,YAAM,IAAIG,KAAJ,CAAW,YAAWJ,IAAK,sBAA3B,CAAN;AACH;AACJ;;AAEDK,MAAIL,IAAJ,EAAU;AACN,WAAO,KAAKH,iBAAL,CAAuBQ,GAAvB,CAA2BL,IAA3B,CAAP;AACH;;AAEDE,MAAIF,IAAJ,EAAU;AACN,WAAO,KAAKH,iBAAL,CAAuBK,GAAvB,CAA2BF,IAA3B,CAAP;AACH;;AAnBkB;;AAsBvBM,OAAOC,gBAAP,GAA0B,IAAIZ,gBAAJ,EAA1B,C,CAEA;;AACA,MAAMa,WAAN,SAA0BV,GAA1B,CAA8B,E,CAE9B;;;AACA,MAAMW,eAAe,IAAIC,OAAJ,EAArB,C,CAEA;AACA;AACA;;AACAC,OAAOC,cAAP,CAAsBC,QAAQC,SAA9B,EAAyC,WAAzC,EAAsD;AAClDT,QAAM;AACF,QAAIU,gBAAgB,IAApB;;AAEA,QAAI,CAACN,aAAaP,GAAb,CAAiB,IAAjB,CAAL,EAA6B;AACzBO,mBAAaN,GAAb,CAAiB,IAAjB,EAAwBY,gBAAgB,IAAIP,WAAJ,EAAxC;AACH,KAFD,MAEOO,gBAAgBN,aAAaJ,GAAb,CAAiB,IAAjB,CAAhB;;AAEP,WAAOU,aAAP;AACH;;AATiD,CAAtD,E,CAYA;;AACA,MAAMC,YAAN,CAAmB;AACfpB,gBAAc;AACV;AAEA,SAAKqB,SAAL,GAAiB,IAAInB,GAAJ,EAAjB;AACH;;AAEDoB,sBAAoB;AAChB,SAAKC,SAAL,GAAiB,KAAKC,YAAL,CAAkBD,SAAnC;AACA,SAAKE,eAAL,CAAqB,EAArB,EAAyB,KAAKC,KAA9B;AACH;;AAEDC,yBAAuB;AACnB,SAAKF,eAAL,CAAqB,KAAKC,KAA1B,EAAiC,EAAjC;AACA,WAAO,KAAKH,SAAZ;AACH;;AAEDE,kBAAgBG,MAAhB,EAAwBC,MAAxB,EAAgC;AAC5B,UAAMC,eAAe,KAAKC,gBAAL,CAAsBF,MAAtB,CAArB;AACA,UAAMG,oBAAoBC,MAAMC,IAAN,CAAW,KAAKX,SAAL,CAAeY,IAAf,EAAX,CAA1B,CAF4B,CAI5B;AACA;;AACA,QAAIL,aAAaM,MAAb,IAAuB,CAAvB,IAA4BJ,kBAAkBI,MAAlB,IAA4B,CAA5D,EAA+D;AAE/D,UAAM;AAAEC,aAAF;AAAWC;AAAX,QAAqB,KAAKC,OAAL,CAAaP,iBAAb,EAAgCF,YAAhC,CAA3B;AACA,SAAKU,UAAL,CAAgBH,OAAhB,EAAyBC,KAAzB;AACH;;AAEDP,mBAAiBU,MAAjB,EAAyB;AACrB,QAAIA,OAAOC,IAAP,MAAiB,EAArB,EAAyB,OAAO,EAAP,CAAzB,KACK,OAAOD,OAAOE,KAAP,CAAa,KAAb,CAAP;AACR;;AAEDJ,UAAQP,iBAAR,EAA2BF,YAA3B,EAAyC;AACrC,UAAMc,OAAO;AACTP,eAAS,EADA;AAETC,aAAOR;AAFE,KAAb;;AAKA,SAAK,IAAIe,IAAI,CAAR,EAAWC,IAAId,kBAAkBI,MAAtC,EAA8CS,IAAIC,CAAlD,EAAqDD,KAAK,CAA1D,EAA6D;AACzD,YAAME,cAAcf,kBAAkBa,CAAlB,CAApB,CADyD,CAGzD;AACA;;AACA,UAAI,CAACD,KAAKN,KAAL,CAAWU,QAAX,CAAoBD,WAApB,CAAL,EAAuC;AACnCH,aAAKP,OAAL,CAAaY,IAAb,CAAkBF,WAAlB;AACH,OAFD,CAIA;AACA;AACA;AANA,WAOK;AACDH,eAAKN,KAAL,CAAWY,MAAX,CAAkBN,KAAKN,KAAL,CAAWa,OAAX,CAAmBJ,WAAnB,CAAlB,EAAmD,CAAnD;AACH;AACJ;;AAED,WAAOH,IAAP;AACH;;AAEDJ,aAAWH,OAAX,EAAoBC,KAApB,EAA2B;AACvB,SAAK,MAAMlC,IAAX,IAAmBiC,OAAnB,EAA4B;AACxB,UAAI,CAAC1B,iBAAiBL,GAAjB,CAAqBF,IAArB,CAAL,EAAiC;AAEjC,YAAMgD,WAAW,KAAK7B,SAAL,CAAed,GAAf,CAAmBL,IAAnB,CAAjB,CAHwB,CAKxB;AACA;AACA;;AACA,UAAI,KAAKoB,YAAL,CAAkB6B,UAAtB,EAAkC;AAC9BD,iBAASzB,oBAAT;AACH,OAVuB,CAYxB;AACA;AACA;AACA;;;AACA,UAAI,KAAKN,SAAL,CAAef,GAAf,CAAmB8C,QAAnB,CAAJ,EAAkC;AAC9B,aAAKE,wBAAL,CAA8BF,QAA9B;AACH;;AAED,WAAK7B,SAAL,CAAegC,MAAf,CAAsBnD,IAAtB;AACH;;AAED,SAAK,MAAMA,IAAX,IAAmBkC,KAAnB,EAA0B;AACtB,UAAI,CAAC3B,iBAAiBL,GAAjB,CAAqBF,IAArB,CAAL,EAAiC;AAEjC,YAAMC,WAAWM,iBAAiBF,GAAjB,CAAqBL,IAArB,CAAjB;AACA,YAAMgD,WAAW,IAAI/C,QAAJ,CAAa,KAAKmB,YAAlB,CAAjB;AACA,WAAKD,SAAL,CAAehB,GAAf,CAAmBH,IAAnB,EAAyBgD,QAAzB,EALsB,CAOtB;AACA;AACA;;AACA,YAAMI,qBAAqBJ,SAASpD,WAAT,CAAqBwD,kBAAhD,CAVsB,CAYtB;AACA;AACA;;AACA,UAAI,KAAKhC,YAAL,CAAkB6B,UAAtB,EAAkC;AAC9BD,iBAAS9B,iBAAT;AACH;;AAED,UAAIW,MAAMwB,OAAN,CAAcD,kBAAd,CAAJ,EAAuC;AACnC,aAAKE,oCAAL,CAA0CN,QAA1C;AACA,aAAKO,uBAAL,CAA6BP,QAA7B;AACH;AACJ;AACJ;;AAEDE,2BAAyBF,QAAzB,EAAmC;AAC/B,SAAK/B,SAAL,CAAeZ,GAAf,CAAmB2C,QAAnB,EAA6BQ,UAA7B;AACA,SAAKvC,SAAL,CAAekC,MAAf,CAAsBH,QAAtB;AACH,GAjHc,CAmHf;AACA;AACA;AACA;AACA;;;AACAO,0BAAwBP,QAAxB,EAAkC;AAC9B,UAAMS,WAAW,IAAIC,gBAAJ,CAAqBC,WAAW;AAC7C,WAAK,MAAMC,MAAX,IAAqBD,OAArB,EAA8B;AAC1BX,iBAASa,wBAAT,CACID,OAAOE,aADX,EAEIF,OAAOG,QAFX,EAGI,KAAK3C,YAAL,CAAkB4C,YAAlB,CAA+BJ,OAAOE,aAAtC,CAHJ;AAKH;AACJ,KARgB,CAAjB;AAUAL,aAASQ,OAAT,CAAiB,KAAK7C,YAAtB,EAAoC;AAChC8C,kBAAY,IADoB;AAEhCC,yBAAmB,IAFa;AAGhCC,uBAAiBpB,SAASpD,WAAT,CAAqBwD;AAHN,KAApC;AAMA,SAAKnC,SAAL,CAAed,GAAf,CAAmB6C,QAAnB,EAA6BS,QAA7B;AACH;;AAEDH,uCAAqCN,QAArC,EAA+C;AAC3C,QAAI,CAACnB,MAAMwB,OAAN,CAAcL,SAASpD,WAAT,CAAqBwD,kBAAnC,CAAL,EAA6D;;AAE7D,SAAK,MAAMiB,IAAX,IAAmBxC,MAAMC,IAAN,CAAW,KAAKV,YAAL,CAAkB8C,UAA7B,CAAnB,EAA6D;AACzD,UAAI,CAAClB,SAASpD,WAAT,CAAqBwD,kBAArB,CAAwCR,QAAxC,CAAiDyB,KAAKrE,IAAtD,CAAL,EAAkE;AAClE,UAAIgD,SAASa,wBAAb,EACIb,SAASa,wBAAT,CAAkCQ,KAAKrE,IAAvC,EAA6C,IAA7C,EAAmDqE,KAAK/C,KAAxD;AACP;AACJ;;AApJc;;AAuJnBgD,qEAAgBA,CAACvE,MAAjB,CAAwB,KAAxB,EAA+BiB,YAA/B;;AAEA,IAAIH,QAAQC,SAAR,CAAkByD,YAAtB,EAAoC;AAChC,QAAMC,gBAAgB3D,QAAQC,SAAR,CAAkByD,YAAxC;;AAEA1D,UAAQC,SAAR,CAAkByD,YAAlB,GAAiC,UAAS,GAAGE,IAAZ,EAAkB;AAC/C,UAAMC,OAAOF,cAAcG,IAAd,CAAmB,IAAnB,EAAyB,GAAGF,IAA5B,CAAb;;AACA,UAAMP,aAAa,IAAIU,sFAAJ,CAA4BF,IAA5B,CAAnB;AAEAR,eAAWnE,MAAX,CAAkB,KAAlB,EAAyBiB,YAAzB;AAEA,WAAO0D,IAAP;AACH,GAPD;AAQH,C,CAED;AACA;;;AACO,MAAMG,UAAU,OAAhB,C","file":"global.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.customAttributes = {}));\n}(this, function (exports) { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  var forEach = Array.prototype.forEach;\n\n  var CustomAttributeRegistry =\n  /*#__PURE__*/\n  function () {\n    function CustomAttributeRegistry(ownerDocument) {\n      _classCallCheck(this, CustomAttributeRegistry);\n\n      if (!ownerDocument) {\n        throw new Error(\"Must be given a document\");\n      }\n\n      this.ownerDocument = ownerDocument;\n      this._attrMap = new Map();\n      this._elementMap = new WeakMap();\n\n      this._observe();\n    }\n\n    _createClass(CustomAttributeRegistry, [{\n      key: \"define\",\n      value: function define(attrName, Constructor) {\n        this._attrMap.set(attrName, Constructor);\n\n        this._upgradeAttr(attrName);\n      }\n    }, {\n      key: \"get\",\n      value: function get(element, attrName) {\n        var map = this._elementMap.get(element);\n\n        if (!map) return;\n        return map.get(attrName);\n      }\n    }, {\n      key: \"_getConstructor\",\n      value: function _getConstructor(attrName) {\n        return this._attrMap.get(attrName);\n      }\n    }, {\n      key: \"_observe\",\n      value: function _observe() {\n        var customAttributes = this;\n        var root = this.ownerDocument;\n\n        var downgrade = this._downgrade.bind(this);\n\n        var upgrade = this._upgradeElement.bind(this);\n\n        this.observer = new MutationObserver(function (mutations) {\n          forEach.call(mutations, function (m) {\n            if (m.type === 'attributes') {\n              var attr = customAttributes._getConstructor(m.attributeName);\n\n              if (attr) {\n                customAttributes._found(m.attributeName, m.target, m.oldValue);\n              }\n            } // chlidList\n            else {\n                forEach.call(m.removedNodes, downgrade);\n                forEach.call(m.addedNodes, upgrade);\n              }\n          });\n        });\n        this.observer.observe(root, {\n          childList: true,\n          subtree: true,\n          attributes: true,\n          attributeOldValue: true\n        });\n      }\n    }, {\n      key: \"_upgradeAttr\",\n      value: function _upgradeAttr(attrName, document) {\n        document = document || this.ownerDocument;\n        var matches = document.querySelectorAll(\"[\" + attrName + \"]\"); // Use a forEach as Edge doesn't support for...of on a NodeList\n\n        forEach.call(matches, function (match) {\n          this._found(attrName, match);\n        }, this);\n      }\n    }, {\n      key: \"_upgradeElement\",\n      value: function _upgradeElement(element) {\n        if (element.nodeType !== 1) return; // Use a forEach as Safari 10 doesn't support for...of on NamedNodeMap (attributes)\n\n        forEach.call(element.attributes, function (attr) {\n          if (this._getConstructor(attr.name)) {\n            this._found(attr.name, element);\n          }\n        }, this);\n\n        this._attrMap.forEach(function (constructor, attr) {\n          this._upgradeAttr(attr, element);\n        }, this);\n      }\n    }, {\n      key: \"_downgrade\",\n      value: function _downgrade(element) {\n        var map = this._elementMap.get(element);\n\n        if (!map) return;\n        map.forEach(function (inst) {\n          if (inst.disconnectedCallback) {\n            inst.disconnectedCallback();\n          }\n        }, this);\n\n        this._elementMap.delete(element);\n      }\n    }, {\n      key: \"_found\",\n      value: function _found(attrName, el, oldVal) {\n        var map = this._elementMap.get(el);\n\n        if (!map) {\n          map = new Map();\n\n          this._elementMap.set(el, map);\n        }\n\n        var inst = map.get(attrName);\n        var newVal = el.getAttribute(attrName);\n\n        if (!inst) {\n          var Constructor = this._getConstructor(attrName);\n\n          inst = new Constructor();\n          map.set(attrName, inst);\n          inst.ownerElement = el;\n          inst.name = attrName;\n          inst.value = newVal;\n\n          if (inst.connectedCallback) {\n            inst.connectedCallback();\n          }\n        } // Attribute was removed\n        else if (newVal == null) {\n            if (inst.disconnectedCallback) {\n              inst.disconnectedCallback();\n            }\n\n            map.delete(attrName);\n          } // Attribute changed\n          else if (newVal !== inst.value) {\n              inst.value = newVal;\n\n              if (inst.changedCallback) {\n                inst.changedCallback(oldVal, newVal);\n              }\n            }\n      }\n    }]);\n\n    return CustomAttributeRegistry;\n  }();\n\n  var customAttributes = new CustomAttributeRegistry(document);\n\n  exports.CustomAttributeRegistry = CustomAttributeRegistry;\n  exports.default = customAttributes;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","import customAttributes, { CustomAttributeRegistry } from 'custom-attributes/pkg/dist-umd'\n\n// TODO: element behaviors currently don't work on elements when they are\n// defined (via elementBehaviors.define()) after the elements are already in the\n// DOM. Make it order-independent.\n\nclass BehaviorRegistry {\n    constructor() {\n        this._definedBehaviors = new Map()\n    }\n\n    define(name, Behavior) {\n        if (!this._definedBehaviors.has(name)) {\n            this._definedBehaviors.set(name, Behavior)\n        } else {\n            throw new Error(`Behavior ${name} is already defined.`)\n        }\n    }\n\n    get(name) {\n        return this._definedBehaviors.get(name)\n    }\n\n    has(name) {\n        return this._definedBehaviors.has(name)\n    }\n}\n\nwindow.elementBehaviors = new BehaviorRegistry()\n\n// for semantic purpose\nclass BehaviorMap extends Map {}\n\n// stores the behaviors associated to each element.\nconst behaviorMaps = new WeakMap()\n\n// All elements have a `behaviors` property. If null, it the element has no\n// behaviors, otherwise the property is a map of behavior names to behavior\n// instances.\nObject.defineProperty(Element.prototype, 'behaviors', {\n    get() {\n        let thisBehaviors = null\n\n        if (!behaviorMaps.has(this)) {\n            behaviorMaps.set(this, (thisBehaviors = new BehaviorMap()))\n        } else thisBehaviors = behaviorMaps.get(this)\n\n        return thisBehaviors\n    },\n})\n\n// One instance of is instantiated per element with has=\"\" attribute.\nclass HasAttribute {\n    constructor() {\n        // TODO constructor confusing because this.ownerElement doesn't exist. Report to custom-attributes\n\n        this.observers = new Map()\n    }\n\n    connectedCallback() {\n        this.behaviors = this.ownerElement.behaviors\n        this.changedCallback('', this.value)\n    }\n\n    disconnectedCallback() {\n        this.changedCallback(this.value, '')\n        delete this.behaviors\n    }\n\n    changedCallback(oldVal, newVal) {\n        const newBehaviors = this.getBehaviorNames(newVal)\n        const previousBehaviors = Array.from(this.behaviors.keys())\n\n        // small optimization: if no previous or new behaviors, just quit\n        // early. It would still function the same without this.\n        if (newBehaviors.length == 0 && previousBehaviors.length == 0) return\n\n        const { removed, added } = this.getDiff(previousBehaviors, newBehaviors)\n        this.handleDiff(removed, added)\n    }\n\n    getBehaviorNames(string) {\n        if (string.trim() == '') return []\n        else return string.split(/\\s+/)\n    }\n\n    getDiff(previousBehaviors, newBehaviors) {\n        const diff = {\n            removed: [],\n            added: newBehaviors,\n        }\n\n        for (let i = 0, l = previousBehaviors.length; i < l; i += 1) {\n            const oldBehavior = previousBehaviors[i]\n\n            // if it exists in the previousBehaviors but not the newBehaviors, then\n            // the node was removed.\n            if (!diff.added.includes(oldBehavior)) {\n                diff.removed.push(oldBehavior)\n            }\n\n            // otherwise the old value also exists in the set of new values, so\n            // therefore it wasn't added or removed, so let's remove it so we\n            // don't count it as added\n            else {\n                diff.added.splice(diff.added.indexOf(oldBehavior), 1)\n            }\n        }\n\n        return diff\n    }\n\n    handleDiff(removed, added) {\n        for (const name of removed) {\n            if (!elementBehaviors.has(name)) continue\n\n            const behavior = this.behaviors.get(name)\n\n            // TODO fire this disconnectedCallback only if the element is in a\n            // document, not if it merely has a parent (the naive easy way for\n            // now).\n            if (this.ownerElement.parentNode) {\n                behavior.disconnectedCallback()\n            }\n\n            // We can't rely on checking observedAttributes here because that\n            // could change after the fact, we only ever check it when we add\n            // the behavior. If it had observedAttributes, then it will have an\n            // observer.\n            if (this.observers.has(behavior)) {\n                this.destroyAttributeObserver(behavior)\n            }\n\n            this.behaviors.delete(name)\n        }\n\n        for (const name of added) {\n            if (!elementBehaviors.has(name)) continue\n\n            const Behavior = elementBehaviors.get(name)\n            const behavior = new Behavior(this.ownerElement)\n            this.behaviors.set(name, behavior)\n\n            // read observedAttributes first, in case anything external fires\n            // logic in the getter and expects it to happen before any\n            // lifecycle methods (f.e. a library like SkateJS)\n            const observedAttributes = behavior.constructor.observedAttributes\n\n            // TODO fire this connectedCallback only if the element is in a\n            // document, not if it merely has a parent (the naive easy way for\n            // now).\n            if (this.ownerElement.parentNode) {\n                behavior.connectedCallback()\n            }\n\n            if (Array.isArray(observedAttributes)) {\n                this.fireInitialAttributeChangedCallbacks(behavior)\n                this.createAttributeObserver(behavior)\n            }\n        }\n    }\n\n    destroyAttributeObserver(behavior) {\n        this.observers.get(behavior).disconnect()\n        this.observers.delete(behavior)\n    }\n\n    // Behaviors observe attribute changes, implemented with MutationObserver\n    //\n    // We have to create one observer per behavior because otherwise\n    // MutationObserver doesn't have an API for disconnecting from a single\n    // element, only for disconnecting from all elements.\n    createAttributeObserver(behavior) {\n        const observer = new MutationObserver(records => {\n            for (const record of records) {\n                behavior.attributeChangedCallback(\n                    record.attributeName,\n                    record.oldValue,\n                    this.ownerElement.getAttribute(record.attributeName)\n                )\n            }\n        })\n\n        observer.observe(this.ownerElement, {\n            attributes: true,\n            attributeOldValue: true,\n            attributeFilter: behavior.constructor.observedAttributes,\n        })\n\n        this.observers.set(behavior, observer)\n    }\n\n    fireInitialAttributeChangedCallbacks(behavior) {\n        if (!Array.isArray(behavior.constructor.observedAttributes)) return\n\n        for (const attr of Array.from(this.ownerElement.attributes)) {\n            if (!behavior.constructor.observedAttributes.includes(attr.name)) continue\n            if (behavior.attributeChangedCallback)\n                behavior.attributeChangedCallback(attr.name, null, attr.value)\n        }\n    }\n}\n\ncustomAttributes.define('has', HasAttribute)\n\nif (Element.prototype.attachShadow) {\n    const _attachShadow = Element.prototype.attachShadow\n\n    Element.prototype.attachShadow = function(...args) {\n        const root = _attachShadow.call(this, ...args)\n        const attributes = new CustomAttributeRegistry(root)\n\n        attributes.define('has', HasAttribute)\n\n        return root\n    }\n}\n\n// Leave this last line alone, it gets automatically updated when publishing a\n// new version of this package.\nexport const version = '2.1.3'\n"],"sourceRoot":""}