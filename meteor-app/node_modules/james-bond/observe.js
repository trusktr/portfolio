"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observe = observe;
exports.unobserve = unobserve;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _defineProperty = _interopRequireDefault(require("@babel/runtime/core-js/object/define-property"));

var _from = _interopRequireDefault(require("@babel/runtime/core-js/array/from"));

var _map = _interopRequireDefault(require("@babel/runtime/core-js/map"));

var _weakMap = _interopRequireDefault(require("@babel/runtime/core-js/weak-map"));

var _utils = require("lowclass/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var propsAndCallbacks = new _weakMap.default();

function observe(object, propertyNames, callback, options) {
  if (options === void 0) options = {}; // TODO the options.async option will make callbacks fire on the next microtask instead of synchronously

  options.async = options.async || false;
  options.inherited = options.inherited || false;

  for (var i = 0, list = propertyNames; i < list.length; i += 1) {
    var propName = list[i];
    var propCallbacks = propsAndCallbacks.get(object);
    !propCallbacks && propsAndCallbacks.set(object, propCallbacks = new _map.default());
    var callbacks = propCallbacks.get(propName);

    if (callbacks) {
      if (!(callbacks.indexOf(callback) !== -1)) {
        callbacks.push(callback);
      }

      continue;
    } // the rest only runs once, the first time the prop observation is set up


    propCallbacks.set(propName, callbacks = []);
    callbacks.push(callback);
    defineObservationGetterSetter(object, propName, options);
  }
}

function unobserve(object, props, callback) {
  var propCallbacks = propsAndCallbacks.get(object);

  if (!propCallbacks) {
    console.warn('the object is not observed, no need to unobserve:', object);
    return;
  } // If called as unobserve(object, callback), unobserve all props for the callback.


  if (typeof props === 'function') {
    callback = props;
    props = (0, _from.default)(propsAndCallbacks.get(object).keys());
  } // Otherwise called as unobserve(object, props, callback), so unobserve the specific props for the callback.


  if (!callback) {
    throw new TypeError('callback not supplied');
  }

  for (var i = 0, list = props; i < list.length; i += 1) {
    var prop = list[i];
    var callbacks = propCallbacks.get(prop);
    callbacks.indexOf(callback) !== -1 && callbacks.splice(callbacks.indexOf(callback), 1);
  }
}

function defineObservationGetterSetter(object, propName, options) {
  var descriptor = (0, _utils.getInheritedDescriptor)(object, propName) || {};
  var owner = options.inherited ? descriptor.owner || object : object;
  var getValue;
  var setValue;

  if (descriptor.get || descriptor.set) {
    // we will use the existing getter/setter assuming they don't do
    // anyting crazy that we might not expect. (See? Another reason for
    // Object.observe)
    var oldGet = descriptor.get;
    var oldSet = descriptor.set;

    getValue = function () {
      return oldGet.call(object);
    };

    setValue = function (value) {
      return oldSet.call(object, value);
    };
  } else {
    var _value = descriptor.value;
    delete descriptor.value;
    delete descriptor.writable;

    getValue = function () {
      return _value;
    };

    setValue = function (value) {
      return _value = value;
    };
  }

  (0, _defineProperty.default)(owner, propName, (0, _objectSpread2.default)({}, descriptor, {
    get: getValue,
    set: function set(value) {
      setValue(value);
      runCallbacks(object, propName, getValue());
    }
  }));
}

function runCallbacks(object, propName, value) {
  var callbacks = propsAndCallbacks.get(object).get(propName);

  for (var i = 0, list = callbacks; i < list.length; i += 1) {
    var callback = list[i];
    callback(propName, value);
  }
}