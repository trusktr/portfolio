{"version":3,"sources":["node_modules/pixify/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/d-path-parser/parser.js","src/SVG.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiSvg","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","root","factory","dPathParse","d","makeCommand","obj","cmd","relative","get","what","must","re","lastIndex","index","res","exec","getSequence","matched","sequence","matchers","push","command","number","comma","flag","coordinate pair","x","y","arc definition","radii","rotation","large","clockwise","end","commands","upcmd","toUpperCase","map","coords","reduce","seq","rest","cp1","cp","value","apply","_dPathParser","measureColor","document","createElement","SVG","svg","_classCallCheck","_this","_possibleConstructorReturn","_PIXI$Graphics","fill","svgChildren","children","inherit","arguments","undefined","child","nodeName","toLowerCase","svgPath","svgCircle","svgRect","svgPoly","hex","substr","parseInt","style","color","rgb","getComputedStyle","body","appendChild","match","removeChild","isEllipse","heightProp","widthProp","width","parseFloat","node","getAttribute","height","cx","cy","drawEllipse","drawCircle","rx","drawRoundedRect","drawRect","opacity","stroke","strokeWidth","split","forEach","prop","_prop$split","name","result","trim","drawPolygon","points","closePath","_svgStyle","defaultLineWidth","lineWidth","beginFill","hexToUint","lineStyle","lineColor","prototype","_dPathParser2","default","moveTo","lineTo","currX","currY","bezierCurveTo","cp2","_currX","_currY","_currX2","_currY2","quadraticCurveTo","_currX3","_currY3","PIXI","Graphics","d-path-parser","3","__esModule","_SVG","_SVG2"],"mappings":";;;;;;;CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,MAAAJ,EAAAK,UAAAL,EAAAK,aAAAC,IAAAX,MAAA,WAAA,GAAAG,EAAA,OAAA,SAAAS,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAjB,GAAA,GAAAsB,OAAA,uBAAAL,EAAA,IAAA,MAAAjB,GAAAuB,KAAA,mBAAAvB,EAAA,GAAAwB,GAAAV,EAAAG,IAAAhB,WAAAY,GAAAI,GAAA,GAAAQ,KAAAD,EAAAvB,QAAA,SAAAW,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,GAAAF,IAAAY,EAAAA,EAAAvB,QAAAW,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAhB,QAAA,IAAA,GAAAoB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAlB,EAAAD,ICUA,SAAA2B,EAAAC,GACA,kBAAA1B,IAAAA,EAAAC,IAEAD,KAAA0B,GACA,gBAAA5B,GAIAC,EAAAD,QAAA4B,IAGAD,EAAAE,WAAAD,KAEApB,KAAA,WACA,YAEA,OAAA,UAAAsB,GAgHA,QAAAC,GAAAC,GAIA,MAHAA,GAAAV,KAAAW,EACAD,EAAAE,SAAAA,EAEAF,EAEA,QAAAG,GAAAC,EAAAC,GACAC,EAAAF,GAAAG,UAAAC,CACA,IAAAC,GAAAH,EAAAF,GAAAM,KAAAZ,EACA,KAAAW,GAAAA,EAAAD,QAAAA,EAAA,CACA,IAAAH,EAAA,MAAA,KACA,MAAAhB,OAAA,YAAAe,EAAA,gBAAAI,GAKA,MAFAA,GAAAF,EAAAF,GAAAG,UAEAE,EAAA,GAEA,QAAAE,GAAAP,GAIA,IAHA,GACAQ,GADAC,KAEAR,GAAA,EACAO,EAAAE,EAAAV,GAAAC,IACAQ,EAAAE,KAAAH,GACAP,IAAAF,EAAA,QAGA,OAAAU,GAlGA,IAxCA,GAAAP,IACAU,QAAA,sBACAC,OAAA,sCACAC,MAAA,iBACAC,KAAA,cAEAL,GACAG,OAAA,SAAAZ,GACA,OAAAF,EAAA,SAAAE,IAEAe,kBAAA,SAAAf,GACA,GAAAgB,GAAAlB,EAAA,SAAAE,EACA,OAAA,QAAAgB,GAAAhB,GACAF,EAAA,UAEAkB,GAAAA,EAAAC,GADAnB,EAAA,UAAA,KAFA,MAKAoB,iBAAA,SAAAlB,GACA,GAAAmB,GAAAV,EAAA,mBAAAT,EACA,KAAAmB,IAAAnB,EAAA,MAAA,KACAF,GAAA,QACA,IAAAsB,IAAAtB,EAAA,UAAA,EACAA,GAAA,SAAA,EACA,IAAAuB,MAAAvB,EAAA,QAAA,EACAA,GAAA,QACA,IAAAwB,MAAAxB,EAAA,QAAA,EAGA,OAFAA,GAAA,UAGAqB,MAAAA,EACAC,SAAAA,EACAC,MAAAA,EACAC,UAAAA,EACAC,IANAd,EAAA,oBAAA,MAUAN,EAAA,EACAqB,KAEArB,EAAAV,EAAAL,QAAA,CACA,GAGAoB,GAHAZ,EAAAE,EAAA,WACA2B,EAAA7B,EAAA8B,cACA7B,EAAAD,IAAA6B,CAEA,QAAAA,GACA,IAAA,IACAjB,EAAAF,EAAA,mBAAAqB,IAAA,SAAAC,EAAA7C,GAEA,MADA,KAAAA,IAAAa,EAAAC,EAAA,IAAA,KACAH,GAAA6B,IAAAK,KAEA,MACA,KAAA,IACA,IAAA,IACApB,EAAAF,EAAA,mBAAAqB,IAAA,SAAAC,GACA,MAAAlC,IAAA6B,IAAAK,KAEA,MACA,KAAA,IAEA,GADApB,EAAAF,EAAA,mBACAE,EAAApB,OAAA,EACA,KAAAJ,OAAA,gDAAAmB,EAEAK,GAAAA,EAAAqB,OAAA,SAAAC,EAAAF,EAAA7C,GACA,GAAAgD,GAAAhD,EAAA,CACA,IAAAgD,EAEA,CACAD,EAAAA,EAAA1C,OAAA,GACA,IAAA2C,EAAA,MAAA,OAAAH,MAHAE,GAAApB,KAAAhB,GAAAsC,IAAAJ,IAKA,OAAAE,OAGA,MACA,KAAA,IACA,IAAA,IAEA,GADAtB,EAAAF,EAAA,mBACA,EAAAE,EAAApB,OACA,KAAAJ,OAAA,+CAAAmB,EAEAK,GAAAA,EAAAqB,OAAA,SAAAC,EAAAF,EAAA7C,GACA,EAAAA,EAIA+C,EAAAA,EAAA1C,OAAA,GACAmC,IAAAK,EAHAE,EAAApB,KAAAhB,GAAAuC,GAAAL,IAKA,OAAAE,OAGA,MACA,KAAA,IACA,IAAA,IACAtB,EAAAF,EAAA,UAAAqB,IAAA,SAAAO,GACA,MAAAxC,IAAAwC,MAAAA,KAEA,MACA,KAAA,IACA1B,EAAAF,EAAA,kBAAAqB,IAAAjC,EACA,MACA,KAAA,IACAc,IAAAvB,KAAA,MAGAuC,EAAAd,KAAAyB,MAAAX,EAAAhB,GAGA,MAAAgB,snBCxIA,IAAAY,GAAAtD,EAAA,wEAIMuD,EAAeC,SAASC,cAAc,OASvBC,cAIjB,QAAAA,GAAaC,GAAKC,EAAAvE,KAAAqE,EAAA,IAAAG,GAAAC,EAAAzE,KACd0E,EAAA1D,KAAAhB,MADc,OAEdwE,GAAKG,KAAKL,GACVE,EAAKI,YAAYN,EAAIO,UAHPL,EA8UI,0BAjUtBI,qBAAaC,GACT,IAAK,GADcC,GAAiBC,UAAA9D,OAAA,OAAA+D,KAAAD,UAAA,IAAAA,UAAA,GAC3BnE,EAAI,EAAGA,EAAIiE,EAAS5D,OAAQL,IAAK,CACtC,GAAMqE,GAAQJ,EAASjE,EAEvB,QADAZ,KAAK2E,KAAKM,EAAOH,GACTG,EAAMC,SAASC,eACnB,IAAK,OACDnF,KAAKoF,QAAQH,EACb,MAEJ,KAAK,SACL,IAAK,UACDjF,KAAKqF,UAAUJ,EACf,MAEJ,KAAK,OACDjF,KAAKsF,QAAQL,EACb,MAEJ,KAAK,UACDjF,KAAKuF,QAAQN,GAAO,EACpB,MAEJ,KAAK,WACDjF,KAAKuF,QAAQN,GAUbjF,KAAA4E,YAAAK,EAAAJ,UAAA,qDAkBR,SANRW,EAAAC,UAGQ,IAAAD,EAAMvE,6CAGFyE,SAAAF,EAAJ,GAECtB,GAAAyB,MAAAC,MAAAJ,CACD,IAAAK,GAAOhG,OAASiG,iBAAhB3B,SAAA4B,KAAAC,YAAA9B,IAAA0B,MAAAK,MAAA,QAAAzC,IAAA,SAAA9C,GACG,MAAAgF,UAAAhF,EAAA,KAKK,OAHRyD,UAAM4B,KAAMG,YAAOhC,IAGX2B,EAAO,IAAA,KAAAA,EAAP,IAAA,GAAAA,EAAA,kDAahB,2BAEQM,KACAC,GAAY,IACVC,GAAY,IAEd,IAAAC,GAAAC,WAAAC,EAAAC,aAAAJ,IACAK,EAAAH,WAAAC,EAAAC,aAAAL,IACHO,EAAAH,EAAAC,aAAA,MACKG,EAAAJ,EAAQC,aAAW,MACnB5D,EAAA,EACAC,EAAA,CACK,QAAL6D,IACF9D,EAAI0D,WAARI,IAEW,OAAPC,IACA9D,EAAIyD,WAAWK,IAEfT,EAGAnG,KAAC6G,YAAWhE,EAAAC,EAAAwD,EAAAI,GAFZ1G,KAAI8G,WAAWjE,EAAfC,EAAAwD,8GAgBRC,oCACUG,EAAIH,WAAgBC,EAAAC,aAA1B,WACMM,EAAIR,WAAWC,EAAKC,aAAa,MACjCM,GACA/G,KAAAgH,gBAAoBnE,EAAAC,EAAKwD,EAAAI,EAAaK,GAExC/G,KAAIiH,SAAApE,EAAAC,EAAAwD,EAAAI,2EAyBZF,EAAAC,qBACUS,QAAQV,EAAKC,aAAa,WAC1BU,OAAAX,EAASC,aAAA,UACXW,YAAWZ,EAAAC,aADA,gBAaP,OAVI,QAARd,IACAA,EAAA0B,MAAA,KAAaC,QAAK,SAAaC,GAJnC,GAAAC,GAAAD,EAAAF,MAAA,KAMII,EAAJD,EAAoB,GACVzD,EAANyD,EAAyB,EAAQE,GACtBD,EADsBE,QAAA5D,EAAA4D,6BAE7BD,EAAON,YAAPM,EAA4B,sBAFhCA,GAAA,kBAMIA,yGAYZhC,cAIa1F,MAAA4H,YAAKC,MAEd7H,KAAK8H,wFAcYX,EAAAY,EAEiCZ,OAA3CC,EAFUW,EAAAX,YAEKY,EAFL,OAEKb,EAFL,EAAA,EAEac,EAAA,OAFbb,EAAAb,WAAAa,GAAAY,6CAGXrD,GACY,SAAZA,EACA3E,KAAAkI,UAAY,EAAA,GAEVlI,KAAAkI,UAAJlI,KAAqBmI,UAAAxD,GAAA,OAAAuC,EAAAX,WAAAW,GAAA,GAEdpC,GACH9E,KAAAkI,UAAK,GAKZlI,KATDoI,UASYH,EAASI,IAcpBhE,EAAAiE,UAAAlD,QAAA,SAAAoB,UACGlF,GAAAkF,EAAKC,aAAa,KAClB5D,MAAA,GACHC,MAAA,GACDO,GAAA,EAAAkF,EAAAC,SAAAlH,iCAGJ,QAAAkB,EAAA1B,+DAMmBd,KAAAyI,OAAa5F,EAA5BL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EACA,MACM,KAAA,IAEI9C,KAAU0I,OAAA7F,EAAhBL,EAAAuB,MAAAjB,EACQ,MACM,KAAA,IAKN9C,KAAA0I,OAAA7F,GAAAL,EAAAuB,MAAAjB,EACH,MACS,KAAA,IAKN9C,KAAA0I,OAAA7F,EAAAC,EAAAN,EAAAuB,MACH,MACS,KAAA,IAEN/D,KAAA0I,OAAA7F,EAAAC,GAAAN,EAAAuB,MACH,MACS,KAAA,IAEN/D,KAAA8H,WACH,MACS,KAAA,IAEN9H,KAAA0I,OAAA7F,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IAEN9C,KAAA0I,OAAA7F,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IAEN,GAAA6F,GAAA9F,EACH+F,EAAA9F,CACD9C,MAAA6I,cAAAF,EAAAnG,EAAAqB,IAAAhB,EAAA+F,EAAApG,EAAAqB,IAAAf,EAAA6F,EAAAnG,EAAAsG,IAAAjG,EAAA+F,EAAApG,EAAAsG,IAAAhG,EAAAD,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EAAU,MAKN,KAAA,IAEJ,GAAAiG,GAAAlG,EAAUmG,EAAAlG,CACN9C,MAAK6I,cACIE,EAAAvG,EACLqB,IAAKhB,EAAAmG,EAFTxG,EAAAqB,IAAAf,EAAAiG,EAAAvG,EAAAsG,IAAAjG,EAAAmG,EAAAxG,EAAAsG,IAAAhG,EAAAD,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EAIA,MAEJ,KAAK,IAAK,IAAA,IAEN,GAAMmG,GAANpG,EACAqG,EAAKpG,CAQL9C,MAAAmJ,iBAAAF,EAAAzG,EAAAsB,GAAAjB,EAAAqG,EAAA1G,EAAAsB,GAAAhB,EAAAD,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IACN,IAAA,IAEA,GAAAsG,GAAKvG,EAQLwG,EAAAvG,CACH9C,MAAAmJ,iBAAAC,EAAA5G,EAAAsB,GAAAjB,EAAAwG,EAAA7G,EAAAsB,GAAAhB,EAAAD,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,MAcSuB,GACNiF,KAAAC,SAEA/J,GAAAgJ,QAAAnE,IAOHmF,gBAAA,IAAAC,GAAA,SAAA9I,EAAAlB,EAAAD,GACD,YACIA,GAAAkK,YAAA,CAEA,IAAAC,GAAAhJ,EAAA,SAEHiJ,EAER,SAAApI,GAAA,MAAAA,IAAAA,EAAAkI,WAAAlI,GAAAgH,QAAAhH,IAFQmI,+BAlWgB,KAAK","file":"pixi-svg.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * d-path-parser - v1.0.0\n * by Massimo Artizzu (MaxArt2501)\n *\n * https://github.com/MaxArt2501/d-path-parser\n *\n * Licensed under the MIT License\n * See LICENSE for details\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.dPathParse = factory();\n    }\n})(this, function() {\n\"use strict\";\n\nreturn function parse(d) {\n    var re = {\n        command: /\\s*([achlmqstvz])/gi,\n        number: /\\s*([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/gi,\n        comma: /\\s*(?:(,)|\\s)/g,\n        flag: /\\s*([01])/g\n    };\n    var matchers = {\n        \"number\": function(must) {\n            return +get(\"number\", must);\n        },\n        \"coordinate pair\": function(must) {\n            var x = get(\"number\", must);\n            if (x === null && !must) return null;\n            get(\"comma\");\n            var y = get(\"number\", true);\n            return { x: +x, y: +y };\n        },\n        \"arc definition\": function(must) {\n            var radii = matchers[\"coordinate pair\"](must);\n            if (!radii && !must) return null;\n            get(\"comma\");\n            var rotation = +get(\"number\", true);\n            get(\"comma\", true);\n            var large = !!+get(\"flag\", true);\n            get(\"comma\");\n            var clockwise = !!+get(\"flag\", true);\n            get(\"comma\");\n            var end = matchers[\"coordinate pair\"](true);\n            return {\n                radii: radii,\n                rotation: rotation,\n                large: large,\n                clockwise: clockwise,\n                end: end\n            };\n        }\n    }\n    var index = 0;\n    var commands = [];\n\n    while (index < d.length) {\n        var cmd = get(\"command\");\n        var upcmd = cmd.toUpperCase();\n        var relative = cmd !== upcmd;\n        var sequence;\n        switch (upcmd) {\n            case \"M\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords, i) {\n                    if (i === 1) cmd = relative ? \"l\" : \"L\";\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"L\":\n            case \"T\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords) {\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"C\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length % 3)\n                    throw Error(\"Expected coordinate pair triplet at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var rest = i % 3;\n                    if (!rest) {\n                        seq.push(makeCommand({ cp1: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last[rest === 1 ? \"cp2\" : \"end\"] = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"Q\":\n            case \"S\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length & 1)\n                    throw Error(\"Expected coordinate pair couple at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var odd = i & 1;\n                    if (!odd) {\n                        seq.push(makeCommand({ cp: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last.end = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"H\":\n            case \"V\":\n                sequence = getSequence(\"number\").map(function(value) {\n                    return makeCommand({ value: value });\n                });\n                break;\n            case \"A\":\n                sequence = getSequence(\"arc definition\").map(makeCommand);\n                break;\n            case \"Z\":\n                sequence = [ { code: \"Z\" } ];\n                break;\n        }\n        commands.push.apply(commands, sequence);\n    }\n\n    return commands;\n\n    function makeCommand(obj) {\n        obj.code = cmd;\n        obj.relative = relative;\n\n        return obj;\n    }\n    function get(what, must) {\n        re[what].lastIndex = index;\n        var res = re[what].exec(d);\n        if (!res || res.index !== index) {\n            if (!must) return null;\n            throw Error(\"Expected \" + what + \" at position \" + index);\n        }\n\n        index = re[what].lastIndex;\n\n        return res[1];\n    }\n    function getSequence(what) {\n        var sequence = [];\n        var matched;\n        var must = true;\n        while (matched = matchers[what](must)) {\n            sequence.push(matched);\n            must = !!get(\"comma\");\n        }\n\n        return sequence;\n    }\n};\n});\n","import dPathParse from 'd-path-parser';\n\n// <div> element to measure string colors like \"black\"\n// and convert to hex colors\nconst measureColor = document.createElement('div');\n\n/**\n * Scalable Graphics drawn from SVG image document.\n * @class SVG\n * @extends PIXI.Graphics\n * @memberof PIXI\n * @param {SVGSVGElement} svg - SVG Element `<svg>`\n */\nexport default class SVG extends PIXI.Graphics {\n    /**\n     * Constructor\n     */\n    constructor (svg) {\n        super();\n        this.fill(svg);\n        this.svgChildren(svg.children);\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @private\n     * @method PIXI.SVG#svgChildren\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Boolean} [inherit=false] Whether to inherit fill settings.\n     */\n    svgChildren (children, inherit = false) {\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.fill(child, inherit);\n            switch (child.nodeName.toLowerCase()) {\n                case 'path': {\n                    this.svgPath(child);\n                    break;\n                }\n                case 'circle':\n                case 'ellipse': {\n                    this.svgCircle(child);\n                    break;\n                }\n                case 'rect': {\n                    this.svgRect(child);\n                    break;\n                }\n                case 'polygon': {\n                    this.svgPoly(child, true);\n                    break;\n                }\n                case 'polyline': {\n                    this.svgPoly(child);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] <%s> elements unsupported', child.nodeName);\n                    // @endif\n                    break;\n                }\n            }\n            this.svgChildren(child.children, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @private\n     * @method PIXI.SVG#hexToUint\n     */\n    hexToUint (hex) {\n        if (hex[0] === '#') {\n                        // Remove the hash\n            hex = hex.substr(1);\n\n                        // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3) {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n            return parseInt(hex, 16);\n        } else {\n            measureColor.style.color = hex;\n            const rgb = window.getComputedStyle(document.body.appendChild(measureColor)).color\n                .match(/\\d+/g)\n                .map(function (a) {\n                    return parseInt(a, 10);\n                });\n            document.body.removeChild(measureColor);\n            return (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];\n        }\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @private\n     * @method PIXI.SVG#internalEllipse\n     * @param {SVGCircleElement} node\n     */\n    svgCircle (node) {\n\n        let heightProp = 'r';\n        let widthProp = 'r';\n        const isEllipse = node.nodeName === 'elipse';\n        if (isEllipse) {\n            heightProp += 'x';\n            widthProp += 'y';\n        }\n        const width = parseFloat(node.getAttribute(widthProp));\n        const height = parseFloat(node.getAttribute(heightProp));\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n        if (cx !== null) {\n            x = parseFloat(cx);\n        }\n        if (cy !== null) {\n            y = parseFloat(cy);\n        }\n        if (!isEllipse) {\n            this.drawCircle(x, y, width);\n        }\n        else {\n            this.drawEllipse(x, y, width, height);\n        }\n    }\n\n    /**\n     * Render a <rect> element\n     * @private\n     * @method PIXI.SVG#svgRect\n     * @param {SVGRectElement} node\n     */\n    svgRect (node) {\n        const x = parseFloat(node.getAttribute('x'));\n        const y = parseFloat(node.getAttribute('y'));\n        const width = parseFloat(node.getAttribute('width'));\n        const height = parseFloat(node.getAttribute('height'));\n        const rx = parseFloat(node.getAttribute('rx'));\n        if (rx) {\n            this.drawRoundedRect(\n                x,\n                y,\n                width,\n                height,\n                rx\n            );\n        } else {\n            this.drawRect(\n                x,\n                y,\n                width,\n                height\n            );\n        }\n    }\n\n    /**\n     * Get the style property and parse options.\n     * @private\n     * @method PIXI.SVG#svgStyle\n     * @param {SVGElement} node\n     * @return {Object} Style attributes\n     */\n    svgStyle (node) {\n        const style = node.getAttribute('style');\n        const result = {\n            fill: node.getAttribute('fill'),\n            opacity: node.getAttribute('opacity'),\n            stroke: node.getAttribute('stroke'),\n            strokeWidth: node.getAttribute('stroke-width')\n        };\n        if (style !== null) {\n            style.split(';').forEach(prop => {\n                const [name, value] = prop.split(':');\n                result[name.trim()] = value.trim();\n            });\n            if (result['stroke-width']) {\n                result.strokeWidth = result['stroke-width'];\n                delete result['stroke-width'];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Render a polyline element.\n     * @private\n     * @method PIXI.SVG#svgPoly\n     * @param {SVGPolylineElement} node\n     */\n    svgPoly (node, close) {\n\n        const points = node.getAttribute('points')\n            .split(/[ ,]/g)\n            .map(p => parseInt(p));\n\n        this.drawPolygon(points);\n\n        if (close) {\n            this.closePath();\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @private\n     * @method PIXI.SVG#fill\n     * @param {SVGElement} node\n     * @param {Boolean} inherit\n     */\n    fill (node, inherit) {\n\n        const {fill, opacity, stroke, strokeWidth} = this.svgStyle(node);\n        const defaultLineWidth = stroke !== null ? 1 : 0;\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : defaultLineWidth;\n        const lineColor = stroke !== null ? this.hexToUint(stroke) : this.lineColor;\n        if (fill) {\n            if (fill === 'none') {\n                this.beginFill(0, 0);\n            } else {\n                this.beginFill(\n                    this.hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1\n                );\n            }\n        } else if (!inherit) {\n            this.beginFill(0);\n        }\n        this.lineStyle(\n            lineWidth,\n            lineColor\n        );\n\n        // @if DEBUG\n        if (node.getAttribute('stroke-linejoin')) {\n            console.info('[SVGUtils] \"stroke-linejoin\" attribute is not supported');\n        }\n        if (node.getAttribute('stroke-linecap')) {\n            console.info('[SVGUtils] \"stroke-linecap\" attribute is not supported');\n        }\n        if (node.getAttribute('fill-rule')) {\n            console.info('[SVGUtils] \"fill-rule\" attribute is not supported');\n        }\n        // @endif\n    }\n\n    /**\n     * Render a <path> d element\n     * @method PIXI.SVG#svgPath\n     * @param {SVGPathElement} node\n     */\n    svgPath (node) {\n        const d = node.getAttribute('d');\n        let x, y;\n        const commands = dPathParse(d);\n        for (var i = 0; i < commands.length; i++) {\n            const command = commands[i];\n            switch (command.code) {\n                case 'm': {\n                    this.moveTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'M': {\n                    this.moveTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'H': {\n                    this.lineTo(x = command.value, y);\n                    break;\n                }\n                case 'h': {\n                    this.lineTo(x += command.value, y);\n                    break;\n                }\n                case 'V': {\n                    this.lineTo(x, y = command.value);\n                    break;\n                }\n                case 'v': {\n                    this.lineTo(x, y += command.value);\n                    break;\n                }\n                case 'Z': {\n                    this.closePath();\n                    break;\n                }\n                case 'L': {\n                    this.lineTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'l': {\n                    this.lineTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'C': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] Draw command not supported:', command.code, command);\n                    // @endif\n                    break;\n                }\n            }\n        }\n    }\n}\n"],"sourceRoot":"."}