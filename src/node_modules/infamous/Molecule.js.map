{"version":3,"sources":["src/Molecule.js"],"names":["Molecule","initialOptions","_","options","defaultOptions","align","origin","transform","handler","newOptions","constructor","name","prop","prototype","modifier","set","setOptions","args","Array","splice","call","arguments","pipe","apply","unpipe","on","resetOptions","newTransform"],"mappings":"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","file":"Molecule.js","sourcesContent":["/*\n * LICENSE\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n */\n\nimport Modifier from 'famous/src/core/Modifier';\nimport RenderNode from 'famous/src/core/RenderNode';\nimport TransitionableTransform from 'famous/src/transitions/TransitionableTransform';\nimport EventHandler from 'famous/src/core/EventHandler';\n\nimport {simpleExtend} from './utils'\n\nimport \"army-knife/polyfill.Function.name\";\n\n/**\n * Molecules are the basic building blocks of all UI components. Molecules\n * extend [famous/src/core/RenderNode](#famous/src/core/RenderNode), so they can be\n * added to any `RenderNode` of a famo.us render tree, and by default they will\n * also accept anything that a normal Famo.us `RenderNode` can accept via the\n * `add` method.  Classes that extend from `Molecule` might override\n * `RenderNode.add` in order to accept things like arrays of renderables in\n * stead of a single renderable.\n *\n * Molecules encapsulate the basic things you need for a component -- a\n * [famous/src/transitions/TransitionableTransform](#famous/src/transitions/TransitionableTransform)\n * for positioning things in space, and a [famous/src/core/EventHandler](#famous/src/core/EventHandler)\n * for capturing user interaction -- exposing a unified API for working with these\n * things. For now, [famous/src/core/Modifier](#famous/src/core/Modifier) is used as the interface\n * for applying transforms and sizing, but this will change in Mixed Mode\n * Famo.us.\n *\n * All components extend Molecule, but at the same time they can also use any\n * number of Molecules internally to do nice things like create layouts and\n * position multiple things in space.\n *\n * @class Molecule\n * @extends {module: famous/src/core/RenderNode}\n */\nexport class Molecule extends RenderNode {\n\n    /**\n     * Creates a new `Molecule` and applies `initialOptions` to it's internal\n     * `famous/src/core/Modifier`. See [famous/src/core/Modifier](#famous/src/core/Modifier)\n     * for details on what options you can pass.\n     *\n     * Note: Mixed Mode Famo.us does away with Modifiers, so this API will\n     * change slightly, but the change will be in such a way that APIs of\n     * higher level classes won't change because of this. One of the biggest\n     * changes in Mixed Mode will be that `size` will be set only on a\n     * per-Surface basis as far as a render tree is concerned. So if you\n     * normally put multiple `Surface` instances into a `Modifier` that has a\n     * size, then instead you'll have to explicitly assign a `size` to each\n     * `Surface`. This is a good thing, and makes for a cleaner and easier to\n     * use render tree with a separation of concerns from classes that can\n     * handle boundaries and group sizing. `Molecule` might then be an example\n     * of such a class with it's own size API.\n     *\n     * @constructor\n     * @param {Object} initialOptions The options to initialize this Molecule's `Modifier` with.\n     */\n    constructor(initialOptions) {\n        super()\n\n        // \"private\" stuff. Not really, but regard it like so. For example, if\n        // you see something like obj._.someVariable then you're accessing\n        // internal stuff that wasn't designed to be accessed directly, and any\n        // problem you enounter with that is your own problem. :)\n        //\n        // TODO: Use a WeakMap to store these at some point.\n        this._ = {\n            options: {}, // set and get with this.options\n            defaultOptions: {}\n        }\n\n        // Add default values for this Molecule\n        // TODO: Make default options static for the class.\n        simpleExtend(this._.defaultOptions, {\n            align: [0.5,0.5],\n            origin: [0.5,0.5],\n            transform: new TransitionableTransform,\n            handler: new EventHandler\n        })\n\n        // set the user's initial options. This automatically creates\n        // this.modifier, and adds it to this (don't forget, *this* is a\n        // RenderNode, so a Molecule can add things to itself).\n        //\n        // NOTE: this.options is a setter property. This statement applies all\n        // relevant properties to this.modifier.\n        this.options = initialOptions;\n    }\n\n    /**\n     * @property {Object} options The Molecule's options, which get applied to\n     * `this.modifier`. This may change with Mixed Mode. Setting this property\n     * overrides existing options. To extend existing options with new options,\n     * use `setOptions` instead.  Unspecified options will be set to their default\n     * values.\n     *\n     * Note: Anytime `this.options` is assigned a new value, `this.modifier` is set\n     * to a new [famous/src/core/Modifier](#famous/src/core/Modifier).\n     */\n    set options(newOptions) {\n        this.resetOptions();\n        this.setOptions(newOptions);\n    }\n    get options() {\n        return this._.options;\n    }\n\n    /**\n     * @property {module: famous/src/transitions/TransitionableTransform} transform\n     * The transform of this `Molecule`. The default is a\n     * [famous/src/transitions/TransitionableTransform](#famous/src/transitions/TransitionableTransform).\n     * Setting this property automatically puts the new transform into effect.\n     * See [famous/src/core/Modifier.transformFrom](#famous/src/core/Modifier.transformFrom).\n     */\n    set transform(newTransform) {\n        this.setOptions({transform: newTransform});\n    }\n    get transform() {\n        return this.options.transform;\n    }\n\n    /**\n     * Compounds `newOptions` into the existing options, similar to extending an\n     * object and overriding only the desired properties. To override all\n     * options with a set of new options, set `this.options` directly.\n     *\n     * An example of setting just a single option without erasing other options:\n     *\n     * ```js\n     * const myMolecule = new Molecule()\n     * myMolecule.setOptions({\n     *   align: [0.2, 0.8]\n     * })\n     * ```\n     *\n     * @param {Object} newOptions An object containing the new options to apply to this `Molecule`.\n     */\n    setOptions(newOptions) {\n        if (typeof newOptions == 'undefined' || newOptions.constructor.name != \"Object\")\n            newOptions = {}\n\n        for (const prop in newOptions) {\n            // Subject to change when Famo.us API changes.\n            if (Modifier.prototype[''+prop+'From']) {\n                this.modifier[''+prop+'From'](newOptions[prop]);\n            }\n\n            this._.options[prop] = newOptions[prop];\n        }\n    }\n\n    /**\n     * Sets all options back to their defaults.\n     *\n     * Note: Anytime this is called, `this.modifier` is set to a new\n     * [famous/src/core/Modifier](#famous/src/core/Modifier) having the default\n     * options.\n     */\n    resetOptions() {\n        this.modifier = new Modifier();\n        this.set(this.modifier);\n        this.setOptions(this._.defaultOptions);\n    }\n\n    /**\n     * Forwards events from this Molecule's [famous/src/core/EventHandler](#famous/src/core/EventHandler) to the given\n     * target, which can be another `EventHandler` or `Molecule`.\n     *\n     * This method is equivalent to [famous/src/core/EventHandler.pipe](#famous/src/core/EventHandler.pipe),\n     * acting upon `this.handler`.\n     *\n     * TODO v0.1.0: Let this method accept a `Molecule`, then stop doing `pipe(this._.handler)` in other places\n     */\n    pipe() {\n        const args = Array.prototype.splice.call(arguments, 0);\n        return this.options.handler.pipe.apply(this.options.handler, args);\n    }\n\n    /**\n     * Stops events from this Molecule's [famous/src/core/EventHandler](#famous/src/core/EventHandler)\n     * from being sent to the given target.\n     *\n     * This method is equivalent to [famous/src/core/EventHandler.unpipe](#famous/src/core/EventHandler.unpipe),\n     * acting upon `this.handler`.\n     *\n     * TODO v0.1.0: Let this method accept a `Molecule`, then stop doing `pipe(this.options.handler)` in other places\n     */\n    unpipe() {\n        const args = Array.prototype.splice.call(arguments, 0);\n        return this.options.handler.unpipe.apply(this.options.handler, args);\n    }\n\n    /**\n     * Register an event handler for the specified event.\n     * See [famous/src/core/EventHandler.on](#famous/src/core/EventHandler.on).\n     */\n    on() {\n        const args = Array.prototype.splice.call(arguments, 0);\n        return this.options.handler.on.apply(this.options.handler, args);\n    }\n\n    /**\n     * Unregister an event handler for the specified event.\n     * See [famous/src/core/EventHandler.off](#famous/src/core/EventHandler.off).\n     */\n    off() {\n        const args = Array.prototype.splice.call(arguments, 0);\n        return this.options.handler.on.apply(this.options.handler, args);\n    }\n}\nexport default Molecule;\n"]}