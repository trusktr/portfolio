{"version":3,"sources":["../src/motor/Node.js"],"names":["Node","options","_scene","_scenePromise","_resolveScenePromise","_onParentSizeChange","_properties","sizeMode","x","y","z","align","_calcSize","_needsToBeRendered","_awaitingScenePromise","_getScenePromise","mountPromise","_mounted","_resolveMountPromise","_elementManager","shouldRender","a","b","_children","childNode","_giveSceneRefToChildren","_resetSceneRef","timestamp","transform","_calculateMatrix","_parent","scene","mixin","default"],"mappings":"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","file":"Node.js","sourcesContent":["import 'geometry-interfaces'\nimport Transformable from './Transformable'\nimport ImperativeBase, {initImperativeBase} from './ImperativeBase'\nimport MotorHTMLNode from '../motor-html/node'\nimport Scene from './Scene'\n\ninitImperativeBase()\n\nclass Node extends ImperativeBase.mixin(Transformable) {\n\n    /**\n     * @constructor\n     *\n     * @param {Object} options Initial properties that the node will\n     * have. This can be used when creating a node, alternatively to using the\n     * setters/getters for position, rotation, etc.\n     *\n     * @example\n     * var node = new Node({\n     *   absoluteSize: {x:100, y:100, z:100},\n     *   rotation: {x:30, y:20, z:25}\n     * })\n     */\n    constructor (options = {}) {\n        super(options)\n\n        // This was when using my `multiple()` implementation, we could call\n        // specific constructors using specific arguments. But, we're using\n        // class-factory style mixins for now, so we don't have control over the\n        // specific arguments we can pass to the constructors, so we're just\n        // using a single `options` parameter in all the constructors.\n        //this.callSuperConstructor(Transformable, options)\n        //this.callSuperConstructor(TreeNode)\n        //this.callSuperConstructor(ImperativeBase)\n\n        this._scene = null // stores a ref to this Node's root Scene.\n\n        // This is an internal promise that resolves when this Node is added to\n        // to a scene graph that has a root Scene TreeNode. The resolved value\n        // is the root Scene.\n        this._scenePromise = null\n        this._resolveScenePromise = null\n\n        /**\n         * @private\n         * This method is defined here in the consructor as an arrow function\n         * because parent Nodes pass it to Observable#on and Observable#off. If\n         * it were a prototype method, then it would need to be bound when\n         * passed to Observable#on, which would require keeping track of the\n         * bound function reference in order to be able to pass it to\n         * Observable#off later. See ImperativeBase#addChild and\n         * ImperativeBase#removeChild.\n         */\n        this._onParentSizeChange = () => {\n\n            // We only need to recalculate sizing and matrices if this node has\n            // properties that depend on parent sizing (proportional size,\n            // align, and mountPoint). mountPoint isn't obvious: if this node\n            // is proportionally sized, then the mountPoint will depend on the\n            // size of this element which depends on the size of this element's\n            // parent.\n            if (\n                this._properties.sizeMode.x === \"proportional\"\n                || this._properties.sizeMode.y === \"proportional\"\n                || this._properties.sizeMode.z === \"proportional\"\n\n                || this._properties.align.x !== 0\n                || this._properties.align.y !== 0\n                || this._properties.align.z !== 0\n            ) {\n                this._calcSize()\n                this._needsToBeRendered()\n            }\n        }\n\n        this._calcSize()\n        this._needsToBeRendered()\n    }\n\n    /**\n     * @private\n     */\n    async _waitForMountThenResolveMountPromise() {\n        if (this._awaitingScenePromise) return\n        try {\n            this._awaitingScenePromise = true\n            await this._getScenePromise()\n            await this._scene.mountPromise\n        } catch (e) {\n            if (e == 'mountcancel') return\n            else throw e\n        } finally {\n            this._awaitingScenePromise = false\n        }\n\n        this._mounted = true\n        this._resolveMountPromise()\n        this._elementManager.shouldRender()\n    }\n\n    /**\n     * @override\n     */\n    _makeElement() {\n        return new MotorHTMLNode\n    }\n\n    /**\n     * @private\n     * Get a promise for the node's eventual scene.\n     */\n    _getScenePromise() {\n        if (!this._scenePromise) {\n            this._scenePromise = new Promise((a, b) => {\n                this._resolveScenePromise = a\n            })\n        }\n\n        if (this._scene)\n            this._resolveScenePromise()\n\n        return this._scenePromise\n    }\n\n    /**\n     * Get the Scene that this Node is in, null if no Scene. This is recursive\n     * at first, then cached.\n     *\n     * This traverses up the scene graph tree starting at this Node and finds\n     * the root Scene, if any. It caches the value for performance. If this\n     * Node is removed from a parent node with parent.removeChild(), then the\n     * cache is invalidated so the traversal can happen again when this Node is\n     * eventually added to a new tree. This way, if the scene is cached on a\n     * parent Node that we're adding this Node to then we can get that cached\n     * value instead of traversing the tree.\n     *\n     * @readonly\n     */\n    get scene() {\n        // NOTE: this._scene is initally null, created in the constructor.\n\n        // if already cached, return it. Or if no parent, return it (it'll be null).\n        if (this._scene || !this._parent) return this._scene\n\n        // if the parent node already has a ref to the scene, use that.\n        if (this._parent._scene) {\n            this._scene = this._parent._scene\n        }\n        else if (this._parent instanceof Scene) {\n            this._scene = this._parent\n        }\n        // otherwise call the scene getter on the parent, which triggers\n        // traversal up the scene graph in order to find the root scene (null\n        // if none).\n        else {\n            this._scene = this._parent.scene\n        }\n\n        return this._scene\n    }\n\n    /**\n     * @private\n     * This method to be called only when this Node has this.scene.\n     * Resolves the _scenePromise for all children of the tree of this Node.\n     */\n    _giveSceneRefToChildren() {\n        for (const childNode of this._children) {\n            childNode._scene = this._scene\n            if (childNode._resolveScenePromise)\n                childNode._resolveScenePromise(childNode._scene)\n            childNode._giveSceneRefToChildren();\n        }\n    }\n\n    _resetSceneRef() {\n        this._scene = null\n        this._scenePromise = null\n        this._resolveScenePromise = null\n        for (const childNode of this._children) {\n            childNode._resetSceneRef();\n        }\n    }\n\n    _render(timestamp) {\n        // applies the transform matrix to the element's style property.\n        this._properties.transform = this._calculateMatrix()\n        super._render(timestamp)\n    }\n}\n\nexport {Node as default}\n"]}