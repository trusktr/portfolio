{"version":3,"sources":["../src/motor/Scene.js"],"names":["Scene","options","_elementParentSize","x","y","z","_onElementParentSizeChange","newSize","_calcSize","_needsToBeRendered","_properties","sizeMode","_mounted","_startSizePolling","_stopSizePolling","_elementManager","element","on","off","mountPoint","document","readyState","undefined","body","querySelector","window","HTMLElement","Error","unmount","parentNode","appendChild","_mountPromise","_resolveMountPromise","shouldRender","_startOrStopSizePolling","shouldNotRender","removeChild","_rejectMountPromise","_resetMountPromise","newValue","mixin","prototype","default"],"mappings":"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","file":"Scene.js","sourcesContent":["import { makeAccessorsEnumerable } from './Utility'\nimport Sizeable from './Sizeable'\nimport ImperativeBase, {initImperativeBase} from './ImperativeBase'\nimport XYZValues from './XYZValues'\nimport MotorHTMLScene from '../motor-html/scene'\nimport documentReady from 'awaitbox/dom/documentReady'\n\ninitImperativeBase()\n\n// Scene is Sizeable, which is currently a subset of Transformable.\nclass Scene extends ImperativeBase.mixin(Sizeable) {\n    constructor(options = {}) {\n        super(options)\n\n        // NOTE: z size is always 0, since native DOM elements are always flat.\n        this._elementParentSize = {x:0, y:0, z:0}\n\n        this._onElementParentSizeChange = (newSize) => {\n            this._elementParentSize = newSize\n            this._calcSize()\n            this._needsToBeRendered()\n        }\n\n        this._calcSize()\n        this._needsToBeRendered()\n    }\n\n    _setDefaultProperties() {\n        super._setDefaultProperties()\n\n        Object.assign(this._properties, {\n            sizeMode: new XYZValues('proportional', 'proportional', 'absolute'),\n        })\n    }\n\n    // When we set the scene's size mode, we should start polling if it has\n    // proportional sizing.\n    set sizeMode(newValue) {\n        super.sizeMode = newValue\n        this._startOrStopSizePolling()\n    }\n    get sizeMode() {\n        return super.sizeMode\n    }\n\n    _startOrStopSizePolling() {\n        if (\n            this._mounted &&\n            (this._properties.sizeMode.x == 'proportional'\n            || this._properties.sizeMode.y == 'proportional'\n            || this._properties.sizeMode.z == 'proportional')\n        ) {\n            this._startSizePolling()\n        }\n        else {\n            this._stopSizePolling()\n        }\n    }\n\n    // observe size changes on the scene element.\n    _startSizePolling() {\n        if (!this._elementManager) return\n        this._elementManager.element._startSizePolling()\n        this._elementManager.element.on('parentsizechange', this._onElementParentSizeChange)\n    }\n\n    // Don't observe size changes on the scene element.\n    _stopSizePolling() {\n        if (!this._elementManager) return\n        this._elementManager.element.off('parentsizechange', this._onElementParentSizeChange)\n        this._elementManager.element._stopSizePolling()\n    }\n\n    /** @override */\n    _getParentSize() {\n        return this._mounted ? this._elementParentSize : {x:0,y:0,z:0}\n    }\n\n    /**\n     * @override\n     */\n    _makeElement() {\n        return new MotorHTMLScene\n    }\n\n    /**\n     * Mount the scene into the given target.\n     * Resolves the Scene's mountPromise, which can be use to do something once\n     * the scene is mounted.\n     *\n     * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,\n     * the mount point will be selected from the DOM. If an HTMLElement is\n     * provided, that will be the mount point. If no mount point is provided,\n     * the scene will be mounted into document.body.\n     */\n    async mount(mountPoint) {\n        // Wait for the document to be ready before mounting, otherwise the\n        // target mount point might not exist yet when this function is called.\n        if (document.readyState == 'loading') await documentReady()\n\n        // if no mountPoint was provided, just mount onto the <body> element.\n        if (mountPoint === undefined) mountPoint = document.body\n\n        // if the user supplied a selector, mount there.\n        else if (typeof mountPoint === 'string')\n            mountPoint = document.querySelector(mountPoint)\n\n        // if we have an actual mount point (the user may have supplied one)\n        if (!(mountPoint instanceof window.HTMLElement))\n            throw new Error('Invalid mount point specified in Scene.mount() call. Specify a selector, or pass an actual HTMLElement.')\n\n        if (this._mounted) this.unmount()\n\n        if (mountPoint !== this._elementManager.element.parentNode)\n            mountPoint.appendChild(this._elementManager.element)\n\n        this._mounted = true\n\n        if (this._mountPromise) this._resolveMountPromise()\n\n        this._elementManager.shouldRender()\n        this._startOrStopSizePolling()\n    }\n\n    /**\n     * Unmount the scene from it's mount point. Resets the Scene's\n     * mountPromise.\n     */\n    unmount() {\n        if (!this._mounted) return\n\n        this._elementManager.shouldNotRender()\n        this._stopSizePolling()\n\n        if (this._elementManager.element.parentNode)\n            this._elementManager.element.parentNode.removeChild(this._elementManager.element)\n\n        if (this._mountPromise) this._rejectMountPromise('mountcancel')\n        this._resetMountPromise()\n    }\n\n}\n\nmakeAccessorsEnumerable(Scene.prototype)\n\nexport {Scene as default}\n"]}