{"version":3,"sources":["../src/motor/Motor.js"],"names":["documentIsReady","Motor","_inFrame","_rAF","_animationLoopStarted","_allRenderTasks","_nodesToBeRendered","motorLoop","_runRenderTasks","timestamp","_renderNodes","size","requestAnimationFrame","fn","Error","add","_startAnimationLoop","delete","task","removeRenderTask","node","has","_render","clear"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;;;;AAIA,IAAIA,kBAAkB,KAAtB;;IAEMC,K;AACF,qBAAc;AAAA;;AACV,aAAKC,QAAL,GAAgB,KAAhB,CADU,CACY;AACtB,aAAKC,IAAL,GAAY,IAAZ,CAFU,CAEO;AACjB,aAAKC,qBAAL,GAA6B,KAA7B;AACA,aAAKC,eAAL,GAAuB,mBAAvB;AACA,aAAKC,kBAAL,GAA0B,mBAA1B;AACH;;AAED;;;;;;;;;;;;;;;;;;;qCAOQ,KAAKF,qB;;;;;;;;;AAET,qCAAKA,qBAAL,GAA6B,IAA7B;;oCAEKJ,e;;;;;;uCACK,8B;;;AACNA,kDAAkB,IAAlB;;;;AAGJ;AACA;AACMO,yC,GAAY,SAAZA,SAAY,YAAa;AAC3B,0CAAKL,QAAL,GAAgB,IAAhB;;AAEA,0CAAKM,eAAL,CAAqBC,SAArB;AACA,0CAAKC,YAAL,CAAkBD,SAAlB;;AAEA;AACA,wCAAI,MAAKJ,eAAL,CAAqBM,IAAzB,EACI,MAAKR,IAAL,GAAYS,sBAAsBL,SAAtB,CAAZ,CADJ,KAEK;AACD,8CAAKJ,IAAL,GAAY,IAAZ;AACA,8CAAKC,qBAAL,GAA6B,KAA7B;AACH;;AAED,0CAAKF,QAAL,GAAgB,KAAhB;AACH,iC;;AAED,qCAAKC,IAAL,GAAYS,sBAAsBL,SAAtB,CAAZ;;AAEA;AACA;AACA;AACA;AACI;AACA;;AAEA;AACA;;AAEA;AACA;AACI;AACA;AACJ;;AAEA;AACJ;;;;;;;;;;;;;;;;;AAGJ;;;;;;;;;;;;;;;;;;;;;;sCAmBcM,E,EAAI;AACd,gBAAI,OAAOA,EAAP,IAAa,UAAjB,EACI,MAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;;AAEJ,iBAAKT,eAAL,CAAqBU,GAArB,CAAyBF,EAAzB;;AAEA;AACA,gBAAI,CAAC,KAAKT,qBAAV,EACI,KAAKY,mBAAL;;AAEJ,mBAAOH,EAAP;AACH;;;yCAEgBA,E,EAAI;AACjB,iBAAKR,eAAL,CAAqBY,MAArB,CAA4BJ,EAA5B;AACH;;;wCAEeJ,S,EAAW;AAAA;AAAA;AAAA;;AAAA;AACvB,gEAAmB,KAAKJ,eAAxB,4GAAyC;AAAA,wBAA9Ba,IAA8B;;AACrC,wBAAIA,KAAKT,SAAL,MAAoB,KAAxB,EACI,KAAKU,gBAAL,CAAsBD,IAAtB;AACP;AAJsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAK1B;;;6CAEoBE,I,EAAM;AACvB,gBAAI,CAAC,KAAKd,kBAAL,CAAwBe,GAAxB,CAA4BD,IAA5B,CAAL,EACI,KAAKd,kBAAL,CAAwBS,GAAxB,CAA4BK,IAA5B;;AAEJ,gBAAI,CAAC,KAAKlB,QAAV,EAAoB,KAAKc,mBAAL;AACvB;;;qCAEYP,S,EAAW;AAAA;AAAA;AAAA;;AAAA;AACpB,iEAAmB,KAAKH,kBAAxB,iHAA4C;AAAA,wBAAjCc,IAAiC;;AACxCA,yBAAKE,OAAL,CAAab,SAAb;AACH;AAHmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIpB,iBAAKH,kBAAL,CAAwBiB,KAAxB;AACH;;;;;AAGL;;;kBACe,IAAItB,KAAJ,E","file":"Motor.js","sourcesContent":["import documentReady from 'awaitbox/dom/documentReady'\n\nimport {\n    //animationFrame,\n} from './Utility'\n\nlet documentIsReady = false\n\nclass Motor {\n    constructor() {\n        this._inFrame = false // true when inside a requested animation frame.\n        this._rAF = null // the current animation frame, or null.\n        this._animationLoopStarted = false\n        this._allRenderTasks = new Set\n        this._nodesToBeRendered = new Set\n    }\n\n    /**\n     * Starts an rAF loop and runs the render tasks in the _renderTasks stack.\n     * As long as there are tasks in the stack, the loop continues. When the\n     * stack becomes empty due to removal of tasks, the rAF stops and the app\n     * sits there doing nothing -- silence, crickets.\n     */\n    async _startAnimationLoop() {\n        if (this._animationLoopStarted) return\n\n        this._animationLoopStarted = true\n\n        if (!documentIsReady) {\n            await documentReady()\n            documentIsReady = true\n        }\n\n        // DIRECT ANIMATION LOOP ///////////////////////////////////\n        // So now we can render after the scene is mounted.\n        const motorLoop = timestamp => {\n            this._inFrame = true\n\n            this._runRenderTasks(timestamp)\n            this._renderNodes(timestamp)\n\n            // If any tasks are left to run, continue the animation loop.\n            if (this._allRenderTasks.size)\n                this._rAF = requestAnimationFrame(motorLoop)\n            else {\n                this._rAF = null\n                this._animationLoopStarted = false\n            }\n\n            this._inFrame = false\n        }\n\n        this._rAF = requestAnimationFrame(motorLoop)\n\n        // ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////\n        //this._rAF = true\n        //let timestamp = null\n        //while (this._rAF) {\n            //timestamp = await animationFrame()\n            //this._inFrame = true\n\n            //this._runRenderTasks(timestamp)\n            //this._renderNodes(timestamp)\n\n            //// If any tasks are left to run, continue the animation loop.\n            //if (!this._allRenderTasks.size) {\n                //this._rAF = null\n                //this._animationLoopStarted = false\n            //}\n\n            //this._inFrame = false\n        //}\n    }\n\n    /**\n     * When a render tasks is added a new rAF loop will be started if there\n     * isn't one currently.\n     *\n     * A render task is simply a function that will be called over and over\n     * again, in the Motor's animation loop. That's all, nothing special.\n     * However, if a Node setter is used inside of a render task, then the Node\n     * will tell Motor that it needs to be re-rendered, which will happen at\n     * the end of the current frame. If a Node setter is used outside of a\n     * render task (i.e. outside of the Motor's animation loop), then the Node\n     * tells Motor to re-render the Node on the next animation loop tick.\n     * Basically, regardless of where the Node's setters are used (inside or\n     * outside of the Motor's animation loop), rendering always happens inside\n     * the loop.\n     *\n     * @param {Function} fn The render task to add.\n     * @return {Function} A reference to the render task. Useful for saving to\n     * a variable so that it can later be passed to Motor.removeRenderTask().\n     */\n    addRenderTask(fn) {\n        if (typeof fn != 'function')\n            throw new Error('Render task must be a function.')\n\n        this._allRenderTasks.add(fn)\n\n        // If the render loop isn't started, start it.\n        if (!this._animationLoopStarted)\n            this._startAnimationLoop()\n\n        return fn\n    }\n\n    removeRenderTask(fn) {\n        this._allRenderTasks.delete(fn)\n    }\n\n    _runRenderTasks(timestamp) {\n        for (const task of this._allRenderTasks) {\n            if (task(timestamp) === false)\n                this.removeRenderTask(task)\n        }\n    }\n\n    _setNodeToBeRendered(node) {\n        if (!this._nodesToBeRendered.has(node))\n            this._nodesToBeRendered.add(node)\n\n        if (!this._inFrame) this._startAnimationLoop()\n    }\n\n    _renderNodes(timestamp) {\n        for (const node of this._nodesToBeRendered) {\n            node._render(timestamp)\n        }\n        this._nodesToBeRendered.clear()\n    }\n}\n\n// export a singleton instance rather than the class directly.\nexport default new Motor\n"]}