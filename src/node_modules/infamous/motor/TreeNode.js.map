{"version":3,"sources":["../src/motor/TreeNode.js"],"names":["instanceofSymbol","TreeNodeMixin","TreeNode","options","_parent","_children","childNode","TypeError","ReferenceError","removeChild","push","nodes","forEach","addChild","node","Error","splice","indexOf","removeChildren","length","base","value","obj","call","currentProto","desc","hasOwnProperty","mixin","default"],"mappings":"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","file":"TreeNode.js","sourcesContent":["const instanceofSymbol = Symbol('instanceofSymbol')\n\nconst TreeNodeMixin = base => {\n    class TreeNode extends base {\n\n        constructor(options = {}) {\n            super(options)\n            this._parent = null // default to no parent.\n            this._children = [];\n        }\n\n        /**\n         * this._parent is protected (node's can access other node._parent).\n         * The user should use the addChild methods, which automatically handles\n         * setting a parent.\n         *\n         * @readonly\n         */\n        get parent() {\n            return this._parent\n        }\n\n        /**\n         * @readonly\n         */\n        get children() {\n            // return a new array, so that the user modifying it doesn't affect\n            // this node's actual children.\n            return [...this._children]\n        }\n\n        /**\n         * Add a child node to this TreeNode.\n         *\n         * @param {TreeNode} childNode The child node to add.\n         */\n        addChild (childNode) {\n\n            if (! (childNode instanceof TreeNode))\n                throw new TypeError('TreeNode.addChild expects the childNode argument to be a TreeNode instance.')\n\n            if (childNode._parent === this)\n                throw new ReferenceError('childNode is already a child of this parent.')\n\n            if (childNode._parent)\n                childNode._parent.removeChild(childNode)\n\n            childNode._parent = this;\n\n            this._children.push(childNode);\n\n            return this\n        }\n\n        /**\n         * Add all the child nodes in the given array to this node.\n         *\n         * @param {Array.TreeNode} nodes The nodes to add.\n         */\n        addChildren(nodes) {\n            nodes.forEach(node => this.addChild(node))\n            return this\n        }\n\n        /**\n         * Remove a child node from this node.\n         *\n         * @param {TreeNode} childNode The node to remove.\n         */\n        removeChild(childNode) {\n            if (! (childNode instanceof TreeNode))\n                throw new Error(`\n                    TreeNode.removeChild expects the childNode argument to be an\n                    instance of TreeNode. There should only be TreeNodes in the\n                    tree.\n                `)\n\n            if (childNode._parent !== this)\n                throw new ReferenceError('childNode is not a child of this parent.')\n\n            childNode._parent = null\n            this._children.splice(this._children.indexOf(childNode), 1);\n\n            return this\n        }\n\n        /**\n         * Remove all the child nodes in the given array from this node.\n         *\n         * @param {Array.TreeNode} nodes The nodes to remove.\n         */\n        removeChildren(nodes) {\n            nodes.forEach(node => this.removeChild(node))\n            return this\n        }\n\n        /**\n         * Shortcut to remove all children.\n         */\n        removeAllChildren() {\n            this.removeChildren(this._children)\n            return this\n        }\n\n        /**\n         * @readonly\n         * @return {number} How many children this TreeNode has.\n         */\n        get childCount() {\n            return this._children.length\n        }\n    }\n\n    Object.defineProperty(TreeNode, Symbol.hasInstance, {\n        value: function(obj) {\n            if (this !== TreeNode) return Object.getPrototypeOf(TreeNode)[Symbol.hasInstance].call(this, obj)\n\n            let currentProto = obj\n\n            while(currentProto) {\n                const desc = Object.getOwnPropertyDescriptor(currentProto, \"constructor\")\n\n                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))\n                    return true\n\n                currentProto = Object.getPrototypeOf(currentProto)\n            }\n\n            return false\n        }\n    })\n\n    TreeNode[instanceofSymbol] = true\n\n    return TreeNode\n}\n\nconst TreeNode = TreeNodeMixin(class{})\nTreeNode.mixin = TreeNodeMixin\n\nexport {TreeNode as default}\n"]}