{"version":3,"sources":["../src/motor/ImperativeBase.js"],"names":["initImperativeBase","ImperativeBase","instanceofSymbol","ImperativeBaseMixin","options","_motorHtmlCounterpart","_elementManager","_makeElement","element","_associateImperativeNode","_mounted","_mountPromise","_resolveMountPromise","_rejectMountPromise","_awaitingMountPromiseToRender","_waitingForMountConditions","on","prop","_calcSize","_needsToBeRendered","Error","childNode","_scene","scene","_resolveScenePromise","_giveSceneRefToChildren","_onParentSizeChange","connectChildElement","off","_resetSceneRef","shouldNotRender","_resetMountPromise","disconnectChildElement","_children","mountPromise","_setNodeToBeRendered","timestamp","applyImperativeNodeProperties","resolve","reject","_waitForMountThenResolveMountPromise","properties","classes","setClasses","base","value","obj","call","currentProto","desc","hasOwnProperty","default","mixin"],"mappings":"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","file":"ImperativeBase.js","sourcesContent":["import ElementManager from './ElementManager'\nimport Node from './Node'\nimport Scene from './Scene'\nimport Motor from './Motor'\n\n// We explicitly use `var` instead of `let` here because it is hoisted for the\n// Node and Scene modules. This, along with the following initImperativeBase\n// function, allows the circular dependency between this module and the Node and\n// Scene modules to work. For details on why, see\n// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem.\nvar ImperativeBase\n\n// Here we wrap the definition of the ImperativeBase class with this function in\n// order to solve the circular depdendency problem caused by the\n// Node<->ImperativeBase and Scene<->ImperativeBase circles. The Node and Scene\n// modules call initImperativeBase to ensure that the ImperativeBase declaration\n// happens first, and then those modules can use the live binding in their\n// declarations.\ninitImperativeBase()\nexport function initImperativeBase() {\n    if (ImperativeBase) return\n\n    const instanceofSymbol = Symbol('instanceofSymbol')\n\n    /**\n     * The ImperativeBase class is the base class for the Imperative version of the\n     * API, for people who chose to take the all-JavaScript approach and who will\n     * not use the HTML-based API (infamous/motor-html).\n     *\n     * In the future when there is an option to disable the HTML-DOM rendering (and\n     * render only WebGL, for example) then the imperative API will be the only API\n     * available since the HTML API will be turned off as a result of disabling\n     * HTML rendering. Disabling both WebGL and HTML won't make sense, as we'll need\n     * at least one of those to render with.\n     */\n    const ImperativeBaseMixin = base => {\n        class ImperativeBase extends base {\n            constructor(options = {}) {\n\n                // The presence of a _motorHtmlCounterpart argument signifies that\n                // the HTML interface is being used, otherwise the imperative interface\n                // here is being used. For example, see MotorHTMLNode. This means the\n                // Node and MotorHTMLNode classes are coupled together, but it's in the\n                // name of the API that we're supporting.\n                const {_motorHtmlCounterpart} = options\n\n                super(options)\n\n                // Here we create the DOM HTMLElement associated with this\n                // Imperative-API Node.\n                this._elementManager = new ElementManager(\n                    _motorHtmlCounterpart || this._makeElement()\n                )\n                this._elementManager.element._associateImperativeNode(this)\n\n                // For Nodes, true when this Node is added to a parent AND it\n                // has an anancestor Scene that is mounted into DOM. For\n                // Scenes, true when mounted into DOM.\n                this._mounted = false;\n\n                // For Nodes, a promise that resolves when this Node is\n                // attached to a tree that has a root Scene TreeNode *and* when\n                // that root Scene has been mounted into the DOM. For Scenes,\n                // resolves when mounted into DOM.\n                this._mountPromise = null\n                this._resolveMountPromise = null\n                this._rejectMountPromise = null\n\n                this._awaitingMountPromiseToRender = false\n                this._waitingForMountConditions = false\n\n                // See Transformable/Sizeable propertychange event.\n                this.on('propertychange', prop => {\n                    if (\n                        prop == 'sizeMode' ||\n                        prop == 'absoluteSize' ||\n                        prop == 'proportionalSize'\n                    ) {\n                        this._calcSize()\n                    }\n\n                    this._needsToBeRendered()\n                })\n            }\n\n            /**\n             * Subclasses are required to override this. It should return the HTML-API\n             * counterpart for this Imperative-API instance. See Node or Scene classes\n             * for example.\n             *\n             * @private\n             */\n            _makeElement() {\n                throw new Error('Subclasses need to override ImperativeBase#_makeElement.')\n            }\n\n            /**\n             * @readonly\n             */\n            get mountPromise() {\n                if (!this._mountPromise) {\n                    this._mountPromise = new Promise((resolve, reject) => {\n                        this._resolveMountPromise = resolve\n                        this._rejectMountPromise = reject\n                    })\n                }\n\n                if (!this._mounted)\n                    this._waitForMountThenResolveMountPromise()\n                else if (this._mounted)\n                    this._resolveMountPromise()\n\n                return this._mountPromise\n            }\n\n            _waitForMountThenResolveMountPromise() {\n                // extended in Node or Scene to await for anything that mount\n                // depends on.\n            }\n\n            /**\n             * @readonly\n             */\n            get element() {\n                return this._elementManager.element\n            }\n\n            /**\n             * @override\n             */\n            addChild(childNode) {\n                if (!(childNode instanceof ImperativeBase)) return\n\n                // We cannot add Scenes to Nodes, for now.\n                if (childNode instanceof Scene) {\n                    throw new Error(`\n                        A Scene cannot be added to another Node or Scene (at\n                        least for now). To place a Scene in a Node, just mount\n                        a new Scene onto a MotorHTMLNode with Scene.mount().\n                    `)\n                }\n\n                super.addChild(childNode)\n\n                // Pass this parent node's Scene reference (if any, checking this cache\n                // first) to the new child and the child's children.\n                if (childNode._scene || childNode.scene) {\n                    if (childNode._resolveScenePromise)\n                        childNode._resolveScenePromise(childNode._scene)\n                    childNode._giveSceneRefToChildren()\n                }\n\n                // Calculate sizing because proportional size might depend on\n                // the new parent.\n                childNode._calcSize()\n                childNode._needsToBeRendered()\n\n                // child should watch the parent for size changes.\n                this.on('sizechange', childNode._onParentSizeChange)\n\n                this._elementManager.connectChildElement(childNode)\n\n                return this\n            }\n\n            removeChild(childNode) {\n                if (!(childNode instanceof Node)) return\n\n                super.removeChild(childNode)\n\n                this.off('sizechange', childNode._onParentSizeChange)\n\n                childNode._resetSceneRef()\n\n                if (childNode._mountPromise) childNode._rejectMountPromise('mountcancel')\n                if (childNode._mounted) childNode._elementManager.shouldNotRender()\n                childNode._resetMountPromise()\n\n                this._elementManager.disconnectChildElement(childNode)\n            }\n\n            _resetMountPromise() {\n                this._mounted = false\n                this._mountPromise = null\n                this._resolveMountPromise = null\n                this._rejectMountPromise = null\n                for (const childNode of this._children) {\n                    childNode._resetMountPromise();\n                }\n            }\n\n            /**\n             * Set all properties of an ImperativeBase instance in one method.\n             *\n             * @param {Object} properties Properties object - see example.\n             *\n             * @example\n             * node.properties = {\n             *   classes: ['open', 'big'],\n             * }\n             */\n            set properties (properties = {}) {\n                super.properties = properties\n\n                if (properties.classes)\n                    this._elementManager.setClasses(...properties.classes);\n            }\n\n            async _needsToBeRendered() {\n                if (this._awaitingMountPromiseToRender) return\n\n                if (!this._mounted) {\n                    try {\n                        this._awaitingMountPromiseToRender = true\n                        await this.mountPromise\n                    } catch(e) {\n                        if (e == 'mountcancel') return\n                        else throw e\n                    } finally {\n                        this._awaitingMountPromiseToRender = false\n                    }\n                }\n\n                Motor._setNodeToBeRendered(this)\n            }\n\n            _render(timestamp) {\n                this._elementManager.applyImperativeNodeProperties(this)\n            }\n        }\n\n        Object.defineProperty(ImperativeBase, Symbol.hasInstance, {\n            value: function(obj) {\n                if (this !== ImperativeBase) return Object.getPrototypeOf(ImperativeBase)[Symbol.hasInstance].call(this, obj)\n\n                let currentProto = obj\n\n                while(currentProto) {\n                    const desc = Object.getOwnPropertyDescriptor(currentProto, \"constructor\")\n\n                    if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol))\n                        return true\n\n                    currentProto = Object.getPrototypeOf(currentProto)\n                }\n\n                return false\n            }\n        })\n\n        ImperativeBase[instanceofSymbol] = true\n\n        return ImperativeBase\n    }\n\n    ImperativeBase = ImperativeBaseMixin(class{})\n    ImperativeBase.mixin = ImperativeBaseMixin\n\n}\n\nexport {ImperativeBase as default}\n"]}