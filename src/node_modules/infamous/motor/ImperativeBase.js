'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _set2 = require('babel-runtime/helpers/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

exports.initImperativeBase = initImperativeBase;

var _ElementManager = require('./ElementManager');

var _ElementManager2 = _interopRequireDefault(_ElementManager);

var _Node = require('./Node');

var _Node2 = _interopRequireDefault(_Node);

var _Scene = require('./Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _Motor = require('./Motor');

var _Motor2 = _interopRequireDefault(_Motor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// We explicitly use `var` instead of `let` here because it is hoisted for the
// Node and Scene modules. This, along with the following initImperativeBase
// function, allows the circular dependency between this module and the Node and
// Scene modules to work. For details on why, see
// https://esdiscuss.org/topic/how-to-solve-this-basic-es6-module-circular-dependency-problem.
var ImperativeBase;

// Here we wrap the definition of the ImperativeBase class with this function in
// order to solve the circular depdendency problem caused by the
// Node<->ImperativeBase and Scene<->ImperativeBase circles. The Node and Scene
// modules call initImperativeBase to ensure that the ImperativeBase declaration
// happens first, and then those modules can use the live binding in their
// declarations.
initImperativeBase();
function initImperativeBase() {
    if (ImperativeBase) return;

    var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

    /**
     * The ImperativeBase class is the base class for the Imperative version of the
     * API, for people who chose to take the all-JavaScript approach and who will
     * not use the HTML-based API (infamous/motor-html).
     *
     * In the future when there is an option to disable the HTML-DOM rendering (and
     * render only WebGL, for example) then the imperative API will be the only API
     * available since the HTML API will be turned off as a result of disabling
     * HTML rendering. Disabling both WebGL and HTML won't make sense, as we'll need
     * at least one of those to render with.
     */
    var ImperativeBaseMixin = function ImperativeBaseMixin(base) {
        var ImperativeBase = function (_base) {
            (0, _inherits3.default)(ImperativeBase, _base);

            function ImperativeBase() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                (0, _classCallCheck3.default)(this, ImperativeBase);


                // The presence of a _motorHtmlCounterpart argument signifies that
                // the HTML interface is being used, otherwise the imperative interface
                // here is being used. For example, see MotorHTMLNode. This means the
                // Node and MotorHTMLNode classes are coupled together, but it's in the
                // name of the API that we're supporting.
                var _motorHtmlCounterpart = options._motorHtmlCounterpart;

                // Here we create the DOM HTMLElement associated with this
                // Imperative-API Node.
                var _this = (0, _possibleConstructorReturn3.default)(this, (ImperativeBase.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase)).call(this, options));

                _this._elementManager = new _ElementManager2.default(_motorHtmlCounterpart || _this._makeElement());
                _this._elementManager.element._associateImperativeNode(_this);

                // For Nodes, true when this Node is added to a parent AND it
                // has an anancestor Scene that is mounted into DOM. For
                // Scenes, true when mounted into DOM.
                _this._mounted = false;

                // For Nodes, a promise that resolves when this Node is
                // attached to a tree that has a root Scene TreeNode *and* when
                // that root Scene has been mounted into the DOM. For Scenes,
                // resolves when mounted into DOM.
                _this._mountPromise = null;
                _this._resolveMountPromise = null;
                _this._rejectMountPromise = null;

                _this._awaitingMountPromiseToRender = false;
                _this._waitingForMountConditions = false;

                // See Transformable/Sizeable propertychange event.
                _this.on('propertychange', function (prop) {
                    if (prop == 'sizeMode' || prop == 'absoluteSize' || prop == 'proportionalSize') {
                        _this._calcSize();
                    }

                    _this._needsToBeRendered();
                });
                return _this;
            }

            /**
             * Subclasses are required to override this. It should return the HTML-API
             * counterpart for this Imperative-API instance. See Node or Scene classes
             * for example.
             *
             * @private
             */


            (0, _createClass3.default)(ImperativeBase, [{
                key: '_makeElement',
                value: function _makeElement() {
                    throw new Error('Subclasses need to override ImperativeBase#_makeElement.');
                }

                /**
                 * @readonly
                 */

            }, {
                key: '_waitForMountThenResolveMountPromise',
                value: function _waitForMountThenResolveMountPromise() {}
                // extended in Node or Scene to await for anything that mount
                // depends on.


                /**
                 * @readonly
                 */

            }, {
                key: 'addChild',


                /**
                 * @override
                 */
                value: function addChild(childNode) {
                    if (!(childNode instanceof ImperativeBase)) return;

                    // We cannot add Scenes to Nodes, for now.
                    if (childNode instanceof _Scene2.default) {
                        throw new Error('\n                        A Scene cannot be added to another Node or Scene (at\n                        least for now). To place a Scene in a Node, just mount\n                        a new Scene onto a MotorHTMLNode with Scene.mount().\n                    ');
                    }

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'addChild', this).call(this, childNode);

                    // Pass this parent node's Scene reference (if any, checking this cache
                    // first) to the new child and the child's children.
                    if (childNode._scene || childNode.scene) {
                        if (childNode._resolveScenePromise) childNode._resolveScenePromise(childNode._scene);
                        childNode._giveSceneRefToChildren();
                    }

                    // Calculate sizing because proportional size might depend on
                    // the new parent.
                    childNode._calcSize();
                    childNode._needsToBeRendered();

                    // child should watch the parent for size changes.
                    this.on('sizechange', childNode._onParentSizeChange);

                    this._elementManager.connectChildElement(childNode);

                    return this;
                }
            }, {
                key: 'removeChild',
                value: function removeChild(childNode) {
                    if (!(childNode instanceof _Node2.default)) return;

                    (0, _get3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'removeChild', this).call(this, childNode);

                    this.off('sizechange', childNode._onParentSizeChange);

                    childNode._resetSceneRef();

                    if (childNode._mountPromise) childNode._rejectMountPromise('mountcancel');
                    if (childNode._mounted) childNode._elementManager.shouldNotRender();
                    childNode._resetMountPromise();

                    this._elementManager.disconnectChildElement(childNode);
                }
            }, {
                key: '_resetMountPromise',
                value: function _resetMountPromise() {
                    this._mounted = false;
                    this._mountPromise = null;
                    this._resolveMountPromise = null;
                    this._rejectMountPromise = null;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = (0, _getIterator3.default)(this._children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var childNode = _step.value;

                            childNode._resetMountPromise();
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                /**
                 * Set all properties of an ImperativeBase instance in one method.
                 *
                 * @param {Object} properties Properties object - see example.
                 *
                 * @example
                 * node.properties = {
                 *   classes: ['open', 'big'],
                 * }
                 */

            }, {
                key: '_needsToBeRendered',
                value: function () {
                    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
                        return _regenerator2.default.wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        if (!this._awaitingMountPromiseToRender) {
                                            _context.next = 2;
                                            break;
                                        }

                                        return _context.abrupt('return');

                                    case 2:
                                        if (this._mounted) {
                                            _context.next = 19;
                                            break;
                                        }

                                        _context.prev = 3;

                                        this._awaitingMountPromiseToRender = true;
                                        _context.next = 7;
                                        return this.mountPromise;

                                    case 7:
                                        _context.next = 16;
                                        break;

                                    case 9:
                                        _context.prev = 9;
                                        _context.t0 = _context['catch'](3);

                                        if (!(_context.t0 == 'mountcancel')) {
                                            _context.next = 15;
                                            break;
                                        }

                                        return _context.abrupt('return');

                                    case 15:
                                        throw _context.t0;

                                    case 16:
                                        _context.prev = 16;

                                        this._awaitingMountPromiseToRender = false;
                                        return _context.finish(16);

                                    case 19:

                                        _Motor2.default._setNodeToBeRendered(this);

                                    case 20:
                                    case 'end':
                                        return _context.stop();
                                }
                            }
                        }, _callee, this, [[3, 9, 16, 19]]);
                    }));

                    function _needsToBeRendered() {
                        return _ref.apply(this, arguments);
                    }

                    return _needsToBeRendered;
                }()
            }, {
                key: '_render',
                value: function _render(timestamp) {
                    this._elementManager.applyImperativeNodeProperties(this);
                }
            }, {
                key: 'mountPromise',
                get: function get() {
                    var _this2 = this;

                    if (!this._mountPromise) {
                        this._mountPromise = new _promise2.default(function (resolve, reject) {
                            _this2._resolveMountPromise = resolve;
                            _this2._rejectMountPromise = reject;
                        });
                    }

                    if (!this._mounted) this._waitForMountThenResolveMountPromise();else if (this._mounted) this._resolveMountPromise();

                    return this._mountPromise;
                }
            }, {
                key: 'element',
                get: function get() {
                    return this._elementManager.element;
                }
            }, {
                key: 'properties',
                set: function set() {
                    var _elementManager;

                    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                    (0, _set3.default)(ImperativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(ImperativeBase.prototype), 'properties', properties, this);

                    if (properties.classes) (_elementManager = this._elementManager).setClasses.apply(_elementManager, (0, _toConsumableArray3.default)(properties.classes));
                }
            }]);
            return ImperativeBase;
        }(base);

        (0, _defineProperty2.default)(ImperativeBase, _hasInstance2.default, {
            value: function value(obj) {
                if (this !== ImperativeBase) return (0, _getPrototypeOf2.default)(ImperativeBase)[_hasInstance2.default].call(this, obj);

                var currentProto = obj;

                while (currentProto) {
                    var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                    if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) return true;

                    currentProto = (0, _getPrototypeOf2.default)(currentProto);
                }

                return false;
            }
        });

        ImperativeBase[instanceofSymbol] = true;

        return ImperativeBase;
    };

    exports.default = ImperativeBase = ImperativeBaseMixin(function () {
        function _class() {
            (0, _classCallCheck3.default)(this, _class);
        }

        return _class;
    }());
    ImperativeBase.mixin = ImperativeBaseMixin;
}

exports.default = ImperativeBase;
//# sourceMappingURL=ImperativeBase.js.map