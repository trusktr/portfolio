'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

require('geometry-interfaces');

var _Transformable = require('./Transformable');

var _Transformable2 = _interopRequireDefault(_Transformable);

var _ImperativeBase = require('./ImperativeBase');

var _ImperativeBase2 = _interopRequireDefault(_ImperativeBase);

var _node = require('../motor-html/node');

var _node2 = _interopRequireDefault(_node);

var _Scene = require('./Scene');

var _Scene2 = _interopRequireDefault(_Scene);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ImperativeBase.initImperativeBase)();

var Node = function (_ImperativeBase$mixin) {
    (0, _inherits3.default)(Node, _ImperativeBase$mixin);

    /**
     * @constructor
     *
     * @param {Object} options Initial properties that the node will
     * have. This can be used when creating a node, alternatively to using the
     * setters/getters for position, rotation, etc.
     *
     * @example
     * var node = new Node({
     *   absoluteSize: {x:100, y:100, z:100},
     *   rotation: {x:30, y:20, z:25}
     * })
     */
    function Node() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, Node);

        // This was when using my `multiple()` implementation, we could call
        // specific constructors using specific arguments. But, we're using
        // class-factory style mixins for now, so we don't have control over the
        // specific arguments we can pass to the constructors, so we're just
        // using a single `options` parameter in all the constructors.
        //this.callSuperConstructor(Transformable, options)
        //this.callSuperConstructor(TreeNode)
        //this.callSuperConstructor(ImperativeBase)

        var _this = (0, _possibleConstructorReturn3.default)(this, (Node.__proto__ || (0, _getPrototypeOf2.default)(Node)).call(this, options));

        _this._scene = null; // stores a ref to this Node's root Scene.

        // This is an internal promise that resolves when this Node is added to
        // to a scene graph that has a root Scene TreeNode. The resolved value
        // is the root Scene.
        _this._scenePromise = null;
        _this._resolveScenePromise = null;

        /**
         * @private
         * This method is defined here in the consructor as an arrow function
         * because parent Nodes pass it to Observable#on and Observable#off. If
         * it were a prototype method, then it would need to be bound when
         * passed to Observable#on, which would require keeping track of the
         * bound function reference in order to be able to pass it to
         * Observable#off later. See ImperativeBase#addChild and
         * ImperativeBase#removeChild.
         */
        _this._onParentSizeChange = function () {

            // We only need to recalculate sizing and matrices if this node has
            // properties that depend on parent sizing (proportional size,
            // align, and mountPoint). mountPoint isn't obvious: if this node
            // is proportionally sized, then the mountPoint will depend on the
            // size of this element which depends on the size of this element's
            // parent.
            if (_this._properties.sizeMode.x === "proportional" || _this._properties.sizeMode.y === "proportional" || _this._properties.sizeMode.z === "proportional" || _this._properties.align.x !== 0 || _this._properties.align.y !== 0 || _this._properties.align.z !== 0) {
                _this._calcSize();
                _this._needsToBeRendered();
            }
        };

        _this._calcSize();
        _this._needsToBeRendered();
        return _this;
    }

    /**
     * @private
     */


    (0, _createClass3.default)(Node, [{
        key: '_waitForMountThenResolveMountPromise',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (!this._awaitingScenePromise) {
                                    _context.next = 2;
                                    break;
                                }

                                return _context.abrupt('return');

                            case 2:
                                _context.prev = 2;

                                this._awaitingScenePromise = true;
                                _context.next = 6;
                                return this._getScenePromise();

                            case 6:
                                _context.next = 8;
                                return this._scene.mountPromise;

                            case 8:
                                _context.next = 17;
                                break;

                            case 10:
                                _context.prev = 10;
                                _context.t0 = _context['catch'](2);

                                if (!(_context.t0 == 'mountcancel')) {
                                    _context.next = 16;
                                    break;
                                }

                                return _context.abrupt('return');

                            case 16:
                                throw _context.t0;

                            case 17:
                                _context.prev = 17;

                                this._awaitingScenePromise = false;
                                return _context.finish(17);

                            case 20:

                                this._mounted = true;
                                this._resolveMountPromise();
                                this._elementManager.shouldRender();

                            case 23:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[2, 10, 17, 20]]);
            }));

            function _waitForMountThenResolveMountPromise() {
                return _ref.apply(this, arguments);
            }

            return _waitForMountThenResolveMountPromise;
        }()

        /**
         * @override
         */

    }, {
        key: '_makeElement',
        value: function _makeElement() {
            return new _node2.default();
        }

        /**
         * @private
         * Get a promise for the node's eventual scene.
         */

    }, {
        key: '_getScenePromise',
        value: function _getScenePromise() {
            var _this2 = this;

            if (!this._scenePromise) {
                this._scenePromise = new _promise2.default(function (a, b) {
                    _this2._resolveScenePromise = a;
                });
            }

            if (this._scene) this._resolveScenePromise();

            return this._scenePromise;
        }

        /**
         * Get the Scene that this Node is in, null if no Scene. This is recursive
         * at first, then cached.
         *
         * This traverses up the scene graph tree starting at this Node and finds
         * the root Scene, if any. It caches the value for performance. If this
         * Node is removed from a parent node with parent.removeChild(), then the
         * cache is invalidated so the traversal can happen again when this Node is
         * eventually added to a new tree. This way, if the scene is cached on a
         * parent Node that we're adding this Node to then we can get that cached
         * value instead of traversing the tree.
         *
         * @readonly
         */

    }, {
        key: '_giveSceneRefToChildren',


        /**
         * @private
         * This method to be called only when this Node has this.scene.
         * Resolves the _scenePromise for all children of the tree of this Node.
         */
        value: function _giveSceneRefToChildren() {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(this._children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var childNode = _step.value;

                    childNode._scene = this._scene;
                    if (childNode._resolveScenePromise) childNode._resolveScenePromise(childNode._scene);
                    childNode._giveSceneRefToChildren();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: '_resetSceneRef',
        value: function _resetSceneRef() {
            this._scene = null;
            this._scenePromise = null;
            this._resolveScenePromise = null;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = (0, _getIterator3.default)(this._children), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var childNode = _step2.value;

                    childNode._resetSceneRef();
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    }, {
        key: '_render',
        value: function _render(timestamp) {
            // applies the transform matrix to the element's style property.
            this._properties.transform = this._calculateMatrix();
            (0, _get3.default)(Node.prototype.__proto__ || (0, _getPrototypeOf2.default)(Node.prototype), '_render', this).call(this, timestamp);
        }
    }, {
        key: 'scene',
        get: function get() {
            // NOTE: this._scene is initally null, created in the constructor.

            // if already cached, return it. Or if no parent, return it (it'll be null).
            if (this._scene || !this._parent) return this._scene;

            // if the parent node already has a ref to the scene, use that.
            if (this._parent._scene) {
                this._scene = this._parent._scene;
            } else if (this._parent instanceof _Scene2.default) {
                this._scene = this._parent;
            }
            // otherwise call the scene getter on the parent, which triggers
            // traversal up the scene graph in order to find the root scene (null
            // if none).
            else {
                    this._scene = this._parent.scene;
                }

            return this._scene;
        }
    }]);
    return Node;
}(_ImperativeBase2.default.mixin(_Transformable2.default));

exports.default = Node;
module.exports = exports['default'];
//# sourceMappingURL=Node.js.map