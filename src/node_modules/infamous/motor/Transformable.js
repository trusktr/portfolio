'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _is = require('babel-runtime/core-js/object/is');

var _is2 = _interopRequireDefault(_is);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _set2 = require('babel-runtime/helpers/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _XYZValues = require('./XYZValues');

var _XYZValues2 = _interopRequireDefault(_XYZValues);

var _Sizeable = require('./Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _Utility = require('./Utility');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instanceofSymbol = (0, _symbol2.default)('instanceofSymbol');

var TransformableMixin = function TransformableMixin(base) {

    // Transformable extends TreeNode (indirectly through Sizeable) because it
    // needs to be aware of its _parent when calculating align adjustments.
    var Transformable = function (_Sizeable$mixin) {
        (0, _inherits3.default)(Transformable, _Sizeable$mixin);

        function Transformable() {
            (0, _classCallCheck3.default)(this, Transformable);
            return (0, _possibleConstructorReturn3.default)(this, (Transformable.__proto__ || (0, _getPrototypeOf2.default)(Transformable)).apply(this, arguments));
        }

        (0, _createClass3.default)(Transformable, [{
            key: '_setDefaultProperties',
            value: function _setDefaultProperties() {
                (0, _get3.default)(Transformable.prototype.__proto__ || (0, _getPrototypeOf2.default)(Transformable.prototype), '_setDefaultProperties', this).call(this);

                (0, _assign2.default)(this._properties, {
                    position: new _XYZValues2.default(0, 0, 0),
                    rotation: new _XYZValues2.default(0, 0, 0),
                    scale: new _XYZValues2.default(1, 1, 1),
                    origin: new _XYZValues2.default(0.5, 0.5, 0.5),
                    align: new _XYZValues2.default(0, 0, 0),
                    mountPoint: new _XYZValues2.default(0, 0, 0),
                    opacity: 1,
                    transform: new window.DOMMatrix()
                });
            }
        }, {
            key: '_setPropertyObservers',
            value: function _setPropertyObservers() {
                var _this2 = this;

                (0, _get3.default)(Transformable.prototype.__proto__ || (0, _getPrototypeOf2.default)(Transformable.prototype), '_setPropertyObservers', this).call(this);

                this._properties.position.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'position');
                });
                this._properties.rotation.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'rotation');
                });
                this._properties.scale.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'scale');
                });
                this._properties.origin.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'origin');
                });
                this._properties.align.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'align');
                });
                this._properties.mountPoint.on('valuechanged', function () {
                    return _this2.triggerEvent('propertychange', 'mountPoint');
                });
            }

            /**
             * Set the position of the Transformable.
             *
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis position to apply.
             * @param {number} [newValue.y] The y-axis position to apply.
             * @param {number} [newValue.z] The z-axis position to apply.
             */

        }, {
            key: '_calculateMatrix',

            // no need for a properties getter.

            /**
             * Takes all the current component values (position, rotation, etc) and
             * calculates a transformation DOMMatrix from them. See "W3C Geometry
             * Interfaces" to learn about DOMMatrix.
             *
             * @method
             * @private
             * @memberOf Node
             */
            value: function _calculateMatrix() {
                var matrix = new window.DOMMatrix();
                var properties = this._properties;

                var alignAdjustment = [0, 0, 0];
                if (this._parent) {
                    // The root Scene doesn't have a parent, for example.
                    var parentSize = this._parent._calculatedSize;
                    var align = properties.align;

                    alignAdjustment[0] = parentSize.x * align.x;
                    alignAdjustment[1] = parentSize.y * align.y;
                    alignAdjustment[2] = parentSize.z * align.z;
                }

                var mountPointAdjustment = [0, 0, 0];
                var thisSize = this._calculatedSize;
                var mountPoint = properties.mountPoint;

                mountPointAdjustment[0] = thisSize.x * mountPoint.x;
                mountPointAdjustment[1] = thisSize.y * mountPoint.y;
                mountPointAdjustment[2] = thisSize.z * mountPoint.z;

                var appliedPosition = [];
                var position = properties.position;

                appliedPosition[0] = position.x + alignAdjustment[0] - mountPointAdjustment[0];
                appliedPosition[1] = position.y + alignAdjustment[1] - mountPointAdjustment[1];
                appliedPosition[2] = position.z + alignAdjustment[2] - mountPointAdjustment[2];

                matrix.translateSelf(appliedPosition[0], appliedPosition[1], appliedPosition[2]);

                // origin calculation will go here:
                // - move by negative origin before rotating.

                // apply each axis rotation, in the x,y,z order.
                var rotation = properties.rotation;

                matrix.rotateAxisAngleSelf(1, 0, 0, rotation.x);
                matrix.rotateAxisAngleSelf(0, 1, 0, rotation.y);
                matrix.rotateAxisAngleSelf(0, 0, 1, rotation.z);

                // origin calculation will go here:
                // - move by positive origin after rotating.

                return matrix;
            }
        }, {
            key: 'position',
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'position', newValue);
            },
            get: function get() {
                return this._properties.position;
            }

            /**
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis rotation to apply.
             * @param {number} [newValue.y] The y-axis rotation to apply.
             * @param {number} [newValue.z] The z-axis rotation to apply.
             */

        }, {
            key: 'rotation',
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'rotation', newValue);
            },
            get: function get() {
                return this._properties.rotation;
            }

            /**
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis scale to apply.
             * @param {number} [newValue.y] The y-axis scale to apply.
             * @param {number} [newValue.z] The z-axis scale to apply.
             */

        }, {
            key: 'scale',
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'scale', newValue);
            },
            get: function get() {
                return this._properties.scale;
            }

            /**
             * Set this Node's opacity.
             *
             * @param {number} opacity A floating point number between 0 and 1
             * (inclusive). 0 is fully transparent, 1 is fully opaque.
             */

        }, {
            key: 'opacity',
            set: function set(newValue) {
                if (!isRealNumber(newValue)) newValue = undefined;
                this._setPropertySingle(Transformable, 'opacity', newValue, 'number');
            },
            get: function get() {
                return this._properties.opacity;
            }

            /**
             * Set the alignment of the Node. This determines at which point in this
             * Node's parent that this Node is mounted.
             *
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis align to apply.
             * @param {number} [newValue.y] The y-axis align to apply.
             * @param {number} [newValue.z] The z-axis align to apply.
             */

        }, {
            key: 'align',
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'align', newValue);
            },
            get: function get() {
                return this._properties.align;
            }

            /**
             * Set the mount point of the Node.
             *
             * @param {Object} newValue
             * @param {number} [newValue.x] The x-axis mountPoint to apply.
             * @param {number} [newValue.y] The y-axis mountPoint to apply.
             * @param {number} [newValue.z] The z-axis mountPoint to apply.
             */

        }, {
            key: 'mountPoint',
            set: function set(newValue) {
                this._setPropertyXYZ(Transformable, 'mountPoint', newValue);
            },
            get: function get() {
                return this._properties.mountPoint;
            }

            /**
             * Set all properties of a Transformable in one method.
             *
             * @param {Object} properties Properties object - see example.
             *
             * @example
             * node.properties = {
             *   position: {x:200, y:300, z:100},
             *   rotation: {z:35},
             *   scale: {y:2},
             *   opacity: .9,
             * }
             */

        }, {
            key: 'properties',
            set: function set() {
                var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                (0, _set3.default)(Transformable.prototype.__proto__ || (0, _getPrototypeOf2.default)(Transformable.prototype), 'properties', properties, this);

                if (properties.position) this.position = properties.position;

                if (properties.rotation) this.rotation = properties.rotation;

                if (properties.scale) this.scale = properties.scale;

                if (properties.origin) this.origin = properties.origin;

                if (properties.align) this.align = properties.align;

                if (properties.mountPoint) this.mountPoint = properties.mountPoint;

                if (properties.opacity) this.opacity = properties.opacity;
            }
        }]);
        return Transformable;
    }(_Sizeable2.default.mixin(base));

    (0, _defineProperty2.default)(Transformable, _hasInstance2.default, {
        value: function value(obj) {
            if (this !== Transformable) return (0, _getPrototypeOf2.default)(Transformable)[_hasInstance2.default].call(this, obj);

            var currentProto = obj;

            while (currentProto) {
                var desc = (0, _getOwnPropertyDescriptor2.default)(currentProto, "constructor");

                if (desc && desc.value && desc.value.hasOwnProperty(instanceofSymbol)) return true;

                currentProto = (0, _getPrototypeOf2.default)(currentProto);
            }

            return false;
        }
    });

    Transformable[instanceofSymbol] = true;

    // for use by MotorHTML, convenient since HTMLElement attributes are all
    // converted to lowercase by default, so if we don't do this then we won't be
    // able to map attributes to Node setters as easily.
    (0, _Utility.makeLowercaseSetterAliases)(Transformable.prototype);

    // So Tween.js can animate Transformable properties that are accessors.
    // Note, this makes all accessors enumerable even though we don't need to
    // animate them all, but it's not a big deal.
    (0, _Utility.makeAccessorsEnumerable)(Transformable.prototype);

    return Transformable;
};

function isRealNumber(num) {
    if (typeof num != 'number' || (0, _is2.default)(num, NaN) || (0, _is2.default)(num, Infinity)) return false;
    return true;
}

var Transformable = TransformableMixin(function () {
    function _class() {
        (0, _classCallCheck3.default)(this, _class);
    }

    return _class;
}());
Transformable.mixin = TransformableMixin;

exports.default = Transformable;
module.exports = exports['default'];
//# sourceMappingURL=Transformable.js.map