{"version":3,"sources":["../src/motor-html/base.js"],"names":["initMotorHTMLBase","proxyGettersSetters","DeclarativeBase","observers","hijack","original","oldRoot","shadowRoot","root","args","call","e","_hasShadowRoot","onV0ShadowRootReplaced","observer","shadowRootChildAdded","bind","shadowRootChildRemoved","set","children","child","_isPossiblyDistributed","imperativeCounterpart","addChild","HTMLContentElement","HTMLSlotElement","addEventListener","_handleDistributedChildren","removeChild","removeEventListener","_slotElementsAssignedNodes","delete","get","disconnect","i","childNodes","insertBefore","HTMLElement","prototype","createShadowRoot","Function","attachShadow","default","_shadowParent","_shadowChildren","_imperativeCounterpartPromise","resolve","then","_associateImperativeNode","mountPromise","_makeImperativeCounterpart","TypeError","_parent","event","type","slot","target","diff","_getDistributedChildDifference","added","addedNode","size","add","removed","removedNode","previousNodes","has","newNodes","assignedNodes","flatten","l","length","oldNode","newIndex","indexOf","push","splice","window","SourceClass","TargetClass","methodProxyBlacklist","props","prop","hasOwnProperty","targetDescriptor","sourceDescriptor","value"],"mappings":"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","file":"base.js","sourcesContent":["/* global HTMLSlotElement */\n\nimport WebComponent from './web-component'\nimport MotorHTMLNode from './node'\nimport { observeChildren, /*getShadowRootVersion,*/ hasShadowDomV0,\n    hasShadowDomV1, getAncestorShadowRoot } from '../motor/Utility'\n\nvar DeclarativeBase\n\n// Override HTMLElement.prototype.attachShadow in v1, and\n// HTMLElement.prototype.createShadowRoot in v0, so that we can make a Map of\n// motor- elements to their shadow roots, so we can always get a reference to\n// the element's shadow root even if it is closed.\nconst observers = new WeakMap\nfunction hijack(original) {\n    return function(...args) {\n        // In v0, shadow roots can be replaced, but in v1 calling attachShadow\n        // on an element that already has a root throws. So, we can set this to\n        // true, and if the try-catch passes then we know we have a v0 root and\n        // that the root was just replaced.\n        const oldRoot = this.shadowRoot\n        let root = null\n        try {\n            root = original.call(this, ...args)\n        }\n        catch (e) { throw e }\n        if (this instanceof DeclarativeBase) {\n            this._hasShadowRoot = true\n            if (oldRoot) {\n                onV0ShadowRootReplaced.call(this, oldRoot)\n            }\n            const observer = observeChildren(root, shadowRootChildAdded.bind(this), shadowRootChildRemoved.bind(this))\n            observers.set(root, observer)\n\n            for (const child of this.children) {\n                if (!(child instanceof DeclarativeBase)) continue\n                child._isPossiblyDistributed = true\n            }\n        }\n        return root\n    }\n}\nfunction shadowRootChildAdded(child) {\n\n    // NOTE Logic here is similar to childConnectedCallback\n\n    if (child instanceof DeclarativeBase) {\n        this.imperativeCounterpart.addChild(child.imperativeCounterpart)\n    }\n    else if (\n        hasShadowDomV0\n        && child instanceof HTMLContentElement\n    ) {\n        // observe <content> elements.\n    }\n    else if (\n        hasShadowDomV1\n        && child instanceof HTMLSlotElement\n    ) {\n        child.addEventListener('slotchange', this)\n        this._handleDistributedChildren(child)\n    }\n}\nfunction shadowRootChildRemoved(child) {\n\n    // NOTE Logic here is similar to childDisconnectedCallback\n\n    if (child instanceof DeclarativeBase) {\n        this.imperativeCounterpart.removeChild(child.imperativeCounterpart)\n    }\n    else if (\n        hasShadowDomV0\n        && child instanceof HTMLContentElement\n    ) {\n        // unobserve <content> element\n    }\n    else if (\n        hasShadowDomV1\n        && child instanceof HTMLSlotElement\n    ) {\n        child.removeEventListener('slotchange', this)\n        this._handleDistributedChildren(child)\n        this._slotElementsAssignedNodes.delete(child)\n    }\n}\nfunction onV0ShadowRootReplaced(oldRoot) {\n    observers.get(oldRoot).disconnect()\n    observers.delete(oldRoot)\n    let i = 0\n    for (const child of oldRoot.childNodes) {\n        if (!(child instanceof DeclarativeBase)) { i += 1; continue }\n\n        // We should disconnect the imperative connection (f.e. so it is\n        // not rendered in WebGL)...\n        this.imperativeCounterpart.removeChild(child.imperativeCounterpart)\n\n        // ...but we should place the element back where it was so there's\n        // no surprises to the HTML-API user who might go looking for the\n        // element. Due to the fact that the observer on the oldRoot was\n        // removed, adding the element back to the oldRoot won't cause it\n        // to be reconnected on the imperative side.\n        oldRoot.insertBefore(child, oldRoot.childNodes[i])\n\n        i += 1\n    }\n}\nif (HTMLElement.prototype.createShadowRoot instanceof Function)\n    HTMLElement.prototype.createShadowRoot = hijack(HTMLElement.prototype.createShadowRoot)\nif (HTMLElement.prototype.attachShadow instanceof Function)\n    HTMLElement.prototype.attachShadow = hijack(HTMLElement.prototype.attachShadow)\n\ninitMotorHTMLBase()\nexport function initMotorHTMLBase() {\n    if (DeclarativeBase) return\n\n    /**\n     * @implements {EventListener}\n     */\n    DeclarativeBase = class DeclarativeBase extends WebComponent(window.HTMLElement) {\n        createdCallback() {\n            super.createdCallback()\n\n            this.imperativeCounterpart = null // to hold the imperative API Node instance.\n\n            // true if this node has a shadow root (even if it is \"closed\", see\n            // hijack function above). Once true always true because shadow\n            // roots cannot be removed.\n            this._hasShadowRoot = false\n\n            // True when this node has a parent that has a shadow root. When\n            // using the HTML API, Imperative API can look at this to determine\n            // whether to render this node or not, in the case of WebGL.\n            this._isPossiblyDistributed = false\n\n            // A map of the slot elements that are children of this node and\n            // their last-known assigned nodes. When a slotchange happens while\n            // this node is in a shadow root and has a slot child, we can\n            // detect what the difference is between the last known and the new\n            // assignments, and notate the new distribution of child nodes. See\n            // issue #40 for background on why we do this.\n            this._slotElementsAssignedNodes = new WeakMap\n\n            // If this node is distributed into a shadow tree, this will\n            // reference the parent of the <slot> or <content> element.\n            // Basically, this node will render as a child of that parent node\n            // in the flat tree.\n            this._shadowParent = null\n\n            // If this element has a child <slot> or <content> element while in\n            // a shadow root, then this will be a Set of the nodes distributed\n            // into the <slot> or <content>, and those nodes render relatively\n            // to this node in the flat tree. We instantiate this later, only\n            // when/if needed.\n            this._shadowChildren = null\n\n            // We use Promise.resolve here to defer to the next microtask.\n            // While we support Custom Elements v0, this is necessary because\n            // the imperative Node counterpart will have already called the\n            // `_associateImperativeNode` method on this element, causing the\n            // next microtask's call to be a no-op. When this MotorHTML element\n            // API is used instead of the Imperative counterpart, then the next\n            // microtask's `_associateImperativeNode` call will not be a no-op.\n            // When we drop support for v0 Custom Elements at some point, we\n            // can rely on passing a constructor argument similarly to how we\n            // do with motor/Node in order to detect that the constructor is\n            // being called from the reciprocal API. See the constructor in\n            // motor/Node.js to get see the idea.\n            // TODO: renewable promise after unmount.\n            this._imperativeCounterpartPromise = Promise.resolve()\n                .then(() => this._associateImperativeNode())\n            this.mountPromise = this._imperativeCounterpartPromise\n                .then(() => this.imperativeCounterpart.mountPromise)\n        }\n\n        /**\n         * This method creates the association between this MotorHTMLNode instance\n         * and the imperative Node instance.\n         *\n         * This method may get called by this.init, but can also be called by\n         * the Node class if Node is used imperatively. See Node#constructor.\n         *\n         * @private\n         *\n         * @param {Object} imperativeCounterpart The imperative counterpart to\n         * associate with this MotorHTML element. This parameter is only used in the\n         * imperative API constructors, and this happens when using the imperative\n         * form of infamous instead of the HTML interface to infamous. When the HTML\n         * interface is used, this gets called first without an\n         * imperativeCounterpart argument and the call to this in an imperative\n         * constructor will be a noop. Basically, either this gets called first by a\n         * MotorHTML element, or first by an imperative instance, depending on which\n         * API is used first.\n         */\n        _associateImperativeNode(imperativeCounterpart) {\n            // if the association is made already, noop\n            if (this.imperativeCounterpart) return\n\n            // if called from an imperative-side class' constructor, associate\n            // the passed instance.\n            if (imperativeCounterpart) this.imperativeCounterpart = imperativeCounterpart\n\n            // otherwise if called from a MotorHTML class without an argument\n            else this.imperativeCounterpart = this._makeImperativeCounterpart()\n        }\n\n        /**\n         * This method should be overriden by child classes. It should return the\n         * imperative-side instance that the HTML-side class (this) corresponds to.\n         * @abstract\n         */\n        _makeImperativeCounterpart() {\n            throw new TypeError('This method should be implemented by classes extending DeclarativeBase.')\n        }\n\n        childConnectedCallback(child) {\n\n            // mirror the DOM connections in the imperative API's virtual scene graph.\n            if (child instanceof MotorHTMLNode) {\n                if (this._hasShadowRoot) child._isPossiblyDistributed = true\n\n                // If ImperativeBase#addChild was called first, child's\n                // _parent will already be set, so prevent recursion.\n                if (child.imperativeCounterpart._parent) return\n\n                this.imperativeCounterpart.addChild(child.imperativeCounterpart)\n            }\n            else if (\n                hasShadowDomV0\n                && child instanceof HTMLContentElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v0'\n            ) {\n                // observe <content> elements.\n            }\n            else if (\n                hasShadowDomV1\n                && child instanceof HTMLSlotElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v1'\n            ) {\n                child.addEventListener('slotchange', this)\n                this._handleDistributedChildren(child)\n            }\n        }\n\n        // This method is part of the EventListener interface.\n        handleEvent(event) {\n            if (event.type == 'slotchange') {\n                const slot = event.target\n                this._handleDistributedChildren(slot)\n            }\n        }\n\n        _handleDistributedChildren(slot) {\n            const diff = this._getDistributedChildDifference(slot)\n\n            for (const addedNode of diff.added) {\n                if (!(addedNode instanceof DeclarativeBase)) continue\n\n                // We do this because if the given slot is assigned to another\n                // slot, then this logic will run again for the next slot on\n                // that next slot's slotchange, so we remove the distributed\n                // node from the previous shadowParent and add it to the next\n                // one. If we don't do this, then the distributed node will\n                // exist in multiple shadowChildren lists when there is a\n                // chain of assigned slots. For more info, see\n                // https://github.com/w3c/webcomponents/issues/611\n                if (addedNode._shadowParent && addedNode._shadowParent._shadowChildren) {\n                    addedNode._shadowParent._shadowChildren.delete(addedNode)\n                    if (!addedNode._shadowParent._shadowChildren.size)\n                        addedNode._shadowParent._shadowChildren = null\n                }\n\n                addedNode._shadowParent = this\n                if (!this._shadowChildren) this._shadowChildren = new Set\n                this._shadowChildren.add(addedNode)\n            }\n\n            for (const removedNode of diff.removed) {\n                if (!(removedNode instanceof DeclarativeBase)) continue\n                removedNode._shadowParent = null\n                this._shadowChildren.delete(removedNode)\n                if (!this._shadowChildren.size) this._shadowChildren = null\n            }\n        }\n\n        _getDistributedChildDifference(slot) {\n            let previousNodes\n\n            if (this._slotElementsAssignedNodes.has(slot))\n                previousNodes = this._slotElementsAssignedNodes.get(slot)\n            else\n                previousNodes = []\n\n            const newNodes = slot.assignedNodes({flatten: true})\n\n            // save the newNodes to be used as the previousNodes for next time.\n            this._slotElementsAssignedNodes.set(slot, newNodes)\n\n            const diff = {\n                removed: [],\n            }\n\n            for (let i=0, l=previousNodes.length; i<l; i+=1) {\n                const oldNode = previousNodes[i]\n                const newIndex = newNodes.indexOf(oldNode)\n\n                // if it exists in the previousNodes but not the newNodes, then\n                // the node was removed.\n                if (!(newIndex >= 0)) {\n                    diff.removed.push(oldNode)\n                }\n\n                // otherwise the node wasn't added or removed.\n                else {\n                    newNodes.splice(i, 1)\n                }\n            }\n\n            // Remaining nodes in newNodes must have been added.\n            diff.added = newNodes\n\n            return diff\n        }\n\n        childDisconnectedCallback(child) {\n            // mirror the connection in the imperative API's virtual scene graph.\n            if (child instanceof MotorHTMLNode) {\n                child._isPossiblyDistributed = false\n\n                // If ImperativeBase#removeChild was called first, child's\n                // _parent will already be null, so prevent recursion.\n                if (!child.imperativeCounterpart._parent) return\n\n                this.imperativeCounterpart.removeChild(child.imperativeCounterpart)\n            }\n            else if (\n                hasShadowDomV0\n                && child instanceof HTMLContentElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v0'\n            ) {\n                // unobserve <content> element\n            }\n            else if (\n                hasShadowDomV1\n                && child instanceof HTMLSlotElement\n                &&\n                //getShadowRootVersion(\n                    getAncestorShadowRoot(this)\n                //) == 'v1'\n            ) {\n                child.removeEventListener('slotchange', this)\n                this._handleDistributedChildren(child)\n                this._slotElementsAssignedNodes.delete(child)\n            }\n        }\n    }\n}\n\n// Creates setters/getters on the TargetClass which proxy to the\n// setters/getters on SourceClass.\nexport function proxyGettersSetters(SourceClass, TargetClass) {\n\n    // Node methods not to proxy (private underscored methods are also detected and\n    // ignored).\n    const methodProxyBlacklist = [\n        'constructor',\n        'parent',\n        'children', // proxying this one would really break stuff (f.e. React)\n        'element',\n        'scene',\n        'addChild',\n        'addChildren',\n        'removeChild',\n        'removeChildren',\n    ]\n\n    const props = Object.getOwnPropertyNames(SourceClass.prototype)\n\n    for (const prop of props) {\n        if (\n            // skip the blacklisted properties\n            methodProxyBlacklist.indexOf(prop) >= 0\n\n            // skip the private underscored properties\n            || prop.indexOf('_') == 0\n\n            // skip properties that are already defined.\n            || TargetClass.prototype.hasOwnProperty(prop)\n        ) continue\n\n        const targetDescriptor = {}\n        const sourceDescriptor = Object.getOwnPropertyDescriptor(SourceClass.prototype, prop)\n\n        // if the property has a setter\n        if (sourceDescriptor.set) {\n            Object.assign(targetDescriptor, {\n                set(value) {\n                    this.imperativeCounterpart[prop] = value\n                }\n            })\n        }\n\n        // if the property has a getter\n        if (sourceDescriptor.get) {\n            Object.assign(targetDescriptor, {\n                get() {\n                    return this.imperativeCounterpart[prop]\n                }\n            })\n        }\n\n        Object.defineProperty(TargetClass.prototype, prop, targetDescriptor)\n    }\n}\n\nexport {DeclarativeBase as default}\n"]}