{"version":3,"sources":["../src/motor-html/web-component.js"],"names":["WebComponentMixin","window","HTMLElement","_HTMLElement","prototype","classCache","classExtendsHTMLElement","constructor","__proto__","elementClass","TypeError","has","get","WebComponent","document","Error","createdCallback","_attached","_initialized","_initialAttributeChange","_childObserver","_style","child","init","connectedCallback","rule","createRule","getStyles","applyTo","resolve","deinit","disconnectedCallback","_createStyles","childNodes","length","setTimeout","node","childConnectedCallback","childDisconnectedCallback","hasAttributes","attributes","attr","attributeChangedCallback","name","value","set"],"mappings":"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","file":"web-component.js","sourcesContent":["/* global customElements */\n\nimport { observeChildren } from '../motor/Utility'\nimport jss from '../jss'\n\n// Very very stupid hack needed for Safari in order for us to be able to extend\n// the HTMLElement class. See:\n// https://github.com/google/traceur-compiler/issues/1709\nif (typeof window.HTMLElement != 'function') {\n    const _HTMLElement = function HTMLElement(){}\n    _HTMLElement.prototype = window.HTMLElement.prototype\n    window.HTMLElement = _HTMLElement\n}\n\nconst classCache = new Map\n\nfunction classExtendsHTMLElement(constructor) {\n    if (!constructor) return false\n    if (constructor === HTMLElement) return true\n    else return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null)\n}\n\n/**\n * Creates a WebComponent base class dynamically, depending on which\n * HTMLElement class you want it to extend from. Extend from WebComponent when\n * making a new Custom Element class.\n *\n * @example\n * const WebComponent = WebComponentMixin(HTMLButtonElement)\n * class AwesomeButton extends WebComponent { ... }\n *\n * @param {Function} elementClass The class that the generated WebComponent\n * base class will extend from.\n */\nexport default\nfunction WebComponentMixin(elementClass) {\n    if (!elementClass) elementClass = HTMLElement\n\n    if (!classExtendsHTMLElement(elementClass)) {\n        throw new TypeError(\n            'The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.'\n        )\n    }\n\n    // if a base class that extends the given `elementClass` has already been\n    // created, return it.\n    if (classCache.has(elementClass))\n        return classCache.get(elementClass)\n\n    // otherwise, create it.\n    class WebComponent extends elementClass {\n\n        // constructor() is used in v1 Custom Elements instead of\n        // createdCallback() as in v0.\n        constructor() {\n            super()\n\n            // If the following is true, then we know the user should be using\n            // `document.registerElement()` to define an element from this class.\n            // `document.registerElement()` creates a new constructor, so if the\n            // constructor here is being called then that means the user is not\n            // instantiating a DOM HTMLElement as expected because it is required\n            // that the constructor returned from `document.registerElement` be used\n            // instead (this is a flaw of Custom Elements v0 which is fixed in v1\n            // where class constructors can be used directly).\n            if ('registerElement' in document && !('customElements' in window)) {\n                throw new Error(`\n                    You cannot instantiate this class directly without first registering it\n                    with \\`document.registerElement(...)\\`. See an example at http://....\n                `)\n            }\n\n            // Throw an error if no Custom Elements API exists.\n            if (!('registerElement' in document) && !('customElements' in window)) {\n                throw new Error(`\n                    Your browser does not support the Custom Elements API. You'll\n                    need to install a polyfill. See how at http://....\n                `)\n            }\n\n            // otherwise the V1 API exists, so call the createdCallback, which\n            // is what Custom Elements v0 would call by default. Subclasses of\n            // WebComponent should put instantiation logic in createdCallback\n            // instead of in a custom constructor if backwards compatibility is\n            // to be maintained.\n            this.createdCallback()\n        }\n\n        createdCallback() {\n            this._attached = false\n            this._initialized = false\n            this._initialAttributeChange = false\n            this._childObserver = null\n            this._style = null\n        }\n\n        // Subclasses can implement these.\n        childConnectedCallback(child) {}\n        childDisconnectedCallback(child) {}\n\n        connectedCallback() {\n            if (super.connectedCallback) super.connectedCallback()\n            this._attached = true\n\n            if (!this._initialized) {\n                this.init()\n                this._initialized = true\n            }\n        }\n        attachedCallback() { this.connectedCallback() } // back-compat\n\n        _createStyles() {\n            const rule = jss.createRule(this.getStyles())\n\n            rule.applyTo(this)\n\n            return rule\n        }\n\n        async disconnectedCallback() {\n            if (super.disconnectedCallback) super.disconnectedCallback()\n            this._attached = false\n\n            // Deferr to the next tick before cleaning up in case the\n            // element is actually being re-attached somewhere else within this\n            // same tick (detaching and attaching is synchronous, so by\n            // deferring to the next tick we'll be able to know if the element\n            // was re-attached or not in order to clean up or not). Note that\n            // appendChild can be used to move an element to another parent\n            // element, in which case connectedCallback and disconnectedCallback\n            // both get called, and in which case we don't necessarily want to\n            // clean up. If the element gets re-attached before the next tick\n            // (for example, gets moved), then we want to preserve the\n            // stuff that would be cleaned up by an extending class' deinit\n            // method by not running the following this.deinit() call.\n            await Promise.resolve() // deferr to the next tick.\n\n            // As mentioned in the previous comment, if the element was not\n            // re-attached in the last tick (for example, it was moved to\n            // another element), then clean up.\n            if (!this._attached && this._initialized) {\n                this.deinit()\n            }\n        }\n        detachedCallback() { this.disconnectedCallback() } // back-compat\n\n        /**\n         * This method can be overridden by extending classes, it should return\n         * JSS-compatible styling. See http://github.com/cssinjs/jss for\n         * documentation.\n         * @abstract\n         */\n        getStyles() {\n            return {}\n        }\n\n\n        /**\n         * Init is called exactly once, the first time this element is connected\n         * into the DOM. When an element is disconnected then connected right\n         * away within the same tick, init() is not fired again. However, if an\n         * element is disconnected and then some time passes and the current\n         * tick completes, then deinit() will be called, and the next time that\n         * the element is connected back into DOM init() will be called again.\n         *\n         * Subclasses should extend this to add such logic.\n         */\n        init() {\n            if (!this._style) this._style = this._createStyles()\n\n            // Handle any nodes that may have been connected before `this` node\n            // was created (f.e. child nodes that were connected before the\n            // custom elements were registered and which would therefore not be\n            // detected by the following MutationObserver).\n            if (!this._childObserver) {\n                if (this.childNodes.length) {\n\n                    // Timeout needed in case the Custom Element classes are\n                    // registered after the elements are already defined in the\n                    // DOM but not yet upgraded. This means that the `node` arg\n                    // might be a `<motor-node>` but if it isn't upgraded then\n                    // its API won't be available to the logic inside the\n                    // childConnectedCallback. The reason this happens is\n                    // because parents are upgraded first and their\n                    // connectedCallbacks fired before their children are\n                    // upgraded.\n                    setTimeout(() => {\n                        for (const node of this.childNodes) {\n                            this.childConnectedCallback(node)\n                        }\n                    }, 5)\n                }\n\n                this._childObserver = observeChildren(this, this.childConnectedCallback, this.childDisconnectedCallback)\n            }\n\n            // fire this.attributeChangedCallback in case some attributes have\n            // existed before the custom element was upgraded.\n            if (!this._initialAttributeChange && this.hasAttributes()) {\n\n                // HTMLElement#attributes is a NamedNodeMap which is not an\n                // iterable, so we use Array.from. See:\n                // https://github.com/zloirock/core-js/issues/234\n                for (const attr of Array.from(this.attributes))\n                    this.attributeChangedCallback(attr.name, null, attr.value)\n            }\n        }\n\n        attributeChangedCallback() {\n            if (super.attributeChangedCallback) super.attributeChangedCallback()\n            this._initialAttributeChange = true\n        }\n\n        /**\n         * This is the reciprocal of init(). It will be called when an element\n         * has been disconnected but not re-connected within the same tick.\n         *\n         * The reason that init() and deinit() exist is so that if an element is\n         * moved from one place to another within the same synchronous tick,\n         * that deinit and init logic will not fire unnecessarily. If logic is\n         * needed in that case, then connectedCallback and disconnectedCallback\n         * can be used directly instead.\n         */\n        deinit() {\n            // Nothing much at the moment, but extending classes can extend\n            // this to add deintialization logic.\n\n            this._initialized = false\n        }\n    }\n\n    classCache.set(elementClass, WebComponent)\n    return WebComponent\n}\n"]}