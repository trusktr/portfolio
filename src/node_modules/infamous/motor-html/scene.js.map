{"version":3,"sources":["../src/motor-html/scene.js"],"names":["privates","_","get","instance","set","MotorHTMLScene","_sizePollTask","_parentSize","x","y","z","_imperativeCounterpartPromise","then","imperativeCounterpart","_mounted","parentNode","mount","addRenderTask","_checkSize","bind","parent","parentSize","style","getComputedStyle","width","parseFloat","height","triggerEvent","_motorHtmlCounterpart","unmount","removeRenderTask","mixin","default","document","registerElement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AA0FA;;;;AAxFA;;AAEA,IAAMA,WAAW,uBAAjB;AACA,IAAMC,IAAI,SAAJA,CAAI,WAAY;AAClB,QAAI,CAACD,SAASE,GAAT,CAAaC,QAAb,CAAL,EAA6BH,SAASI,GAAT,CAAaD,QAAb,EAAuB,EAAvB;AAC7B,WAAOH,SAASE,GAAT,CAAaC,QAAb,CAAP;AACH,CAHD;;IAKME,c;;;;;;;;;;0CAEgB;AAAA;;AACd;;AAEA,iBAAKC,aAAL,GAAqB,IAArB;AACA,iBAAKC,WAAL,GAAmB,EAACC,GAAE,CAAH,EAAMC,GAAE,CAAR,EAAWC,GAAE,CAAb,EAAnB;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAKC,6BAAL,CACKC,IADL,CACU,YAAM;;AAER;AACA,oBAAI,OAAKC,qBAAL,CAA2BC,QAA/B,EAAyC;;AAEzC,oBAAI,OAAKC,UAAT,EACI,OAAKF,qBAAL,CAA2BG,KAA3B,CAAiC,OAAKD,UAAtC;AACP,aARL;AASH;;;4CAEmB;AAChB;AACA;AACA;AACA,gBAAI,CAAC,KAAKT,aAAV,EACI,KAAKA,aAAL,GAAqB,gBAAMW,aAAN,CAAoB,KAAKC,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAApB,CAArB;AACP;;AAED;AACA;;;;qCACa;;AAET;AACA;AACA,gBAAMC,SAAS,KAAKL,UAApB;AACA,gBAAMM,aAAa,KAAKd,WAAxB;AACA,gBAAMe,QAAQC,iBAAiBH,MAAjB,CAAd;AACA,gBAAMI,QAAQC,WAAWH,MAAME,KAAjB,CAAd;AACA,gBAAME,SAASD,WAAWH,MAAMI,MAAjB,CAAf;;AAEA;AACA,gBAAIL,WAAWb,CAAX,IAAgBgB,KAAhB,IAAyBH,WAAWZ,CAAX,IAAgBiB,MAA7C,EAAqD;AACjDL,2BAAWb,CAAX,GAAegB,KAAf;AACAH,2BAAWZ,CAAX,GAAeiB,MAAf;;AAEA,qBAAKC,YAAL,CAAkB,kBAAlB,EAAsC,sBAAc,EAAd,EAAkBN,UAAlB,CAAtC;AACH;AACJ;;;qDAE4B;AACzB,mBAAO,oBAAU;AACbO,uCAAuB;AADV,aAAV,CAAP;AAGH;;AAED;;;;oCACY;AACR;AACH;;;iCAEQ;AACL;;AAEA,iBAAKf,qBAAL,CAA2BgB,OAA3B;AACH;;;2CAEkB;AACf,4BAAMC,gBAAN,CAAuB,KAAKxB,aAA5B;AACA,iBAAKA,aAAL,GAAqB,IAArB;AACH;;;EAzEwB,qBAAWyB,KAAX,gB;;AA4E7B;AACA;;;AACA,mDAA8B1B,cAA9B;;AAGA,QAE0B2B,OAF1B,oBAAiBC,SAASC,eAAT,CAAyB,aAAzB,EAAwC7B,cAAxC,CAAjB;;QAE0B2B,O,GAAlB3B,c","file":"scene.js","sourcesContent":["\nimport styles from './scene-style'\nimport Motor from '../motor/Motor'\nimport Scene from '../motor/Scene'\nimport Observable from '../motor/Observable'\nimport Sizeable from '../motor/Sizeable'\nimport MotorHTMLBase, {initMotorHTMLBase, proxyGettersSetters} from './base'\n\ninitMotorHTMLBase()\n\nconst privates = new WeakMap()\nconst _ = instance => {\n    if (!privates.get(instance)) privates.set(instance, {})\n    return privates.get(instance)\n}\n\nclass MotorHTMLScene extends Observable.mixin(MotorHTMLBase) {\n\n    createdCallback() {\n        super.createdCallback()\n\n        this._sizePollTask = null\n        this._parentSize = {x:0, y:0, z:0}\n\n        // After the imperativeCounterpart is available it needs to register\n        // mount into DOM. This is only for MotorHTMLScenes because their\n        // imperativeCounterparts are not added to a parent Node.\n        // MotorHTMLNodes get their parent connection from their parent in\n        // childConnectedCallback.\n        this._imperativeCounterpartPromise\n            .then(() => {\n\n                // return if\n                if (this.imperativeCounterpart._mounted) return\n\n                if (this.parentNode)\n                    this.imperativeCounterpart.mount(this.parentNode)\n            })\n    }\n\n    _startSizePolling() {\n        // NOTE Polling is currently required because there's no other way to do this\n        // reliably, not even with MutationObserver. ResizeObserver hasn't\n        // landed in browsers yet.\n        if (!this._sizePollTask)\n            this._sizePollTask = Motor.addRenderTask(this._checkSize.bind(this))\n    }\n\n    // NOTE, the Z dimension of a scene doesn't matter, it's a flat plane, so\n    // we haven't taken that into consideration here.\n    _checkSize() {\n\n        // The scene has a parent by the time this is called (see\n        // src/motor/Scene#mount where _startSizePolling is called)\n        const parent = this.parentNode\n        const parentSize = this._parentSize\n        const style = getComputedStyle(parent)\n        const width = parseFloat(style.width)\n        const height = parseFloat(style.height)\n\n        // if we have a size change, trigger parentsizechange\n        if (parentSize.x != width || parentSize.y != height) {\n            parentSize.x = width\n            parentSize.y = height\n\n            this.triggerEvent('parentsizechange', Object.assign({}, parentSize))\n        }\n    }\n\n    _makeImperativeCounterpart() {\n        return new Scene({\n            _motorHtmlCounterpart: this\n        })\n    }\n\n    /** @override */\n    getStyles() {\n        return styles\n    }\n\n    deinit() {\n        super.deinit()\n\n        this.imperativeCounterpart.unmount()\n    }\n\n    _stopSizePolling() {\n        Motor.removeRenderTask(this._sizePollTask)\n        this._sizePollTask = null\n    }\n}\n\n// This associates the Transformable getters/setters with the HTML-API classes,\n// so that the same getters/setters can be called from HTML side of the API.\nproxyGettersSetters(Sizeable, MotorHTMLScene)\n\nimport 'document-register-element'\nMotorHTMLScene = document.registerElement('motor-scene', MotorHTMLScene)\n\nexport {MotorHTMLScene as default}\n"]}