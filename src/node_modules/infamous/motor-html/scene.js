'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _sceneStyle = require('./scene-style');

var _sceneStyle2 = _interopRequireDefault(_sceneStyle);

var _Motor = require('../motor/Motor');

var _Motor2 = _interopRequireDefault(_Motor);

var _Scene = require('../motor/Scene');

var _Scene2 = _interopRequireDefault(_Scene);

var _Observable = require('../motor/Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _Sizeable = require('../motor/Sizeable');

var _Sizeable2 = _interopRequireDefault(_Sizeable);

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

require('document-register-element');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _base.initMotorHTMLBase)();

var privates = new _weakMap2.default();
var _ = function _(instance) {
    if (!privates.get(instance)) privates.set(instance, {});
    return privates.get(instance);
};

var MotorHTMLScene = function (_Observable$mixin) {
    (0, _inherits3.default)(MotorHTMLScene, _Observable$mixin);

    function MotorHTMLScene() {
        (0, _classCallCheck3.default)(this, MotorHTMLScene);
        return (0, _possibleConstructorReturn3.default)(this, (MotorHTMLScene.__proto__ || (0, _getPrototypeOf2.default)(MotorHTMLScene)).apply(this, arguments));
    }

    (0, _createClass3.default)(MotorHTMLScene, [{
        key: 'createdCallback',
        value: function createdCallback() {
            var _this2 = this;

            (0, _get3.default)(MotorHTMLScene.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotorHTMLScene.prototype), 'createdCallback', this).call(this);

            this._sizePollTask = null;
            this._parentSize = { x: 0, y: 0, z: 0 };

            // After the imperativeCounterpart is available it needs to register
            // mount into DOM. This is only for MotorHTMLScenes because their
            // imperativeCounterparts are not added to a parent Node.
            // MotorHTMLNodes get their parent connection from their parent in
            // childConnectedCallback.
            this._imperativeCounterpartPromise.then(function () {

                // return if
                if (_this2.imperativeCounterpart._mounted) return;

                if (_this2.parentNode) _this2.imperativeCounterpart.mount(_this2.parentNode);
            });
        }
    }, {
        key: '_startSizePolling',
        value: function _startSizePolling() {
            // NOTE Polling is currently required because there's no other way to do this
            // reliably, not even with MutationObserver. ResizeObserver hasn't
            // landed in browsers yet.
            if (!this._sizePollTask) this._sizePollTask = _Motor2.default.addRenderTask(this._checkSize.bind(this));
        }

        // NOTE, the Z dimension of a scene doesn't matter, it's a flat plane, so
        // we haven't taken that into consideration here.

    }, {
        key: '_checkSize',
        value: function _checkSize() {

            // The scene has a parent by the time this is called (see
            // src/motor/Scene#mount where _startSizePolling is called)
            var parent = this.parentNode;
            var parentSize = this._parentSize;
            var style = getComputedStyle(parent);
            var width = parseFloat(style.width);
            var height = parseFloat(style.height);

            // if we have a size change, trigger parentsizechange
            if (parentSize.x != width || parentSize.y != height) {
                parentSize.x = width;
                parentSize.y = height;

                this.triggerEvent('parentsizechange', (0, _assign2.default)({}, parentSize));
            }
        }
    }, {
        key: '_makeImperativeCounterpart',
        value: function _makeImperativeCounterpart() {
            return new _Scene2.default({
                _motorHtmlCounterpart: this
            });
        }

        /** @override */

    }, {
        key: 'getStyles',
        value: function getStyles() {
            return _sceneStyle2.default;
        }
    }, {
        key: 'deinit',
        value: function deinit() {
            (0, _get3.default)(MotorHTMLScene.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotorHTMLScene.prototype), 'deinit', this).call(this);

            this.imperativeCounterpart.unmount();
        }
    }, {
        key: '_stopSizePolling',
        value: function _stopSizePolling() {
            _Motor2.default.removeRenderTask(this._sizePollTask);
            this._sizePollTask = null;
        }
    }]);
    return MotorHTMLScene;
}(_Observable2.default.mixin(_base2.default));

// This associates the Transformable getters/setters with the HTML-API classes,
// so that the same getters/setters can be called from HTML side of the API.


(0, _base.proxyGettersSetters)(_Sizeable2.default, MotorHTMLScene);

exports.default = MotorHTMLScene = document.registerElement('motor-scene', MotorHTMLScene);

exports.default = MotorHTMLScene;
module.exports = exports['default'];
//# sourceMappingURL=scene.js.map