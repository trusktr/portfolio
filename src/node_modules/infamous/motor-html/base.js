'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

exports.initMotorHTMLBase = initMotorHTMLBase;
exports.proxyGettersSetters = proxyGettersSetters;

var _webComponent = require('./web-component');

var _webComponent2 = _interopRequireDefault(_webComponent);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _Utility = require('../motor/Utility');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DeclarativeBase;

// Override HTMLElement.prototype.attachShadow in v1, and
// HTMLElement.prototype.createShadowRoot in v0, so that we can make a Map of
// motor- elements to their shadow roots, so we can always get a reference to
// the element's shadow root even if it is closed.
/* global HTMLSlotElement */

var observers = new _weakMap2.default();
function hijack(original) {
    return function () {
        // In v0, shadow roots can be replaced, but in v1 calling attachShadow
        // on an element that already has a root throws. So, we can set this to
        // true, and if the try-catch passes then we know we have a v0 root and
        // that the root was just replaced.
        var oldRoot = this.shadowRoot;
        var root = null;
        try {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            root = original.call.apply(original, [this].concat(args));
        } catch (e) {
            throw e;
        }
        if (this instanceof DeclarativeBase) {
            this._hasShadowRoot = true;
            if (oldRoot) {
                onV0ShadowRootReplaced.call(this, oldRoot);
            }
            var observer = (0, _Utility.observeChildren)(root, shadowRootChildAdded.bind(this), shadowRootChildRemoved.bind(this));
            observers.set(root, observer);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(this.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var child = _step.value;

                    if (!(child instanceof DeclarativeBase)) continue;
                    child._isPossiblyDistributed = true;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        return root;
    };
}
function shadowRootChildAdded(child) {

    // NOTE Logic here is similar to childConnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.addChild(child.imperativeCounterpart);
    } else if (_Utility.hasShadowDomV0 && child instanceof HTMLContentElement) {
        // observe <content> elements.
    } else if (_Utility.hasShadowDomV1 && child instanceof HTMLSlotElement) {
        child.addEventListener('slotchange', this);
        this._handleDistributedChildren(child);
    }
}
function shadowRootChildRemoved(child) {

    // NOTE Logic here is similar to childDisconnectedCallback

    if (child instanceof DeclarativeBase) {
        this.imperativeCounterpart.removeChild(child.imperativeCounterpart);
    } else if (_Utility.hasShadowDomV0 && child instanceof HTMLContentElement) {
        // unobserve <content> element
    } else if (_Utility.hasShadowDomV1 && child instanceof HTMLSlotElement) {
        child.removeEventListener('slotchange', this);
        this._handleDistributedChildren(child);
        this._slotElementsAssignedNodes.delete(child);
    }
}
function onV0ShadowRootReplaced(oldRoot) {
    observers.get(oldRoot).disconnect();
    observers.delete(oldRoot);
    var i = 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = (0, _getIterator3.default)(oldRoot.childNodes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var child = _step2.value;

            if (!(child instanceof DeclarativeBase)) {
                i += 1;continue;
            }

            // We should disconnect the imperative connection (f.e. so it is
            // not rendered in WebGL)...
            this.imperativeCounterpart.removeChild(child.imperativeCounterpart);

            // ...but we should place the element back where it was so there's
            // no surprises to the HTML-API user who might go looking for the
            // element. Due to the fact that the observer on the oldRoot was
            // removed, adding the element back to the oldRoot won't cause it
            // to be reconnected on the imperative side.
            oldRoot.insertBefore(child, oldRoot.childNodes[i]);

            i += 1;
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }
}
if (HTMLElement.prototype.createShadowRoot instanceof Function) HTMLElement.prototype.createShadowRoot = hijack(HTMLElement.prototype.createShadowRoot);
if (HTMLElement.prototype.attachShadow instanceof Function) HTMLElement.prototype.attachShadow = hijack(HTMLElement.prototype.attachShadow);

initMotorHTMLBase();
function initMotorHTMLBase() {
    if (DeclarativeBase) return;

    /**
     * @implements {EventListener}
     */
    exports.default = DeclarativeBase = function (_WebComponent) {
        (0, _inherits3.default)(DeclarativeBase, _WebComponent);

        function DeclarativeBase() {
            (0, _classCallCheck3.default)(this, DeclarativeBase);
            return (0, _possibleConstructorReturn3.default)(this, (DeclarativeBase.__proto__ || (0, _getPrototypeOf2.default)(DeclarativeBase)).apply(this, arguments));
        }

        (0, _createClass3.default)(DeclarativeBase, [{
            key: 'createdCallback',
            value: function createdCallback() {
                var _this2 = this;

                (0, _get3.default)(DeclarativeBase.prototype.__proto__ || (0, _getPrototypeOf2.default)(DeclarativeBase.prototype), 'createdCallback', this).call(this);

                this.imperativeCounterpart = null; // to hold the imperative API Node instance.

                // true if this node has a shadow root (even if it is "closed", see
                // hijack function above). Once true always true because shadow
                // roots cannot be removed.
                this._hasShadowRoot = false;

                // True when this node has a parent that has a shadow root. When
                // using the HTML API, Imperative API can look at this to determine
                // whether to render this node or not, in the case of WebGL.
                this._isPossiblyDistributed = false;

                // A map of the slot elements that are children of this node and
                // their last-known assigned nodes. When a slotchange happens while
                // this node is in a shadow root and has a slot child, we can
                // detect what the difference is between the last known and the new
                // assignments, and notate the new distribution of child nodes. See
                // issue #40 for background on why we do this.
                this._slotElementsAssignedNodes = new _weakMap2.default();

                // If this node is distributed into a shadow tree, this will
                // reference the parent of the <slot> or <content> element.
                // Basically, this node will render as a child of that parent node
                // in the flat tree.
                this._shadowParent = null;

                // If this element has a child <slot> or <content> element while in
                // a shadow root, then this will be a Set of the nodes distributed
                // into the <slot> or <content>, and those nodes render relatively
                // to this node in the flat tree. We instantiate this later, only
                // when/if needed.
                this._shadowChildren = null;

                // We use Promise.resolve here to defer to the next microtask.
                // While we support Custom Elements v0, this is necessary because
                // the imperative Node counterpart will have already called the
                // `_associateImperativeNode` method on this element, causing the
                // next microtask's call to be a no-op. When this MotorHTML element
                // API is used instead of the Imperative counterpart, then the next
                // microtask's `_associateImperativeNode` call will not be a no-op.
                // When we drop support for v0 Custom Elements at some point, we
                // can rely on passing a constructor argument similarly to how we
                // do with motor/Node in order to detect that the constructor is
                // being called from the reciprocal API. See the constructor in
                // motor/Node.js to get see the idea.
                // TODO: renewable promise after unmount.
                this._imperativeCounterpartPromise = _promise2.default.resolve().then(function () {
                    return _this2._associateImperativeNode();
                });
                this.mountPromise = this._imperativeCounterpartPromise.then(function () {
                    return _this2.imperativeCounterpart.mountPromise;
                });
            }

            /**
             * This method creates the association between this MotorHTMLNode instance
             * and the imperative Node instance.
             *
             * This method may get called by this.init, but can also be called by
             * the Node class if Node is used imperatively. See Node#constructor.
             *
             * @private
             *
             * @param {Object} imperativeCounterpart The imperative counterpart to
             * associate with this MotorHTML element. This parameter is only used in the
             * imperative API constructors, and this happens when using the imperative
             * form of infamous instead of the HTML interface to infamous. When the HTML
             * interface is used, this gets called first without an
             * imperativeCounterpart argument and the call to this in an imperative
             * constructor will be a noop. Basically, either this gets called first by a
             * MotorHTML element, or first by an imperative instance, depending on which
             * API is used first.
             */

        }, {
            key: '_associateImperativeNode',
            value: function _associateImperativeNode(imperativeCounterpart) {
                // if the association is made already, noop
                if (this.imperativeCounterpart) return;

                // if called from an imperative-side class' constructor, associate
                // the passed instance.
                if (imperativeCounterpart) this.imperativeCounterpart = imperativeCounterpart;

                // otherwise if called from a MotorHTML class without an argument
                else this.imperativeCounterpart = this._makeImperativeCounterpart();
            }

            /**
             * This method should be overriden by child classes. It should return the
             * imperative-side instance that the HTML-side class (this) corresponds to.
             * @abstract
             */

        }, {
            key: '_makeImperativeCounterpart',
            value: function _makeImperativeCounterpart() {
                throw new TypeError('This method should be implemented by classes extending DeclarativeBase.');
            }
        }, {
            key: 'childConnectedCallback',
            value: function childConnectedCallback(child) {

                // mirror the DOM connections in the imperative API's virtual scene graph.
                if (child instanceof _node2.default) {
                    if (this._hasShadowRoot) child._isPossiblyDistributed = true;

                    // If ImperativeBase#addChild was called first, child's
                    // _parent will already be set, so prevent recursion.
                    if (child.imperativeCounterpart._parent) return;

                    this.imperativeCounterpart.addChild(child.imperativeCounterpart);
                } else if (_Utility.hasShadowDomV0 && child instanceof HTMLContentElement &&
                //getShadowRootVersion(
                (0, _Utility.getAncestorShadowRoot)(this)
                //) == 'v0'
                ) {
                        // observe <content> elements.
                    } else if (_Utility.hasShadowDomV1 && child instanceof HTMLSlotElement &&
                //getShadowRootVersion(
                (0, _Utility.getAncestorShadowRoot)(this)
                //) == 'v1'
                ) {
                        child.addEventListener('slotchange', this);
                        this._handleDistributedChildren(child);
                    }
            }

            // This method is part of the EventListener interface.

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                if (event.type == 'slotchange') {
                    var slot = event.target;
                    this._handleDistributedChildren(slot);
                }
            }
        }, {
            key: '_handleDistributedChildren',
            value: function _handleDistributedChildren(slot) {
                var diff = this._getDistributedChildDifference(slot);

                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = (0, _getIterator3.default)(diff.added), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var addedNode = _step3.value;

                        if (!(addedNode instanceof DeclarativeBase)) continue;

                        // We do this because if the given slot is assigned to another
                        // slot, then this logic will run again for the next slot on
                        // that next slot's slotchange, so we remove the distributed
                        // node from the previous shadowParent and add it to the next
                        // one. If we don't do this, then the distributed node will
                        // exist in multiple shadowChildren lists when there is a
                        // chain of assigned slots. For more info, see
                        // https://github.com/w3c/webcomponents/issues/611
                        if (addedNode._shadowParent && addedNode._shadowParent._shadowChildren) {
                            addedNode._shadowParent._shadowChildren.delete(addedNode);
                            if (!addedNode._shadowParent._shadowChildren.size) addedNode._shadowParent._shadowChildren = null;
                        }

                        addedNode._shadowParent = this;
                        if (!this._shadowChildren) this._shadowChildren = new _set2.default();
                        this._shadowChildren.add(addedNode);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = (0, _getIterator3.default)(diff.removed), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var removedNode = _step4.value;

                        if (!(removedNode instanceof DeclarativeBase)) continue;
                        removedNode._shadowParent = null;
                        this._shadowChildren.delete(removedNode);
                        if (!this._shadowChildren.size) this._shadowChildren = null;
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            }
        }, {
            key: '_getDistributedChildDifference',
            value: function _getDistributedChildDifference(slot) {
                var previousNodes = void 0;

                if (this._slotElementsAssignedNodes.has(slot)) previousNodes = this._slotElementsAssignedNodes.get(slot);else previousNodes = [];

                var newNodes = slot.assignedNodes({ flatten: true });

                // save the newNodes to be used as the previousNodes for next time.
                this._slotElementsAssignedNodes.set(slot, newNodes);

                var diff = {
                    removed: []
                };

                for (var i = 0, l = previousNodes.length; i < l; i += 1) {
                    var oldNode = previousNodes[i];
                    var newIndex = newNodes.indexOf(oldNode);

                    // if it exists in the previousNodes but not the newNodes, then
                    // the node was removed.
                    if (!(newIndex >= 0)) {
                        diff.removed.push(oldNode);
                    }

                    // otherwise the node wasn't added or removed.
                    else {
                            newNodes.splice(i, 1);
                        }
                }

                // Remaining nodes in newNodes must have been added.
                diff.added = newNodes;

                return diff;
            }
        }, {
            key: 'childDisconnectedCallback',
            value: function childDisconnectedCallback(child) {
                // mirror the connection in the imperative API's virtual scene graph.
                if (child instanceof _node2.default) {
                    child._isPossiblyDistributed = false;

                    // If ImperativeBase#removeChild was called first, child's
                    // _parent will already be null, so prevent recursion.
                    if (!child.imperativeCounterpart._parent) return;

                    this.imperativeCounterpart.removeChild(child.imperativeCounterpart);
                } else if (_Utility.hasShadowDomV0 && child instanceof HTMLContentElement &&
                //getShadowRootVersion(
                (0, _Utility.getAncestorShadowRoot)(this)
                //) == 'v0'
                ) {
                        // unobserve <content> element
                    } else if (_Utility.hasShadowDomV1 && child instanceof HTMLSlotElement &&
                //getShadowRootVersion(
                (0, _Utility.getAncestorShadowRoot)(this)
                //) == 'v1'
                ) {
                        child.removeEventListener('slotchange', this);
                        this._handleDistributedChildren(child);
                        this._slotElementsAssignedNodes.delete(child);
                    }
            }
        }]);
        return DeclarativeBase;
    }((0, _webComponent2.default)(window.HTMLElement));
}

// Creates setters/getters on the TargetClass which proxy to the
// setters/getters on SourceClass.
function proxyGettersSetters(SourceClass, TargetClass) {

    // Node methods not to proxy (private underscored methods are also detected and
    // ignored).
    var methodProxyBlacklist = ['constructor', 'parent', 'children', // proxying this one would really break stuff (f.e. React)
    'element', 'scene', 'addChild', 'addChildren', 'removeChild', 'removeChildren'];

    var props = (0, _getOwnPropertyNames2.default)(SourceClass.prototype);

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        var _loop = function _loop() {
            var prop = _step5.value;

            if (
            // skip the blacklisted properties
            methodProxyBlacklist.indexOf(prop) >= 0

            // skip the private underscored properties
            || prop.indexOf('_') == 0

            // skip properties that are already defined.
            || TargetClass.prototype.hasOwnProperty(prop)) return 'continue';

            var targetDescriptor = {};
            var sourceDescriptor = (0, _getOwnPropertyDescriptor2.default)(SourceClass.prototype, prop);

            // if the property has a setter
            if (sourceDescriptor.set) {
                (0, _assign2.default)(targetDescriptor, {
                    set: function set(value) {
                        this.imperativeCounterpart[prop] = value;
                    }
                });
            }

            // if the property has a getter
            if (sourceDescriptor.get) {
                (0, _assign2.default)(targetDescriptor, {
                    get: function get() {
                        return this.imperativeCounterpart[prop];
                    }
                });
            }

            (0, _defineProperty2.default)(TargetClass.prototype, prop, targetDescriptor);
        };

        for (var _iterator5 = (0, _getIterator3.default)(props), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _ret = _loop();

            if (_ret === 'continue') continue;
        }
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }
}

exports.default = DeclarativeBase;
//# sourceMappingURL=base.js.map