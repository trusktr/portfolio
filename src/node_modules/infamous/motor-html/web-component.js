'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

exports.default = WebComponentMixin;

var _Utility = require('../motor/Utility');

var _jss = require('../jss');

var _jss2 = _interopRequireDefault(_jss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Very very stupid hack needed for Safari in order for us to be able to extend
// the HTMLElement class. See:
// https://github.com/google/traceur-compiler/issues/1709
/* global customElements */

if (typeof window.HTMLElement != 'function') {
    var _HTMLElement = function HTMLElement() {};
    _HTMLElement.prototype = window.HTMLElement.prototype;
    window.HTMLElement = _HTMLElement;
}

var classCache = new _map2.default();

function classExtendsHTMLElement(constructor) {
    if (!constructor) return false;
    if (constructor === HTMLElement) return true;else return classExtendsHTMLElement(constructor.prototype.__proto__ ? constructor.prototype.__proto__.constructor : null);
}

/**
 * Creates a WebComponent base class dynamically, depending on which
 * HTMLElement class you want it to extend from. Extend from WebComponent when
 * making a new Custom Element class.
 *
 * @example
 * const WebComponent = WebComponentMixin(HTMLButtonElement)
 * class AwesomeButton extends WebComponent { ... }
 *
 * @param {Function} elementClass The class that the generated WebComponent
 * base class will extend from.
 */
function WebComponentMixin(elementClass) {
    if (!elementClass) elementClass = HTMLElement;

    if (!classExtendsHTMLElement(elementClass)) {
        throw new TypeError('The argument to WebComponentMixin must be a constructor that extends from or is HTMLElement.');
    }

    // if a base class that extends the given `elementClass` has already been
    // created, return it.
    if (classCache.has(elementClass)) return classCache.get(elementClass);

    // otherwise, create it.

    var WebComponent = function (_elementClass) {
        (0, _inherits3.default)(WebComponent, _elementClass);

        // constructor() is used in v1 Custom Elements instead of
        // createdCallback() as in v0.
        function WebComponent() {
            (0, _classCallCheck3.default)(this, WebComponent);

            // If the following is true, then we know the user should be using
            // `document.registerElement()` to define an element from this class.
            // `document.registerElement()` creates a new constructor, so if the
            // constructor here is being called then that means the user is not
            // instantiating a DOM HTMLElement as expected because it is required
            // that the constructor returned from `document.registerElement` be used
            // instead (this is a flaw of Custom Elements v0 which is fixed in v1
            // where class constructors can be used directly).
            var _this = (0, _possibleConstructorReturn3.default)(this, (WebComponent.__proto__ || (0, _getPrototypeOf2.default)(WebComponent)).call(this));

            if ('registerElement' in document && !('customElements' in window)) {
                throw new Error('\n                    You cannot instantiate this class directly without first registering it\n                    with `document.registerElement(...)`. See an example at http://....\n                ');
            }

            // Throw an error if no Custom Elements API exists.
            if (!('registerElement' in document) && !('customElements' in window)) {
                throw new Error('\n                    Your browser does not support the Custom Elements API. You\'ll\n                    need to install a polyfill. See how at http://....\n                ');
            }

            // otherwise the V1 API exists, so call the createdCallback, which
            // is what Custom Elements v0 would call by default. Subclasses of
            // WebComponent should put instantiation logic in createdCallback
            // instead of in a custom constructor if backwards compatibility is
            // to be maintained.
            _this.createdCallback();
            return _this;
        }

        (0, _createClass3.default)(WebComponent, [{
            key: 'createdCallback',
            value: function createdCallback() {
                this._attached = false;
                this._initialized = false;
                this._initialAttributeChange = false;
                this._childObserver = null;
                this._style = null;
            }

            // Subclasses can implement these.

        }, {
            key: 'childConnectedCallback',
            value: function childConnectedCallback(child) {}
        }, {
            key: 'childDisconnectedCallback',
            value: function childDisconnectedCallback(child) {}
        }, {
            key: 'connectedCallback',
            value: function connectedCallback() {
                if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'connectedCallback', this)) (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'connectedCallback', this).call(this);
                this._attached = true;

                if (!this._initialized) {
                    this.init();
                    this._initialized = true;
                }
            }
        }, {
            key: 'attachedCallback',
            value: function attachedCallback() {
                this.connectedCallback();
            } // back-compat

        }, {
            key: '_createStyles',
            value: function _createStyles() {
                var rule = _jss2.default.createRule(this.getStyles());

                rule.applyTo(this);

                return rule;
            }
        }, {
            key: 'disconnectedCallback',
            value: function () {
                var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
                    return _regenerator2.default.wrap(function _callee$(_context) {
                        while (1) {
                            switch (_context.prev = _context.next) {
                                case 0:
                                    if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'disconnectedCallback', this)) (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'disconnectedCallback', this).call(this);
                                    this._attached = false;

                                    // Deferr to the next tick before cleaning up in case the
                                    // element is actually being re-attached somewhere else within this
                                    // same tick (detaching and attaching is synchronous, so by
                                    // deferring to the next tick we'll be able to know if the element
                                    // was re-attached or not in order to clean up or not). Note that
                                    // appendChild can be used to move an element to another parent
                                    // element, in which case connectedCallback and disconnectedCallback
                                    // both get called, and in which case we don't necessarily want to
                                    // clean up. If the element gets re-attached before the next tick
                                    // (for example, gets moved), then we want to preserve the
                                    // stuff that would be cleaned up by an extending class' deinit
                                    // method by not running the following this.deinit() call.
                                    _context.next = 4;
                                    return _promise2.default.resolve();

                                case 4:
                                    // deferr to the next tick.

                                    // As mentioned in the previous comment, if the element was not
                                    // re-attached in the last tick (for example, it was moved to
                                    // another element), then clean up.
                                    if (!this._attached && this._initialized) {
                                        this.deinit();
                                    }

                                case 5:
                                case 'end':
                                    return _context.stop();
                            }
                        }
                    }, _callee, this);
                }));

                function disconnectedCallback() {
                    return _ref.apply(this, arguments);
                }

                return disconnectedCallback;
            }()
        }, {
            key: 'detachedCallback',
            value: function detachedCallback() {
                this.disconnectedCallback();
            } // back-compat

            /**
             * This method can be overridden by extending classes, it should return
             * JSS-compatible styling. See http://github.com/cssinjs/jss for
             * documentation.
             * @abstract
             */

        }, {
            key: 'getStyles',
            value: function getStyles() {
                return {};
            }

            /**
             * Init is called exactly once, the first time this element is connected
             * into the DOM. When an element is disconnected then connected right
             * away within the same tick, init() is not fired again. However, if an
             * element is disconnected and then some time passes and the current
             * tick completes, then deinit() will be called, and the next time that
             * the element is connected back into DOM init() will be called again.
             *
             * Subclasses should extend this to add such logic.
             */

        }, {
            key: 'init',
            value: function init() {
                var _this2 = this;

                if (!this._style) this._style = this._createStyles();

                // Handle any nodes that may have been connected before `this` node
                // was created (f.e. child nodes that were connected before the
                // custom elements were registered and which would therefore not be
                // detected by the following MutationObserver).
                if (!this._childObserver) {
                    if (this.childNodes.length) {

                        // Timeout needed in case the Custom Element classes are
                        // registered after the elements are already defined in the
                        // DOM but not yet upgraded. This means that the `node` arg
                        // might be a `<motor-node>` but if it isn't upgraded then
                        // its API won't be available to the logic inside the
                        // childConnectedCallback. The reason this happens is
                        // because parents are upgraded first and their
                        // connectedCallbacks fired before their children are
                        // upgraded.
                        setTimeout(function () {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = (0, _getIterator3.default)(_this2.childNodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var node = _step.value;

                                    _this2.childConnectedCallback(node);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }, 5);
                    }

                    this._childObserver = (0, _Utility.observeChildren)(this, this.childConnectedCallback, this.childDisconnectedCallback);
                }

                // fire this.attributeChangedCallback in case some attributes have
                // existed before the custom element was upgraded.
                if (!this._initialAttributeChange && this.hasAttributes()) {

                    // HTMLElement#attributes is a NamedNodeMap which is not an
                    // iterable, so we use Array.from. See:
                    // https://github.com/zloirock/core-js/issues/234
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = (0, _getIterator3.default)((0, _from2.default)(this.attributes)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var attr = _step2.value;

                            this.attributeChangedCallback(attr.name, null, attr.value);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            }
        }, {
            key: 'attributeChangedCallback',
            value: function attributeChangedCallback() {
                if ((0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'attributeChangedCallback', this)) (0, _get3.default)(WebComponent.prototype.__proto__ || (0, _getPrototypeOf2.default)(WebComponent.prototype), 'attributeChangedCallback', this).call(this);
                this._initialAttributeChange = true;
            }

            /**
             * This is the reciprocal of init(). It will be called when an element
             * has been disconnected but not re-connected within the same tick.
             *
             * The reason that init() and deinit() exist is so that if an element is
             * moved from one place to another within the same synchronous tick,
             * that deinit and init logic will not fire unnecessarily. If logic is
             * needed in that case, then connectedCallback and disconnectedCallback
             * can be used directly instead.
             */

        }, {
            key: 'deinit',
            value: function deinit() {
                // Nothing much at the moment, but extending classes can extend
                // this to add deintialization logic.

                this._initialized = false;
            }
        }]);
        return WebComponent;
    }(elementClass);

    classCache.set(elementClass, WebComponent);
    return WebComponent;
}
module.exports = exports['default'];
//# sourceMappingURL=web-component.js.map